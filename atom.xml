<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>watson&#39;blogs</title>
  
  
  <link href="https://watsonlu6.github.io/atom.xml" rel="self"/>
  
  <link href="https://watsonlu6.github.io/"/>
  <updated>2025-04-26T13:48:25.025Z</updated>
  <id>https://watsonlu6.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>13 virsh使用</title>
    <link href="https://watsonlu6.github.io/13-virsh%E4%BD%BF%E7%94%A8/"/>
    <id>https://watsonlu6.github.io/13-virsh%E4%BD%BF%E7%94%A8/</id>
    <published>2024-04-01T07:50:26.000Z</published>
    <updated>2025-04-26T13:48:25.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 <strong>概述</strong></h1><p>virsh [<em>选项</em>]… [<em>命令字符串</em>]</p><p>virsh [<em>选项</em>]… <em>命令</em> [<em>参数</em>]…</p><h1 id="2-描述"><a href="#2-描述" class="headerlink" title="2 描述"></a>2 <strong>描述</strong></h1><p>virsh 程序是用于管理 virsh 客户域的主要接口。该程序可用于创建、暂停和关闭域，还可以用于列出当前域。Libvirt 是一个 C 工具包，用于与 Linux（及其他操作系统）最新版本的虚拟化功能交互。它是在 GNU 宽通用公共许可证下可用的免费软件。Linux 操作系统的虚拟化意味着能够在单个硬件系统上同时运行多个操作系统实例，其中基本资源由 Linux 实例驱动。该库旨在提供长期稳定的 C API。目前支持 Xen、QEMU、KVM、LXC、OpenVZ、VirtualBox 和 VMware ESX。</p><p>大多数 virsh 使用的基本结构如下：</p><p>virsh [<em>选项</em>]… &lt;*命令*&gt; &lt;*域*&gt; [<em>参数</em>]…</p><p>其中，<em>命令</em> 是下面列出的命令之一；<em>域</em> 是数字域 ID、域名或域 UUID；<em>参数</em> 是特定于命令的选项。少数例外情况是命令作用于所有域、整个机器或直接作用于 Xen 虚拟机管理程序时。这些例外情况将在相关命令中明确说明。注意：可以为域指定数字名称，但这样做会导致域只能通过域 ID 识别。换句话说，如果提供数字值，它将被解释为域 ID，而不是名称。任何以 # 开头的 <em>命令</em> 将被视为注释并静默忽略，所有其他无法识别的 <em>命令</em> 将被诊断。</p><p>virsh 程序可以通过在 shell 命令行中提供命令及其参数来运行单个 <em>命令</em>，也可以通过 <em>命令字符串</em> 运行，<em>命令字符串</em> 是一个由多个 <em>命令</em> 操作及其参数组成的单个 shell 参数，命令之间用空格分隔，并用分号或换行符分隔，其中未引用的反斜杠换行对将被省略。在 <em>命令字符串</em> 中，virsh 理解与 shell 相同的单引号、双引号和反斜杠转义，但在创建单个 shell 参数时必须添加另一层 shell 转义，任何以未引用的 <em>#</em> 开头的单词将开始一个注释，直到换行符结束。如果在命令行中未给出命令，virsh 将启动一个最小的解释器等待输入命令，然后使用 quit 命令退出程序。</p><p>virsh 程序支持以下 <em>选项</em>。</p><p>-c, --connect <em>URI</em><br>连接到指定的 <em>URI</em>，类似于 connect 命令，而不是默认连接。</p><p>-d, --debug <em>级别</em><br>启用整数 <em>级别</em> 及更高级别的调试消息。<em>级别</em> 范围为 0 到 4（默认值）。有关每个 <em>级别</em> 的描述，请参阅下面 VIRSH_DEBUG 环境变量的文档。</p><p>-e, --escape <em>字符串</em><br>为 <em>console</em> 命令设置替代转义序列。默认使用 telnet 的 ^]。使用脱字符表示法时允许的字符为：字母字符、@、[、]、\、^、_。</p><p>-h, --help<br>忽略所有其他参数，并表现得像给出了 help 命令一样。</p><p>-k, --keepalive-interval <em>间隔</em><br>设置发送保活消息的 <em>间隔</em>（以秒为单位），以检查与服务器的连接是否仍然存活。将间隔设置为 0 会禁用客户端保活机制。</p><p>-K, --keepalive-count <em>计数</em><br>设置在服务器未响应的情况下可以发送保活消息的次数，而不会将连接标记为死亡。如果 <em>间隔</em> 设置为 0，则此设置无效。</p><p>-l, --log <em>文件</em><br>将日志详细信息输出到 <em>文件</em>。</p><p>-q, --quiet<br>避免额外的信息性消息。</p><p>-r, --readonly<br>使初始连接为只读，类似于 connect 命令的 <em>--readonly</em> 选项。</p><p>-t, --timing<br>输出每个命令的耗时信息。</p><p>-v, --version[&#x3D;short]<br>忽略所有其他参数，并打印 virsh 所使用的 libvirt 库的版本。</p><p>-V, --version&#x3D;long<br>忽略所有其他参数，并打印 virsh 所使用的 libvirt 库的版本以及编译的选项和驱动程序。</p><h1 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3 注意事项"></a>3 <strong>注意事项</strong></h1><p>大多数 virsh 操作依赖于 libvirt 库能够连接到已运行的 libvirtd 服务。通常可以使用命令 <code>service libvirtd start</code> 完成此操作。</p><p>由于与虚拟机管理程序通信所使用的通道，大多数 virsh 命令需要 root 权限才能运行。以非 root 用户身份运行将返回错误。</p><p>大多数 virsh 命令是同步执行的，除了 shutdown、setvcpus 和 setmem 等少数命令。在这些情况下，virsh 程序返回并不意味着操作已完成，必须定期轮询以检测客户机是否已完成操作。</p><p>virsh 致力于向后兼容。尽管 help 命令仅列出命令的首选用法，但如果旧版本的 virsh 支持命令或选项的替代拼写（例如 <em>--tunnelled</em> 而不是 <em>--tunneled</em>），则使用旧拼写的脚本将继续有效。</p><p>一些 virsh 命令接受可选的带单位的整数；如果未提供单位，则命令中会列出默认单位（出于历史原因，某些命令默认为字节，而其他命令默认为千字节）。以下不区分大小写的后缀可用于选择特定单位：</p><p>b, byte 字节 1<br>KB 千字节 1,000<br>k, KiB 千二进制字节 1,024<br>MB 兆字节 1,000,000<br>M, MiB 兆二进制字节 1,048,576<br>GB 吉字节 1,000,000,000<br>G, GiB 吉二进制字节 1,073,741,824<br>TB 太字节 1,000,000,000,000<br>T, TiB 太二进制字节 1,099,511,627,776<br>PB 拍字节 1,000,000,000,000,000<br>P, PiB 拍二进制字节 1,125,899,906,842,624<br>EB 艾字节 1,000,000,000,000,000,000<br>E, EiB 艾二进制字节 1,152,921,504,606,846,976</p><h1 id="4-通用命令"><a href="#4-通用命令" class="headerlink" title="4 通用命令"></a>4 <strong>通用命令</strong></h1><p>以下命令是通用的，即不特定于某个域。</p><p><strong>help</strong></p><p><strong>语法：</strong></p><p>help [命令或分组]</p><p>此命令列出每个 virsh 命令。不带选项使用时，所有命令将按相关类别分组显示，每行一个命令，并显示每个分组的关键字。</p><p>要仅显示特定分组的命令，请将该分组的关键字作为选项。例如：</p><p><strong>示例 1：</strong></p><p>virsh # help host</p><p>主机和虚拟机管理程序（帮助关键字 ‘host’）:</p><p>capabilities              显示功能<br>cpu-models                显示架构的 CPU 型号<br>connect                   连接到虚拟机管理程序<br>freecell                  NUMA 空闲内存<br>hostname                  打印虚拟机管理程序主机名<br>qemu-attach               附加到现有 QEMU 进程<br>qemu-monitor-command      QEMU 监视器命令<br>qemu-agent-command        QEMU 客户机代理命令<br>sysinfo                   打印虚拟机管理程序系统信息<br>uri                       打印虚拟机管理程序规范 URI  </p><p>要显示特定命令的详细信息，请将其名称作为选项。例如：</p><p><strong>示例 2：</strong></p><p>virsh # help list</p><p>名称<br>list - 列出域  </p><p>概要<br>list [–inactive] [–all]  </p><p>描述<br>返回域列表。  </p><p>选项<br>–inactive  列出非活动域<br>–all       列出非活动和活动域  </p><p><strong>quit, exit</strong></p><p><strong>语法：</strong></p><p>quit<br>exit  </p><p>退出交互式终端。  </p><p><strong>version</strong></p><p><strong>语法：</strong></p><p>version [–daemon]  </p><p>打印此构建的主要版本信息。如果指定 <em>–daemon</em>，则输出中会包含 libvirt 守护程序的版本。  </p><p><strong>示例：</strong></p><p>$ virsh version<br>Compiled against library: libvirt 1.2.3<br>Using library: libvirt 1.2.3<br>Using API: QEMU 1.2.3<br>Running hypervisor: QEMU 2.0.50  </p><p>$ virsh version –daemon<br>Compiled against library: libvirt 1.2.3<br>Using library: libvirt 1.2.3<br>Using API: QEMU 1.2.3<br>Running hypervisor: QEMU 2.0.50<br>Running against daemon: 1.2.6  </p><p><strong>cd</strong></p><p><strong>语法：</strong></p><p>cd [目录]  </p><p>将当前目录更改为 <em>目录</em>。cd 命令的默认目录是主目录，如果环境中没有 <em>HOME</em> 变量，则为根目录。  </p><p><strong>pwd</strong></p><p><strong>语法：</strong></p><p>pwd  </p><p>打印当前目录。  </p><p><strong>connect</strong></p><p><strong>语法：</strong></p><p>connect [URI] [–readonly]  </p><p>（重新）连接到虚拟机管理程序。当 shell 首次启动时，此命令会自动运行，并使用命令行中 -c 选项请求的 <em>URI</em> 参数。<em>URI</em> 参数指定如何连接到虚拟机管理程序。URI 文档 <a href="https://libvirt.org/uri.html">https://libvirt.org/uri.html</a> 列出了支持的值，但最常见的有：  </p><ul><li><p>xen:&#x2F;&#x2F;&#x2F;system<br>用于连接到本地 Xen 虚拟机管理程序。  </p></li><li><p>qemu:&#x2F;&#x2F;&#x2F;system<br>以 root 身份连接到本地监督 QEMU 和 KVM 域的守护程序。  </p></li><li><p>qemu:&#x2F;&#x2F;&#x2F;session<br>以普通用户身份连接到其自己的 QEMU 和 KVM 域集。  </p></li><li><p>lxc:&#x2F;&#x2F;&#x2F;system<br>连接到本地 Linux 容器。</p></li></ul><p>要查找当前使用的 URI，请查看下面记录的 <em>uri</em> 命令。  </p><p>对于远程访问，请参阅 URI 文档 <a href="https://libvirt.org/uri.html">https://libvirt.org/uri.html</a> 了解如何创建 URI。*–readonly* 选项允许只读连接。  </p><p><strong>uri</strong></p><p><strong>语法：</strong></p><p>uri  </p><p>打印虚拟机管理程序的规范 URI，在 shell 模式下可能有用。  </p><p><strong>hostname</strong></p><p><strong>语法：</strong></p><p>hostname  </p><p>打印虚拟机管理程序的主机名。  </p><p><strong>sysinfo</strong></p><p><strong>语法：</strong></p><p>sysinfo  </p><p>打印虚拟机管理程序的 XML 表示的系统信息（如果可用）。  </p><p><strong>nodeinfo</strong></p><p><strong>语法：</strong></p><p>nodeinfo  </p><p>返回有关节点的基本信息，例如 CPU 的数量和类型，以及物理内存的大小。  </p><p>强烈不建议使用此命令，因为提供的信息不能保证在所有硬件平台上都准确。  </p><p><em>CPU 频率</em> 值仅反映机器中第一个 CPU 当前的运行速度。此速度可能因 CPU 而异，并且会随着主机操作系统调整而变化。  </p><p>用于获取数据的数据结构不可扩展，因此仅支持全局节点&#x2F;插槽&#x2F;核心&#x2F;线程（插槽&#x2F;核心&#x2F;线程是每个 NUMA 节点）拓扑信息。如果主机 CPU 有任何进一步的分组（例如 die、集群等）或 NUMA 拓扑不对称，则数据结构无法真实表示系统。在这种情况下，将报告一个伪造的拓扑（节点 &#x3D; 1，插槽 &#x3D; 1，核心 &#x3D; 主机 CPU 数量，线程 &#x3D; 1），仅正确表示主机 CPU 总数。  </p><p>建议使用 <em>capabilities</em> 命令替代，该命令在 &#x2F;capabilities&#x2F;host&#x2F;topology XPath 下报告数据（频率除外）。  </p><p><strong>nodecpumap</strong></p><p><strong>语法：</strong></p><p>nodecpumap [–pretty]  </p><p>显示节点的 CPU 总数、在线 CPU 数量以及在线 CPU 列表。  </p><p>使用 <em>–pretty</em> 时，在线 CPU 将以范围形式打印，而不是列表形式。  </p><p><strong>nodecpustats</strong></p><p><strong>语法：</strong></p><p>nodecpustats [CPU] [–percent]  </p><p>返回节点的 CPU 统计信息。如果指定 <em>CPU</em>，则仅打印指定 CPU 的统计信息。如果指定 <em>–percent</em>，则打印每种 CPU 统计信息在 1 秒内的百分比。  </p><p><strong>nodememstats</strong></p><p><strong>语法：</strong></p><p>nodememstats [单元]  </p><p>返回节点的内存统计信息。如果指定 <em>单元</em>，则仅打印指定单元的统计信息。  </p><p><strong>nodesevinfo</strong></p><p><strong>语法：</strong></p><p>nodesevinfo  </p><p>报告有关节点的 AMD SEV 启动安全功能的信息（如果有）。其中一些信息也会在域功能 XML 文档中报告。  </p><p><strong>nodesuspend</strong></p><p><strong>语法：</strong></p><p>nodesuspend [目标] [持续时间]  </p><p>将节点（主机）置于系统范围的睡眠状态，并安排节点的实时时钟中断在指定的 <em>持续时间</em> 后恢复节点。<em>目标</em> 指定主机将挂起到的状态，可以是 “mem”（挂起到 RAM）、”disk”（挂起到磁盘）或 “hybrid”（挂起到 RAM 和磁盘）。<em>持续时间</em> 指定主机挂起的时间（以秒为单位），应至少为 60 秒。  </p><p><strong>node-memory-tune</strong></p><p><strong>语法：</strong></p><p>node-memory-tune [shm-pages-to-scan] [shm-sleep-millisecs] [shm-merge-across-nodes]  </p><p>允许显示或设置节点内存参数。<em>shm-pages-to-scan</em> 可用于设置共享内存服务在休眠前扫描的页数；<em>shm-sleep-millisecs</em> 可用于设置共享内存服务在下一次扫描前休眠的毫秒数；<em>shm-merge-across-nodes</em> 指定是否可以从不同的 NUMA 节点合并页。设置为 0 时，仅可以合并物理位于同一 NUMA 节点内存区域的页。设置为 1 时，可以合并所有节点的页。默认为 1。  </p><p>注意：当前“共享内存服务”仅指 KSM（内核同页合并）。  </p><p><strong>capabilities</strong></p><p><strong>语法：</strong></p><p>capabilities [–xpath 表达式] [–wrap]  </p><p>打印描述当前连接的虚拟机管理程序功能的 XML 文档。这包括主机在 CPU 和功能方面的能力部分，以及每种可以虚拟化的客户机的描述集。更完整的描述请参阅：<br><a href="https://libvirt.org/formatcaps.html">https://libvirt.org/formatcaps.html</a>  </p><p>XML 还显示 NUMA 拓扑信息（如果可用）。  </p><p>如果 <strong>–xpath</strong> 参数提供 XPath 表达式，则将对输出 XML 求值，并仅打印匹配的节点。默认行为是将每个匹配节点打印为独立文档，但为了方便进一步处理，**–wrap** 参数会将匹配节点包装在公共根节点中。  </p><p><strong>domcapabilities</strong></p><p><strong>语法：</strong></p><p>domcapabilities [virttype] [emulatorbin] [arch] [machine]<br>[–xpath 表达式] [–wrap]<br>[–disable-deprecated-features]  </p><p>打印描述当前连接的虚拟机管理程序域功能的 XML 文档，这些信息可以来自现有域或 virsh capabilities 输出。如果您打算创建新域并想知道它是否可以通过为特定模拟器和架构创建域来使用 VFIO，这可能很有用。  </p><p>每个虚拟机管理程序对哪些选项是必需的、哪些是可选的会有不同的要求。虚拟机管理程序可以支持为任何选项提供默认值。  </p><p><em>virttype</em> 选项指定使用的虚拟化类型。该值可以来自域 XML 中 &lt;domain&#x2F;&gt; 顶级元素的 ‘type’ 属性，也可以来自 virsh capabilities 输出中每个 &lt;guest&#x2F;&gt; 元素的 ‘type’ 属性。<em>emulatorbin</em> 选项指定模拟器的路径。该值可以来自域 XML 中的 &lt;emulator&gt; 元素或 virsh capabilities 输出。<em>arch</em> 选项指定用于域的架构。该值可以来自域 XML 中 &lt;os&#x2F;&gt; 元素和 &lt;type&#x2F;&gt; 子元素的 “arch” 属性，也可以来自 virsh capabilities 输出中 &lt;arch&#x2F;&gt; 元素的 “name” 属性。<em>machine</em> 指定模拟器的机器类型。该值可以来自域 XML 中 &lt;os&#x2F;&gt; 元素和 &lt;type&#x2F;&gt; 子元素的 “machine” 属性，也可以来自 virsh capabilities 输出中特定架构和域类型的机器列表。  </p><p>对于 QEMU 虚拟机管理程序，必须提供 <em>virttype</em> 为 ‘qemu’ 或 ‘kvm’ 以及 <em>emulatorbin</em> 或 <em>arch</em> 才能为默认 <em>machine</em> 生成输出。提供 <em>machine</em> 值将为特定机器生成输出。  </p><p>如果 <strong>–xpath</strong> 参数提供 XPath 表达式，则将对输出 XML 求值，并仅打印匹配的节点。默认行为是将每个匹配节点打印为独立文档，但为了方便进一步处理，**–wrap** 参数会将匹配节点包装在公共根节点中。  </p><p><strong>–disable-deprecated-features</strong> 参数将修改 host-model CPU XML 的内容，更新功能列表，其中包含虚拟机管理程序标记为已弃用的 CPU 模型的任何功能。这些功能将与 “disable” 策略配对。  </p><p><strong>pool-capabilities</strong></p><p><strong>语法：</strong></p><p>pool-capabilities  </p><p>打印描述连接的存储驱动程序存储池功能的 XML 文档。如果您打算创建新存储池并需要了解可用的池类型、支持的存储池源和目标卷格式以及创建池所需的源元素，这可能很有用。  </p><p><strong>inject-nmi</strong></p><p><strong>语法：</strong></p><p>inject-nmi 域  </p><p>向客户机注入 NMI。  </p><p><strong>list</strong></p><p><strong>语法：</strong></p><p>list [–inactive | –all]<br>[–managed-save] [–title]<br>{ [–table] | –name | –id } [–uuid]<br>[–persistent] [–transient]<br>[–with-managed-save] [–without-managed-save]<br>[–autostart] [–no-autostart]<br>[–with-snapshot] [–without-snapshot]<br>[–with-checkpoint] [–without-checkpoint]<br>[–state-running] [–state-paused]<br>[–state-shutoff] [–state-other]  </p><p>打印有关现有域的信息。如果未指定选项，则打印有关运行域的信息。  </p><p><strong>示例 1：</strong></p><p>列表的示例格式如下：  </p><p><code>virsh</code> list  </p><h2 id="Id-名称-状态"><a href="#Id-名称-状态" class="headerlink" title="Id   名称       状态  "></a>Id   名称       状态  </h2><p>0    Domain-0   running<br>2    fedora     paused  </p><p>名称是域的名称。ID 是域的数字 ID。状态是运行状态（见下文）。  </p><p><strong>状态</strong>  </p><p>状态字段列出每个域当前的状态。域可以处于以下可能的状态之一：  </p><ul><li><p>running<br>域当前正在 CPU 上运行。  </p></li><li><p>idle<br>域处于空闲状态，未运行或不可运行。这可能是由于域正在等待 I&#x2F;O（传统等待状态）或因为没有其他事情可做而进入睡眠状态。  </p></li><li><p>paused<br>域已暂停，通常是由于管理员运行 virsh suspend。在暂停状态下，域仍会消耗分配的资源（如内存），但没有资格由虚拟机管理程序调度。  </p></li><li><p>in shutdown<br>域正在关闭过程中，即客户操作系统已收到通知并应正在优雅地停止其操作。  </p></li><li><p>shut off<br>域未运行。通常这表示域已完全关闭或尚未启动。  </p></li><li><p>crashed<br>域已崩溃，这始终是暴力结束。通常只有在域配置为崩溃时不重启时才会出现此状态。  </p></li><li><p>pmsuspended<br>域已由客户电源管理暂停，例如进入 s3 状态。</p></li></ul><p>通常仅列出活动域。要列出非活动域，请指定 <em>–inactive</em> 或 <em>–all</em> 以同时列出活动和非活动域。  </p><p><strong>过滤</strong>  </p><p>要进一步过滤域列表，可以指定 list 命令支持的一个或多个过滤标志。这些标志按功能分组。从组中指定一个或多个标志会启用过滤组。注意，某些标志组合可能不会产生任何结果。支持的过滤标志和组：  </p><p><strong>持久性</strong><br>标志 <em>–persistent</em> 用于在返回的列表中包括持久客户机。要包括临时客户机，请指定 <em>–transient</em>。  </p><p><strong>托管保存映像的存在</strong><br>要列出具有托管保存映像的域，请指定标志 <em>–with-managed-save</em>。对于没有托管保存映像的域，请指定 <em>–without-managed-save</em>。  </p><p><strong>域状态</strong><br>以下过滤标志按状态选择域：*–state-running* 用于运行域，*–state-paused* 用于暂停域，*–state-shutoff* 用于关闭域，*–state-other* 用于所有其他状态作为后备。  </p><p><strong>自动启动域</strong><br>要列出自动启动域，请使用标志 <em>–autostart</em>。要列出禁用此功能的域，请使用 <em>–no-autostart</em>。  </p><p><strong>快照存在</strong><br>可以使用标志 <em>–with-snapshot</em> 列出具有快照映像的域，使用 <em>–without-snapshot</em> 列出没有快照的域。  </p><p><strong>检查点存在</strong><br>可以使用标志 <em>–with-checkpoint</em> 列出具有检查点的域，使用 <em>–without-checkpoint</em> 列出没有检查点的域。  </p><p>在与旧服务器通信时，此命令被迫使用一系列具有固有竞争的 API 调用，如果在收集列表时域状态在调用之间更改，则可能不会列出域或域可能多次出现。新服务器没有此问题。  </p><p>如果指定 <em>–managed-save</em>，则具有托管保存状态（仅在域处于关闭状态时可能，因此需要指定 <em>–inactive</em> 或 <em>–all</em> 才能实际列出它们）的域将在列表中显示为已保存。此标志仅可与默认 <em>–table</em> 输出一起使用。注意，此标志不会过滤域列表。  </p><p>如果指定 <em>–name</em>，则打印域名而不是表格格式，每行一个。如果指定 <em>–uuid</em>，则打印域的 UUID 而不是名称。如果指定 <em>–id</em>，则打印域的 ID 而不是名称。但是，可以组合 <em>–name</em>、*–uuid* 和 <em>–id</em> 以仅选择要打印的所需字段。标志 <em>–table</em> 指定应使用传统的表格格式输出，但它与 <em>–name</em> 和 <em>–id</em> 互斥。这是默认值，如果未指定 <em>–name</em>、*–uuid* 或 <em>–id</em>，则将使用它。如果未指定 <em>–name</em> 或 <em>–uuid</em>，但指定了 <em>–id</em>，则仅列出活动域，即使使用 <em>–all</em> 参数，否则输出将仅包含一堆仅包含 <em>-1</em> 的行。如果 <em>–table</em> 与 <em>–uuid</em> 组合，则域 UUID 将作为额外列打印。  </p><p>如果指定 <em>–title</em>，则会在额外列中打印域的简短描述（标题）。此标志仅可与默认 <em>–table</em> 输出一起使用。  </p><p><strong>示例 2：</strong></p><p>$ virsh list –title  </p><h2 id="Id-名称-状态-标题"><a href="#Id-名称-状态-标题" class="headerlink" title="Id   名称       状态    标题  "></a>Id   名称       状态    标题  </h2><p>0    Domain-0   running Mailserver 1<br>2    fedora     paused  </p><p><strong>freecell</strong></p><p><strong>语法：</strong></p><p>freecell [{ [–cellno] 单元号 | –all }]  </p><p>打印机器或 NUMA 单元中的可用内存量。freecell 命令可以根据指定的选项提供三种不同的机器可用内存显示之一。不带选项时，显示机器上的总空闲内存。使用 –all 选项时，显示每个单元的空闲内存和机器上的总空闲内存。最后，使用数字参数或 –cellno 加单元号时，将仅显示指定单元的空闲内存。  </p><p><strong>freepages</strong></p><p><strong>语法：</strong></p><p>freepages [{ [–cellno] 单元号 [–pagesize] 页大小 | –all }]  </p><p>打印 NUMA 单元中的可用页数。<em>单元号</em> 指您感兴趣的 NUMA 单元。<em>页大小</em> 是一个带单位的整数（参见上面的 NOTES）。或者，如果使用 <em>–all</em>，则打印每个可能的 NUMA 单元和页大小组合的信息。  </p><p><strong>allocpages</strong></p><p><strong>语法：</strong></p><p>allocpages [–pagesize] 页大小 [–pagecount] 页数 [[–cellno] 单元号] [–add] [–all]  </p><p>更改主机上 <em>页大小</em> 的页池大小。如果指定 <em>–add</em>，则将 <em>页数</em> 页添加到池中。但是，如果未指定 <em>–add</em>，则 <em>页数</em> 将作为池的新绝对大小（这可用于释放一些页并缩小池）。<em>单元号</em> 修饰符可用于将修改范围缩小到单个主机 NUMA 单元。在范围的另一端是 <em>–all</em>，它将在所有 NUMA 单元上执行修改。  </p><p><strong>cpu-baseline</strong></p><p><strong>语法：</strong></p><p>cpu-baseline 文件 [–features] [–migratable]  </p><p>计算基线 CPU，该 CPU 将由 &lt;文件&gt; 中给出的所有主机 CPU 支持。（参见 hypervisor-cpu-baseline 命令以获取可由特定虚拟机管理程序提供的 CPU。）主机 CPU 列表是通过从 &lt;文件&gt; 中提取所有 &lt;cpu&gt; 元素构建的。因此，&lt;文件&gt; 可以包含由换行符分隔的一组 &lt;cpu&gt; 元素，甚至可以包含 capabilities 命令打印的一组完整的 &lt;capabilities&gt; 元素。如果指定 <em>–features</em>，则生成的 XML 描述将显式包括构成 CPU 的所有功能，没有此选项时，属于 CPU 模型的功能将不会在 XML 描述中列出。如果指定 <em>–migratable</em>，则阻止迁移的功能将不会包含在生成的 CPU 中。  </p><p><strong>cpu-compare</strong></p><p><strong>语法：</strong></p><p>cpu-compare 文件 [–error] [–validate]  </p><p>将 XML &lt;文件&gt; 中的 CPU 定义与主机 CPU 进行比较。（参见 hypervisor-cpu-compare 命令以将 CPU 定义与特定虚拟机管理程序在主机上能够提供的 CPU 进行比较。）XML &lt;文件&gt; 可以包含主机或客户机 CPU 定义。主机 CPU 定义是 capabilities 命令打印的 &lt;cpu&gt; 元素及其内容。客户机 CPU 定义是域 XML 定义中的 &lt;cpu&gt; 元素及其内容，或从域功能 XML（由 domcapabilities 命令打印）中找到的主机 CPU 模型创建的 CPU 定义。除了 &lt;cpu&gt; 元素本身外，此命令还接受包含 CPU 定义的完整域 XML、capabilities XML 或域功能 XML。有关客户机 CPU 定义的更多信息，请参阅：<br><a href="https://libvirt.org/formatdomain.html#elementsCPU">https://libvirt.org/formatdomain.html#elementsCPU</a>  </p><p>如果指定 <em>–error</em>，则当给定 CPU 与主机 CPU 不兼容时，命令将返回错误，并打印提供有关不兼容性更多详细信息的消息。如果指定 <em>–validate</em>，则根据内部 RNG 模式验证 XML 文档的格式。  </p><p><strong>cpu-models</strong></p><p><strong>语法：</strong></p><p>cpu-models 架构  </p><p>打印 libvirt 为指定架构已知的 CPU 模型列表。特定虚拟机管理程序是否能够创建使用任何打印的 CPU 模型的域是一个单独的问题，可以通过查看 domcapabilities 命令返回的域功能 XML 来回答。此外，对于某些架构，libvirt 不知道任何 CPU 模型，可用的 CPU 模型仅受虚拟机管理程序的限制。对于这些架构，此命令将打印所有 CPU 模型都被接受，实际支持的 CPU 模型列表可以在域功能 XML 中检查。  </p><p><strong>hypervisor-cpu-compare</strong></p><p><strong>语法：</strong></p><p>hypervisor-cpu-compare 文件 [virttype] [emulator] [arch] [machine] [–error] [–validate]  </p><p>将 XML &lt;文件&gt; 中的 CPU 定义与虚拟机管理程序在主机上能够提供的 CPU 进行比较。（这与 cpu-compare 不同，后者在不考虑任何特定虚拟机管理程序及其能力的情况下将 CPU 定义与主机 CPU 进行比较。）  </p><p>XML <em>文件</em> 应包含客户机 CPU 定义：域 XML 定义中的 &lt;cpu&gt; 元素及其内容，或从域功能 XML（由 domcapabilities 命令打印）中的 &lt;mode name&#x3D;”host-model”&gt; 元素创建的主机 CPU 模型创建的 CPU 定义。域功能 XML 中的 &lt;mode name&#x3D;”host-model”&gt; 元素本身或其 &lt;cpu&gt; 父元素不被接受。必须将元素转换为实际的 CPU 定义。有关客户机 CPU 定义的更多信息，请参阅：<br><a href="https://libvirt.org/formatdomain.html#elementsCPU">https://libvirt.org/formatdomain.html#elementsCPU</a>  </p><p>或者，此命令在提供完整域或域功能 XML 时将自动提取 CPU 定义。  </p><p>出于历史原因，XML <em>文件</em> 也可以包含主机 CPU 定义，但强烈不建议这种用法，因为它很可能会提供不正确的结果。  </p><p><em>virttype</em> 选项指定虚拟化类型（可在域 XML 中 &lt;domain&gt; 顶级元素的 ‘type’ 属性中使用）。<em>emulator</em> 指定模拟器的路径，<em>arch</em> 指定 CPU 架构，<em>machine</em> 指定机器类型。如果指定 <em>–error</em>，则当给定 CPU 与主机 CPU 不兼容时，命令将返回错误，并打印提供有关不兼容性更多详细信息的消息。如果指定 <em>–validate</em>，则根据内部 RNG 模式验证 XML 文档的格式。  </p><p><strong>hypervisor-cpu-baseline</strong></p><p><strong>语法：</strong></p><p>hypervisor-cpu-baseline [文件] [virttype] [emulator] [arch] [machine]<br>[–features] [–migratable] [模型]  </p><p>计算基线 CPU，该 CPU 将与 XML <em>文件</em> 中定义的所有 CPU 以及虚拟机管理程序在主机上能够提供的 CPU 兼容。（这与 cpu-baseline 不同，后者在计算基线 CPU 时不考虑任何虚拟机管理程序的能力。）  </p><p>作为 <em>文件</em> 的替代方案，如果 XML 仅包含没有附加功能的 CPU 模型，则可以将 CPU 模型名称本身作为 <em>模型</em> 传递。必须使用 <em>文件</em> 和 <em>模型</em> 中的一个。  </p><p>XML <em>文件</em> 应包含从域功能 XML（在每个主机上由 domcapabilities 命令打印）中的 &lt;mode name&#x3D;”host-model”&gt; 元素创建的主机 CPU 模型创建的客户机 CPU 定义。域功能 XML 中的 &lt;mode name&#x3D;”host-model”&gt; 元素本身或其 &lt;cpu&gt; 父元素不被接受。必须将元素转换为实际的 CPU 定义。  </p><p>或者，此命令在提供域功能 XML 时将自动提取 CPU 定义。  </p><p>出于历史原因，XML <em>文件</em> 也可以包含主机 CPU 定义，但强烈不建议这种用法，因为它很可能会提供不正确的结果。  </p><p>当 <em>文件</em> 仅包含单个 CPU 定义时，命令将打印相同的 CPU，并附加虚拟机管理程序能力施加的限制。具体来说，在没有其他选项的情况下运行 virsh hypervisor-cpu-baseline 命令对 virsh domcapabilities 的结果进行操作，将域功能 XML 中的主机 CPU 模型转换为可直接在域 XML 中使用的形式。运行带有 <em>模型</em>（或仅包含模型且没有功能元素的单个 CPU 定义的 <em>文件</em>）的命令，该模型在 virsh domcapabilities 中被标记为不可用，将提供阻止此 CPU 模型可用的功能列表。  </p><p><em>virttype</em> 选项指定虚拟化类型（可在域 XML 中 &lt;domain&gt; 顶级元素的 ‘type’ 属性中使用）。<em>emulator</em> 指定模拟器的路径，<em>arch</em> 指定 CPU 架构，<em>machine</em> 指定机器类型。如果指定 <em>–features</em>，则生成的 XML 描述将显式包括构成 CPU 的所有功能，没有此选项时，属于 CPU 模型的功能将不会在 XML 描述中列出。如果指定 <em>–migratable</em>，则阻止迁移的功能将不会包含在生成的 CPU 中。  </p><p><strong>hypervisor-cpu-models</strong></p><p><strong>语法：</strong></p><p>hypervisor-cpu-models [–virttype virttype] [–emulator emulator]<br>[–arch arch] [–machine machine] [–all]  </p><p>打印虚拟机管理程序为指定架构已知的 CPU 模型列表。不能保证列出的 CPU 将在主机上运行。要确定 CPU 模型与主机的兼容性，请参阅 virsh hypervisor-cpu-baseline 和 virsh hypervisor-cpu-compare。  </p><p><em>virttype</em> 选项指定虚拟化类型（可在域 XML 中 &lt;domain&gt; 顶级元素的 ‘type’ 属性中使用）。<em>emulator</em> 指定模拟器的路径，<em>arch</em> 指定 CPU 架构，<em>machine</em> 指定机器类型。  </p><p>默认情况下，仅报告虚拟机管理程序在主机上声称“可用”的模型。选项 <em>–all</em> 将报告虚拟机管理程序已知的每个 CPU 模型，包括不受支持的模型（例如新一代模型）。</p><h1 id="5-域命令"><a href="#5-域命令" class="headerlink" title="5 域命令"></a>5 <strong>域命令</strong></h1><p>以下命令直接操作域，如前所述，大多数命令将域作为第一个参数。<em>域</em>可以指定为短整数、名称或完整的UUID。</p><p><strong>自动启动</strong></p><p><strong>语法：</strong></p><p>autostart [–disable] 域</p><p>配置域在启动时自动启动。</p><p>选项 <em>–disable</em> 禁用自动启动。</p><p><strong>块设备IO调优</strong></p><p><strong>语法：</strong></p><p>blkdeviotune 域 设备 [[–config] [–live] | [–current]]<br>[[total-bytes-sec] | [read-bytes-sec] [write-bytes-sec]]<br>[[total-iops-sec] | [read-iops-sec] [write-iops-sec]]<br>[[total-bytes-sec-max] | [read-bytes-sec-max] [write-bytes-sec-max]]<br>[[total-iops-sec-max] | [read-iops-sec-max] [write-iops-sec-max]]<br>[[total-bytes-sec-max-length] | [read-bytes-sec-max-length] [write-bytes-sec-max-length]]<br>[[total-iops-sec-max-length] | [read-iops-sec-max-length] [write-iops-sec-max-length]]<br>[size-iops-sec] [group-name]</p><p>设置或查询域块设备的IO参数。<em>设备</em>指定域中附加的磁盘设备的唯一目标名称（&lt;target dev&#x3D;’name’&#x2F;&gt;）或源文件（&lt;source file&#x3D;’name’&#x2F;&gt;）（参见domblklist列出这些名称）。</p><p>如果未指定限制，则查询当前IO限制设置。否则，使用以下标志更改限制：*–total-bytes-sec* 指定总吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–read-bytes-sec* 指定读取吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–write-bytes-sec* 指定写入吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–total-iops-sec* 指定每秒总IO操作限制。*–read-iops-sec* 指定每秒读取IO操作限制。*–write-iops-sec* 指定每秒写入IO操作限制。*–total-bytes-sec-max* 指定最大总吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–read-bytes-sec-max* 指定最大读取吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–write-bytes-sec-max* 指定最大写入吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–total-iops-sec-max* 指定每秒最大总IO操作限制。*–read-iops-sec-max* 指定每秒最大读取IO操作限制。*–write-iops-sec-max* 指定每秒最大写入IO操作限制。*–total-bytes-sec-max-length* 指定允许最大总吞吐量限制的持续时间（秒）。*–read-bytes-sec-max-length* 指定允许最大读取吞吐量限制的持续时间（秒）。*–write-bytes-sec-max-length* 指定允许最大写入吞吐量限制的持续时间（秒）。*–total-iops-sec-max-length* 指定允许最大总IO操作限制的持续时间（秒）。*–read-iops-sec-max-length* 指定允许最大读取IO操作限制的持续时间（秒）。*–write-iops-sec-max-length* 指定允许最大写入IO操作限制的持续时间（秒）。*–size-iops-sec* 指定每秒大小IO操作限制。*–group-name* 指定在多个驱动器之间共享IO配额的组名。对于QEMU域，如果未提供名称，则默认为每个<em>设备</em>有一个单独的组。</p><p>旧版本的virsh仅接受下划线而非连字符的选项，例如*–total_bytes_sec*。</p><p>字节和IOPS值是独立的，但仅设置一个值（例如–read-bytes-sec）会将该类别中的其他两个值重置为无限制。显式的0也会清除任何限制。对于给定的总值的非零值不能与读取或写入的非零值混合使用。</p><p>长度值的处理方式由管理程序决定。对于QEMU管理程序，如果设置了IO限制值或最大值，则默认显示1秒的值。提供0将值重置回默认值。</p><p>如果指定*–live<em>，则影响正在运行的客户机。如果指定</em>–config<em>，则影响持久客户机的下一次启动。如果指定</em>–current<em>，则根据客户机的当前状态等效于</em>–live<em>或</em>–config<em>。设置磁盘IO参数时，可以同时指定</em>–live<em>和</em>–config<em>标志，但</em>–current<em>是互斥的。查询时只能指定</em>–live<em>、</em>–config<em>或</em>–current*中的一个。如果未指定标志，行为因管理程序而异。</p><p><strong>域节流组设置</strong></p><p><strong>语法：</strong></p><p>domthrottlegroupset 域 组名 [[–config] [–live] | [–current]]<br>[[total-bytes-sec] | [read-bytes-sec] [write-bytes-sec]]<br>[[total-iops-sec] | [read-iops-sec] [write-iops-sec]]<br>[[total-bytes-sec-max] | [read-bytes-sec-max] [write-bytes-sec-max]]<br>[[total-iops-sec-max] | [read-iops-sec-max] [write-iops-sec-max]]<br>[[total-bytes-sec-max-length] | [read-bytes-sec-max-length] [write-bytes-sec-max-length]]<br>[[total-iops-sec-max-length] | [read-iops-sec-max-length] [write-iops-sec-max-length]]<br>[size-iops-sec]</p><p>添加或更新特定域的节流组。<em>组名</em>指定唯一的节流组名称，定义限制，并将被驱动器引用。</p><p>如果未指定限制，则默认为全零，这将失败。否则，使用以下标志设置限制：*–total-bytes-sec* 指定总吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–read-bytes-sec* 指定读取吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–write-bytes-sec* 指定写入吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–total-iops-sec* 指定每秒总IO操作限制。*–read-iops-sec* 指定每秒读取IO操作限制。*–write-iops-sec* 指定每秒写入IO操作限制。*–total-bytes-sec-max* 指定最大总吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–read-bytes-sec-max* 指定最大读取吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–write-bytes-sec-max* 指定最大写入吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–total-iops-sec-max* 指定每秒最大总IO操作限制。*–read-iops-sec-max* 指定每秒最大读取IO操作限制。*–write-iops-sec-max* 指定每秒最大写入IO操作限制。*–total-bytes-sec-max-length* 指定允许最大总吞吐量限制的持续时间（秒）。*–read-bytes-sec-max-length* 指定允许最大读取吞吐量限制的持续时间（秒）。*–write-bytes-sec-max-length* 指定允许最大写入吞吐量限制的持续时间（秒）。*–total-iops-sec-max-length* 指定允许最大总IO操作限制的持续时间（秒）。*–read-iops-sec-max-length* 指定允许最大读取IO操作限制的持续时间（秒）。*–write-iops-sec-max-length* 指定允许最大写入IO操作限制的持续时间（秒）。*–size-iops-sec* 指定每秒大小IO操作限制。</p><p>字节和IOPS值是独立的，但仅设置一个值（例如–read-bytes-sec）会将该类别中的其他两个值重置为无限制。显式的0也会清除任何限制。对于给定的总值的非零值不能与读取或写入的非零值混合使用。</p><p>长度值的处理方式由管理程序决定。对于QEMU管理程序，如果设置了IO限制值或最大值，则默认显示1秒的值。提供0将值重置回默认值。</p><p>如果指定*–live<em>，则影响正在运行的客户机。如果指定</em>–config<em>，则影响持久客户机的下一次启动。如果指定</em>–current<em>，则根据客户机的当前状态等效于</em>–live<em>或</em>–config<em>。设置磁盘IO参数时，可以同时指定</em>–live<em>和</em>–config<em>标志，但</em>–current*是互斥的。如果未指定标志，行为因管理程序而异。</p><p><strong>域节流组删除</strong></p><p><strong>语法：</strong></p><p>domthrottlegroupdel 域 组名 [[–config] [–live] | [–current]]</p><p>使用指定的<em>组名</em>从域中删除节流组。如果节流组当前被磁盘资源引用，则尝试删除节流组将失败。如果<em>组名</em>不存在，将发生错误。</p><p>如果指定*–live<em>，则影响正在运行的客户机。如果客户机未运行，则返回错误。如果指定</em>–config<em>，则影响持久客户机的下一次启动。如果指定</em>–current<em>，则根据客户机的当前状态等效于</em>–live<em>或</em>–config*。</p><p><strong>域节流组信息</strong></p><p><strong>语法：</strong></p><p>domthrottlegroupinfo 域 组名 [[–config] [–live] | [–current]]</p><p>显示域节流组信息，包括IO限制设置。</p><p>如果指定*–live<em>，则从正在运行的客户机获取节流组数据。如果客户机未运行，则返回错误。如果指定</em>–config<em>，则从持久客户机的下一次启动获取节流组数据。如果指定</em>–current<em>或未指定</em>–live<em>和</em>–config<em>，则根据客户机的当前状态获取节流组数据，可以是活动或离线状态。如果同时指定</em>–live<em>和</em>–config<em>，则</em>–config*选项优先获取当前描述。</p><p><strong>域节流组列表</strong></p><p><strong>语法：</strong></p><p>domthrottlegrouplist 域 [–inactive]</p><p>打印显示与域关联的所有节流组名称的表格。如果指定*–inactive*，则查询将在下次启动时使用的节流组数据，而不是当前正在使用的域。</p><p><strong>块IO调优</strong></p><p><strong>语法：</strong></p><p>blkiotune 域 [–weight 权重] [–device-weights 设备权重]<br>[–device-read-iops-sec 设备读取IOPS]<br>[–device-write-iops-sec 设备写入IOPS]<br>[–device-read-bytes-sec 设备读取字节]<br>[–device-write-bytes-sec 设备写入字节]<br>[[–config] [–live] | [–current]]</p><p>显示或设置块IO参数。QEMU&#x2F;KVM支持*–weight<em>。</em>–weight*范围为[100, 1000]。在内核2.6.39之后，该值可以在[10, 1000]范围内。</p><p>设备权重是一个字符串，列出一个或多个设备&#x2F;权重对，格式为&#x2F;路径&#x2F;到&#x2F;设备,权重,&#x2F;路径&#x2F;到&#x2F;设备,权重。每个权重在[100, 1000]范围内，内核2.6.39之后为[10, 1000]，或值为0以从每设备列表中删除该设备。仅修改字符串中列出的设备；其他设备的现有每设备权重保持不变。</p><p>设备读取IOPS是一个字符串，列出一个或多个设备&#x2F;读取IOPS对，格式为&#x2F;路径&#x2F;到&#x2F;设备,读取IOPS,&#x2F;路径&#x2F;到&#x2F;设备,读取IOPS。每个读取IOPS是一个无符号整数，值为0以从每设备列表中删除该设备。仅修改字符串中列出的设备；其他设备的现有每设备读取IOPS保持不变。</p><p>设备写入IOPS是一个字符串，列出一个或多个设备&#x2F;写入IOPS对，格式为&#x2F;路径&#x2F;到&#x2F;设备,写入IOPS,&#x2F;路径&#x2F;到&#x2F;设备,写入IOPS。每个写入IOPS是一个无符号整数，值为0以从每设备列表中删除该设备。仅修改字符串中列出的设备；其他设备的现有每设备写入IOPS保持不变。</p><p>设备读取字节是一个字符串，列出一个或多个设备&#x2F;读取字节对，格式为&#x2F;路径&#x2F;到&#x2F;设备,读取字节,&#x2F;路径&#x2F;到&#x2F;设备,读取字节。每个读取字节是一个无符号长整型，值为0以从每设备列表中删除该设备。仅修改字符串中列出的设备；其他设备的现有每设备读取字节保持不变。</p><p>设备写入字节是一个字符串，列出一个或多个设备&#x2F;写入字节对，格式为&#x2F;路径&#x2F;到&#x2F;设备,写入字节,&#x2F;路径&#x2F;到&#x2F;设备,写入字节。每个写入字节是一个无符号长整型，值为0以从每设备列表中删除该设备。仅修改字符串中列出的设备；其他设备的现有每设备写入字节保持不变。</p><p>如果指定*–live<em>，则影响正在运行的客户机。如果指定</em>–config<em>，则影响持久客户机的下一次启动。如果指定</em>–current<em>，则根据客户机的当前状态等效于</em>–live<em>或</em>–config<em>。可以同时指定</em>–live<em>和</em>–config<em>标志，但</em>–current*是互斥的。如果未指定标志，行为因管理程序而异。</p><p><strong>块提交</strong></p><p><strong>语法：</strong></p><p>blockcommit 域 路径 [带宽] [–bytes] [基础]<br>[–shallow] [顶部] [–delete] [–keep-relative]<br>[–wait [–async] [–verbose]] [–timeout 秒]<br>[–active] [{–pivot | –keep-overlay}]</p><p>通过将链顶部的更改（快照或增量文件）提交到基础映像中，减少基础映像链的长度。默认情况下，此命令尝试展平整个链。如果<em>基础</em>和&#x2F;或<em>顶部</em>指定为链中的文件，则操作仅限于提交该部分链；*–shallow<em>可以代替</em>基础<em>指定要提交的顶部映像的直接基础文件。正在提交的文件将变为无效，可能在操作开始时即如此；使用</em>–delete<em>标志将在成功完成提交操作后尝试删除这些无效文件。使用</em>–keep-relative*标志时，基础文件路径将保持相对路径。</p><p>当省略<em>顶部</em>或将其指定为活动映像时，还可以指定*–active<em>以触发两阶段活动提交。在第一阶段，</em>顶部<em>被复制到</em>基础<em>中，作业只能取消，顶部仍包含尚未在基础中的数据。在第二阶段，</em>顶部<em>和</em>基础<em>保持相同，直到调用带有</em>–abort<em>标志的blockjob（保持顶部作为跟踪从该时间点更改的活动映像）或</em>–pivot*标志（使基础成为新的活动映像并使顶部无效）。</p><p>默认情况下，此命令尽快返回，整个磁盘的数据在后台提交；可以使用blockjob检查操作进度。但是，如果指定*–wait<em>，则此命令将阻塞，直到操作完成（或对于</em>–active<em>，进入第二阶段），或由于可选的</em>timeout<em>秒超时或发送SIGINT（通常使用Ctrl-C）而取消操作。使用</em>–verbose<em>与</em>–wait<em>将产生定期状态更新。如果触发作业取消，</em>–async<em>将尽快将控制权返回给用户，否则命令可能会继续阻塞一段时间，直到作业完成清理。使用</em>–pivot<em>是结合</em>–active* <em>–wait</em>与自动blockjob <em>–pivot</em>的简写；使用*–keep-overlay<em>是结合</em>–active* <em>–wait</em>与自动blockjob <em>–abort</em>的简写。</p><p><em>路径</em>指定磁盘的完全限定路径；它对应于域中附加的磁盘设备的唯一目标名称（&lt;target dev&#x3D;’name’&#x2F;&gt;）或源文件（&lt;source file&#x3D;’name’&#x2F;&gt;）（参见domblklist列出这些名称）。<em>带宽</em>指定复制带宽限制（MiB&#x2F;s），但对于QEMU，仅在线域可能为非零值。有关<em>带宽</em>参数的更多信息，请参见blockjob命令的相应部分。</p><p><strong>块复制</strong></p><p><strong>语法：</strong></p><p>blockcopy 域 路径 { 目标 [格式] [–blockdev] | –xml 文件 }<br>[–shallow] [–reuse-external] [带宽]<br>[–wait [–async] [–verbose]] [{–pivot | –finish}]<br>[–timeout 秒] [粒度] [缓冲区大小] [–bytes]<br>[–transient-job] [–synchronous-writes] [–print-xml]</p><p>将磁盘基础映像链复制到目标。必须存在<em>目标</em>作为目标文件名，或*–xml<em>包含描述目标的顶级&lt;disk&gt;元素的XML文件名。此外，如果给出</em>目标<em>，则应指定</em>格式<em>以声明目标的格式（如果省略</em>格式<em>，则libvirt将重用源的格式，或使用</em>–reuse-external<em>强制探测目标格式，这可能是潜在的安全漏洞）。该命令支持</em>–raw<em>作为</em>–format&#x3D;raw<em>的布尔标志同义词。使用</em>目标<em>时，目标被视为常规文件，除非使用</em>–blockdev<em>表示它是块设备。默认情况下，此命令展平整个链；但如果指定</em>–shallow*，则副本共享基础链。</p><p>如果指定*–reuse-external<em>，则目标必须存在并具有足够的空间来保存副本。如果</em>–shallow<em>与</em>–reuse-external*一起使用，则预创建的映像必须具有与原始映像的基础文件相同的客户可见内容。这可以用于修改目标上的基础文件名。</p><p>默认情况下，复制作业在后台运行，并分为两个阶段。最初，作业必须从源复制所有数据，在此阶段，作业只能取消以恢复到源磁盘，不保证目标的状态。在此阶段完成后，源和目标保持镜像，直到调用带有*–abort<em>和</em>–pivot<em>标志的blockjob切换到副本，或不带</em>–pivot<em>的调用将目标保留为该时间点的忠实副本。但是，如果指定</em>–wait<em>，则此命令将阻塞，直到镜像阶段开始，或如果可选的</em>timeout<em>秒超时或发送SIGINT（通常使用Ctrl-C）则取消操作。使用</em>–verbose<em>与</em>–wait<em>将产生定期状态更新。使用</em>–pivot<em>（类似于blockjob <em>–pivot</em>）或</em>–finish<em>（类似于blockjob <em>–abort</em>）隐含</em>–wait<em>，并将干净地结束作业，而不是保持在镜像阶段。如果超时或</em>–finish<em>触发作业取消，</em>–async*将尽快将控制权返回给用户，否则命令可能会继续阻塞一段时间，直到作业实际取消。</p><p><em>路径</em>指定磁盘的完全限定路径。<em>带宽</em>指定复制带宽限制（MiB&#x2F;s）。指定负值被视为无符号长整型值，可能基本上无限制，但更可能溢出；使用0更安全。有关<em>带宽</em>参数的更多信息，请参见blockjob命令的相应部分。指定<em>粒度</em>允许微调检测到脏区域时要复制的粒度；较大的值触发较少的IO开销，但总体上可能复制更多的数据（默认值通常正确）；管理程序可能限制为2的幂或落在特定范围内。指定<em>缓冲区大小</em>将控制在复制期间可以同时传输的数据量；较大的值使用更多内存，但可能允许更快完成（默认值通常正确）。</p><p><em>–transient-job</em>允许指定如果VM在作业完成前崩溃或关闭，用户不需要恢复作业。如果管理程序应用了复制作业对临时域的限制，此标志将删除该限制。</p><p>如果指定*–synchronous-writes*，则块作业将等待客户写入传播到原始映像和复制目标，以确保如果目标存储较慢，作业会收敛。这可能会影响块作业运行时的写入性能。</p><p>如果指定*–print-xml*，则打印用于启动块复制作业的XML，而不是启动作业。</p><p><strong>块作业</strong></p><p><strong>语法：</strong></p><p>blockjob 域 路径 { [–abort] [–async] [–pivot] |<br>[–info] [–raw] [–bytes] | [带宽] }</p><p>管理活动块操作。有三种互斥模式：*–info<em>、</em>带宽<em>和</em>–abort<em>。</em>–async<em>和</em>–pivot<em>隐含中止模式；</em>–raw<em>隐含信息模式；如果未给出模式，则假定为</em>–info*模式。</p><p><em>路径</em>指定磁盘的完全限定路径；它对应于域中附加的磁盘设备的唯一目标名称（&lt;target dev&#x3D;’name’&#x2F;&gt;）或源文件（&lt;source file&#x3D;’name’&#x2F;&gt;）（参见domblklist列出这些名称）。</p><p>在*–abort<em>模式下，将中止指定磁盘上的活动作业。如果还指定</em>–async<em>，则此命令将立即返回，而不是等待取消完成。如果指定</em>–pivot*，则请求将活动复制或活动提交作业切换到新映像。</p><p>在*–info<em>模式下，将打印指定磁盘上的活动作业信息。默认情况下，输出为单个人类可读的摘要行；此格式可能在将来的版本中更改。添加</em>–raw<em>以稳定格式列出结构的每个字段。如果设置</em>–bytes*标志，则如果服务器无法提供字节&#x2F;秒分辨率，则命令将出错；省略标志时，原始输出以MiB&#x2F;s列出，人类可读输出自动选择服务器支持的最佳分辨率。</p><p><em>带宽</em>可用于设置活动作业的带宽限制（MiB&#x2F;s）。如果指定*–bytes<em>，则带宽值解释为字节&#x2F;秒。指定负值被视为无符号长整型值或基本上无限制。管理程序可以选择是否拒绝该值或将其转换为允许的最大值。可选地，可以使用缩放正数作为带宽（参见上面的NOTES）。使用</em>–bytes<em>与缩放值允许选择更细的粒度。不带</em>–bytes<em>的缩放值将向下舍入到MiB&#x2F;s。请注意，</em>–bytes*可能不受管理程序支持。</p><p>请注意，对应于拉模式备份的块作业报告的进度不是备份的进度，而是备份所需的临时空间的使用情况。</p><p><strong>块拉取</strong></p><p><strong>语法：</strong></p><p>blockpull 域 路径 [带宽] [–bytes] [基础]<br>[–wait [–verbose] [–timeout 秒] [–async]]<br>[–keep-relative]</p><p>从基础映像链中填充磁盘。默认情况下，此命令展平整个链；但如果指定<em>基础</em>，包含链中基础文件之一的名称，则该文件成为新的基础文件，仅拉取链的中间部分。一旦从基础映像链中拉取了所有请求的数据，磁盘就不再依赖于该部分基础链。</p><p>默认情况下，此命令尽快返回，整个磁盘的数据在后台拉取；可以使用blockjob检查操作进度。但是，如果指定*–wait<em>，则此命令将阻塞，直到操作完成，或如果可选的</em>timeout<em>秒超时或发送SIGINT（通常使用Ctrl-C）则取消操作。使用</em>–verbose<em>与</em>–wait<em>将产生定期状态更新。如果触发作业取消，</em>–async*将尽快将控制权返回给用户，否则命令可能会继续阻塞一段时间，直到作业完成清理。</p><p>使用*–keep-relative*标志将保持基础链名称的相对性。</p><p><em>路径</em>指定磁盘的完全限定路径；它对应于域中附加的磁盘设备的唯一目标名称（&lt;target dev&#x3D;’name’&#x2F;&gt;）或源文件（&lt;source file&#x3D;’name’&#x2F;&gt;）（参见domblklist列出这些名称）。<em>带宽</em>指定复制带宽限制（MiB&#x2F;s）。有关<em>带宽</em>参数的更多信息，请参见blockjob命令的相应部分。</p><p><strong>块调整大小</strong></p><p><strong>语法：</strong></p><p>blockresize 域 路径 ([大小] | [–capacity])</p><p>在域运行时调整块设备的大小。<em>路径</em>指定块设备的绝对路径；它对应于域中附加的磁盘设备的唯一目标名称（&lt;target dev&#x3D;’name’&#x2F;&gt;）或源文件（&lt;source file&#x3D;’name’&#x2F;&gt;）（参见domblklist列出这些名称）。</p><p>对于没有元数据的映像格式（原始格式）存储在固定大小的存储（例如块设备）中，可以使用*–capacity*标志将设备调整为基础设备的完整大小。</p><p><em>大小</em>是一个缩放整数（参见上面的NOTES），如果没有后缀，则默认为KiB（1024字节的块）。必须使用“B”后缀以获取字节（请注意，由于历史原因，这与vol-resize不同，后者默认不带后缀的字节）。</p><p><strong>控制台</strong></p><p><strong>语法：</strong></p><p>console 域 [设备名] [–safe] [–force] [–resume]</p><p>连接到客户机的虚拟串行控制台。可选的<em>设备名</em>参数引用为客户机配置的备用控制台、串行或并行设备的设备别名。如果省略，将打开主控制台。</p><p>如果指定*–safe<em>标志，则仅在驱动程序支持安全控制台处理时尝试连接。此标志指定服务器必须确保对控制台设备的独占访问。可选地，可以指定</em>–force*标志，请求断开任何现有会话，例如在连接断开的情况下。</p><p>如果指定*–resume*标志，则在连接到控制台后恢复客户机。</p><p><strong>CPU统计</strong></p><p><strong>语法：</strong></p><p>cpu-stats 域 [–total] [起始] [数量]</p><p>提供域的CPU统计信息。域应正在运行。默认显示所有CPU的统计信息和总计。使用*–total<em>仅显示总计统计信息，</em>起始<em>仅显示从</em>起始<em>开始的CPU的统计信息，</em>数量<em>仅显示</em>数量*个CPU的统计信息。</p><p><strong>创建</strong></p><p><strong>语法：</strong></p><p>create 文件 [–console] [–paused] [–autodestroy]<br>[–pass-fds N,M,…] [–validate] [–reset-nvram]</p><p>从XML &lt;文件&gt;创建域。可选地，可以传递*–validate*选项以根据内部RNG模式验证输入XML文件的格式（与使用virt-xml-validate(1)工具相同）。使用此命令创建的域将是临时的（一旦销毁即消失）或现有的持久客户机，将运行一次性使用的配置，保持持久XML不变（这在基于原始XML的各种配置的自动化测试中可能很方便）。请参见下面的示例以了解用法演示。</p><p>如果使用*–paused<em>选项且驱动程序支持，则域将被暂停；否则将运行。如果请求</em>–console<em>，则在创建后附加到控制台。如果请求</em>–autodestroy*，则当virsh关闭其与libvirt的连接或以其他方式退出时，客户机将自动销毁。</p><p>如果指定*–pass-fds*，则参数是逗号分隔的打开文件描述符列表，这些文件描述符应传递到客户机中。文件描述符将在客户机中重新编号，从3开始。这仅支持基于容器的虚拟化。</p><p>如果指定*–reset-nvram*，则任何现有的NVRAM文件将被删除并从其原始模板重新初始化。</p><p><strong>示例：</strong></p><ol><li>从现有域准备模板（如果从头开始编写，则直接跳到3a）</li></ol><p># virsh dumpxml &lt;域&gt; &gt; 域.xml</p><ol start="2"><li><p>使用您选择的编辑器编辑模板：</p><p> a. 必须更改！&lt;name&gt;和&lt;uuid&gt;（&lt;uuid&gt;也可以删除），或</p><p> b. 不要更改！&lt;name&gt;或&lt;uuid&gt;</p></li></ol><p># $EDITOR 域.xml</p><ol start="3"><li><p>从domain.xml创建域，取决于是否遵循2a或2b：</p><p> a. 域将是临时的</p><p> b. 现有的持久客户机将使用修改后的一次性配置运行</p></li></ol><p># virsh create domain.xml</p><p><strong>定义</strong></p><p><strong>语法：</strong></p><p>define 文件 [–validate]</p><p>从XML &lt;文件&gt;定义域。可选地，可以使用*–validate*（与使用virt-xml-validate(1)工具相同）根据内部RNG模式验证输入XML文件的格式。域定义已注册但未启动。如果域已在运行，则更改将在下次启动时生效。</p><p><strong>描述</strong></p><p><strong>语法：</strong></p><p>desc 域 [[–live] [–config] | [–current]] [–title] [–edit] [–new-desc 新描述或标题消息]</p><p>显示或修改域的描述和标题。这些值是允许存储任意文本数据的用户字段，以便轻松识别域。标题应简短，尽管未强制执行。（另请参见适用于基于XML的域元数据的元数据。）</p><p>标志*–live<em>或</em>–config<em>选择此命令是作用于域的实时定义还是持久定义。如果同时指定</em>–live<em>和</em>–config<em>，则</em>–config<em>选项优先获取当前描述，并在设置描述时同时更新实时配置和配置。</em>–current*是互斥的，如果未指定这些标志，则隐含。</p><p>标志*–edit*指定应打开包含当前描述或标题内容的编辑器，并在之后保存内容。</p><p>标志*–title*选择操作标题字段而不是描述。</p><p>如果既不指定*–edit<em>也不指定</em>–new-desc*，则显示注释或描述而不是修改。</p><p><strong>销毁</strong></p><p><strong>语法：</strong></p><p>destroy 域 [–graceful] [–remove-logs]</p><p>立即终止域<em>域</em>。这不会给域操作系统任何反应的机会，相当于物理机器上拔掉电源线。在大多数情况下，您会希望改用shutdown命令。但是，这不会删除客户机使用的任何存储卷，如果域是持久的，则可以稍后重新启动。</p><p>如果<em>域</em>是临时的，则一旦客户机停止运行，任何快照的元数据将丢失，但快照内容仍然存在，具有相同名称和UUID的新域可以使用snapshot-create恢复快照元数据。类似地，任何检查点的元数据将丢失，但可以使用checkpoint-create恢复。</p><p>如果指定*–graceful*，则在客户机在合理超时后未停止时，不采取极端措施（例如SIGKILL）；而是返回错误。</p><p>如果指定*–remove-logs<em>，则删除每个</em>域*的日志文件。并非所有部署配置都受支持。</p><p>对于QEMU，仅当使用virlogd处理QEMU进程输出时才支持该标志。否则忽略该标志。</p><p><strong>块错误</strong></p><p><strong>语法：</strong></p><p>domblkerror 域</p><p>显示块设备上的错误。当domstate命令说域由于I&#x2F;O错误而暂停时，此命令通常很有用。domblkerror命令列出所有处于错误状态的块设备以及每个设备上看到的错误。</p><p><strong>块信息</strong></p><p><strong>语法：</strong></p><p>domblkinfo 域 [块设备 –all] [–human]</p><p>获取域的块设备大小信息。<em>块设备</em>对应于域中附加的磁盘设备的唯一目标名称（&lt;target dev&#x3D;’name’&#x2F;&gt;）或源文件（&lt;source file&#x3D;’name’&#x2F;&gt;）（参见domblklist列出这些名称）。如果指定*–human<em>，则输出将具有人类可读的输出。如果指定</em>–all<em>，则输出将是一个表格，显示与</em>域<em>关联的所有块设备大小信息。</em>–all*选项优先于其他选项。</p><p><strong>块列表</strong></p><p><strong>语法：</strong></p><p>domblklist 域 [–inactive] [–details]</p><p>打印一个表格，显示与<em>域</em>关联的所有块设备的简要信息。如果指定*–inactive<em>，则查询将在下次启动时使用的块设备，而不是当前正在使用的域。如果指定</em>–details<em>，还将打印磁盘类型和设备值。其他需要块设备名称的上下文（例如</em>domblkinfo<em>或用于磁盘快照的</em>snapshot-create*）将接受此命令打印的目标或唯一源名称。</p><p><strong>块统计</strong></p><p><strong>语法：</strong></p><p>domblkstat 域 [块设备] [–human]</p><p>获取正在运行的域的块设备统计信息。<em>块设备</em>对应于域中附加的磁盘设备的唯一目标名称（&lt;target dev&#x3D;’name’&#x2F;&gt;）或源文件（&lt;source file&#x3D;’name’&#x2F;&gt;）（参见domblklist列出这些名称）。在LXC或QEMU域上，省略<em>块设备</em>将汇总整个域的块设备统计信息。</p><p>使用*–human*以获得更人类可读的输出。</p><p>这些字段的可用性取决于管理程序。不支持的字段将从输出中缺失。如果与较新版本的libvirtd通信，可能会出现其他字段。</p><p>字段说明（字段按以下顺序出现）：</p><ul><li><p>rd_req - 读取操作计数</p></li><li><p>rd_bytes - 读取字节计数</p></li><li><p>wr_req - 写入操作计数</p></li><li><p>wr_bytes - 写入字节计数</p></li><li><p>errs - 错误计数</p></li><li><p>flush_operations - 刷新操作计数</p></li><li><p>rd_total_times - 读取操作花费的总时间（纳秒）</p></li><li><p>wr_total_times - 写入操作花费的总时间（纳秒）</p></li><li><p>flush_total_times - 刷新操作花费的总时间（纳秒）</p></li><li><p>&lt;– 管理程序提供的其他字段 –&gt;</p></li></ul><p><strong>块阈值</strong></p><p><strong>语法：</strong></p><p>domblkthreshold 域 设备 阈值</p><p>设置传递块阈值事件的阈值值。<em>设备</em>指定磁盘设备目标或使用’target[1]’语法给定设备的支持链元素。<em>阈值</em>是偏移的缩放值。如果块设备应写入超过该偏移，则将传递事件。</p><p><strong>域控制</strong></p><p><strong>语法：</strong></p><p>domcontrol 域</p><p>返回用于控制域的VMM接口状态。对于除“ok”或“error”之外的状态，该命令还打印自控制接口进入其当前状态以来经过的秒数。</p><p><strong>脏页率计算</strong></p><p><strong>语法：</strong></p><p>domdirtyrate-calc &lt;域&gt; [–seconds &lt;秒&gt;]<br>–mode&#x3D;[page-sampling | dirty-bitmap | dirty-ring]</p><p>计算活动域的内存脏页率，用户可能期望以此决定是否适合迁移出去。seconds参数可用于在特定时间计算脏页率，现在最多允许60s，如果缺失则默认为1s。这三种<em>page-sampling、dirty-bitmap、dirty-ring</em>模式在指定计算模式时是互斥且可选的，如果缺失则<em>page-sampling</em>是默认模式。通过调用’domstats –dirtyrate’可以获取计算的脏页率信息。</p><p><strong>域显示</strong></p><p><strong>语法：</strong></p><p>domdisplay 域 [–include-password] [[–type] 类型] [–all]</p><p>输出可用于通过VNC、SPICE或RDP连接到域的图形显示的URI。可以使用type参数选择特定的图形显示类型（例如“vnc”、“spice”、“rdp”）。如果指定*–include-password<em>，则SPICE通道密码将包含在URI中。如果指定</em>–all*，则显示所有可能的图形显示，因为VM可能有多个图形显示。</p><p><strong>域显示重新加载</strong></p><p><strong>语法：</strong></p><p>domdisplay-reload &lt;域&gt; [–type &lt;类型&gt;]</p><p>重新加载域的图形显示。这会重新加载其TLS证书而不重新启动域。type可以是<em>virDomainGraphicsReloadType</em>枚举中的任何常量。默认情况下，重新加载任何支持的类型（目前仅VNC）。</p><p><strong>域文件系统冻结</strong></p><p><strong>语法：</strong></p><p>domfsfreeze 域 [[–mountpoint] 挂载点…]</p><p>冻结正在运行的域中的已挂载文件系统，以准备一致的快照。</p><p><em>–mountpoint</em>选项接受参数挂载点，这是要冻结的文件系统的挂载点路径。此选项可以多次出现。如果未指定此选项，则冻结每个已挂载的文件系统。</p><p>注意：snapshot-create命令具有*–quiesce*选项，可以自动冻结和解冻文件系统以保持快照一致。domfsfreeze命令仅在用户希望利用libvirt不支持的存储设备的本地快照功能时才需要。</p><p><strong>域文件系统信息</strong></p><p><strong>语法：</strong></p><p>domfsinfo 域</p><p>显示正在运行的域中已挂载文件系统的列表。该列表包含挂载点、客户机中已挂载设备的名称、文件系统类型和域XML中使用的唯一目标名称（&lt;target dev&#x3D;’name’&#x2F;&gt;）。</p><p>注意：此命令需要在域的客户机操作系统中配置并运行客户机代理。</p><p><strong>域文件系统解冻</strong></p><p><strong>语法：</strong></p><p>domfsthaw 域 [[–mountpoint] 挂载点…]</p><p>解冻由domfsfreeze命令冻结的正在运行的域中的已挂载文件系统。</p><p><em>–mountpoint</em>选项接受参数挂载点，这是要解冻的文件系统的挂载点路径。此选项可以多次出现。如果未指定此选项，则解冻每个已挂载的文件系统。</p><p><strong>域文件系统修剪</strong></p><p><strong>语法：</strong></p><p>domfstrim 域 [–minimum 字节] [–mountpoint 挂载点]</p><p>在正在运行的域中的所有已挂载文件系统上发出fstrim命令。它丢弃文件系统未使用的块。如果指定*–minimum<em>字节，则告诉客户内核连续空闲范围的长度。小于此值的可能会被忽略（这是一个提示，客户可能不会遵守）。通过增加此值，fstrim操作将更快完成，对于具有严重碎片化空闲空间的文件系统，尽管并非所有块都会被丢弃。默认值为零，表示“丢弃每个空闲块”。此外，如果用户只想修剪一个挂载点，可以通过可选的</em>–mountpoint*参数指定。</p><p><strong>域主机名</strong></p><p><strong>语法：</strong></p><p>domhostname 域 [–source lease|agent]</p><p>如果管理程序可用，则返回域的主机名。</p><p><em>–source</em>参数指定用于主机名的数据源，当前为“lease”读取DHCP租约或“agent”通过代理查询客户操作系统。如果未指定，驱动程序返回可用的默认方法（某些驱动程序仅支持一种类型的源）。</p><p><strong>域ID</strong></p><p><strong>语法：</strong></p><p>domid 域名或UUID</p><p>将域名（或UUID）转换为域ID</p><p><strong>域接口获取链接</strong></p><p><strong>语法：</strong></p><p>domif-getlink 域 接口设备 [–config]</p><p>查询域虚拟接口的链接状态。如果指定*–config<em>，则查询持久配置，为了兼容性，</em>–persistent<em>是</em>–config*的别名。</p><p><em>接口设备</em>可以是接口的目标名称或MAC地址。</p><p><strong>域接口设置链接</strong></p><p><strong>语法：</strong></p><p>domif-setlink 域 接口设备 状态 [–config] [–print-xml]</p><p>修改域虚拟接口的链接状态。状态的可能值为“up”和“down”。如果指定*–config<em>，则仅修改域的持久配置，为了兼容性，</em>–persistent<em>是</em>–config<em>的别名。</em>接口设备*可以是接口的目标名称或MAC地址。</p><p>如果指定*–print-xml*，则打印用于更新接口的XML。</p><p><strong>域接口地址</strong></p><p><strong>语法：</strong></p><p>domifaddr 域 [接口] [–full]<br>[–source lease|agent|arp]</p><p>获取正在运行的域的接口列表及其IP和MAC地址，或如果指定<em>接口</em>，则仅显示一个接口的有限输出。请注意，<em>接口</em>可能依赖于驱动程序，可以是客户操作系统中的名称或域XML中看到的名称。此外，在某些管理程序（特别是QEMU）下，整个命令可能要求为查询的域配置客户代理。</p><p>如果指定*–full*，则当接口有多个IP地址或别名时，始终显示接口名称和MAC地址；否则，仅对第一个名称和MAC地址显示接口名称和MAC地址，其他使用相同名称和MAC地址的显示为“-”。</p><p><em>–source</em>参数指定用于地址的数据源，当前为“lease”读取DHCP租约，“agent”通过代理查询客户操作系统，或“arp”从主机的arp表中获取IP。如果未指定，“lease”是默认值。</p><p><strong>备份开始</strong></p><p><strong>语法：</strong></p><p>backup-begin 域 [backupxml] [checkpointxml] [–reuse-external]</p><p>开始新的备份作业。如果省略<em>backupxml</em>，则默认为使用libvirt生成的文件名的完整备份；提供XML允许微调，例如请求相对于早期检查点的增量备份，控制哪些磁盘参与或涉及哪些文件名，或请求使用拉模型备份。<em>backup-dumpxml</em>命令显示libvirt分配的任何结果值。有关备份XML的更多信息，请参见：<a href="https://libvirt.org/formatbackup.html">https://libvirt.org/formatbackup.html</a></p><p>如果使用*–reuse-external<em>，则指示libvirt重用用户在</em>backupxml*中提供的临时和输出文件。</p><p>如果指定<em>checkpointxml</em>，则使用包含<em>domaincheckpoint</em>顶级元素的第二个文件创建同时检查点，以便在创建备份时进行稍后的增量备份。有关检查点的更多详细信息，请参见<em>checkpoint-create</em>。</p><p>此命令尽快返回，备份作业在后台运行；可以使用<em>domjobinfo</em>检查推送模型备份的进度，或使用<em>event</em>等待事件（拉模型备份的进度由连接到NBD导出的任何第三方控制）。使用<em>domjobabort</em>结束作业。</p><p><strong>备份转储XML</strong></p><p><strong>语法：</strong></p><p>backup-dumpxml [–xpath 表达式] [–wrap] 域</p><p>输出描述当前备份作业的XML。</p><p>如果**–xpath<strong>参数提供XPath表达式，则将对输出XML求值，并仅打印匹配的节点。默认行为是将每个匹配节点打印为独立文档，但是为了便于进一步处理，</strong>–wrap**参数将使匹配节点包装在公共根节点中。</p><p><strong>域接口列表</strong></p><p><strong>语法：</strong></p><p>domiflist 域 [–inactive]</p><p>打印显示与域关联的所有虚拟接口的简要信息的表格。如果指定*–inactive<em>，则查询将在下次启动时使用的虚拟接口，而不是当前正在使用的域。其他需要虚拟接口MAC地址的上下文（例如</em>detach-interface<em>或</em>domif-setlink*）将接受此命令打印的MAC地址。</p><p><strong>域接口统计</strong></p><p><strong>语法：</strong></p><p>domifstat 域 接口设备</p><p>获取正在运行的域的网络接口统计信息。网络接口统计信息仅适用于具有物理源接口的接口。这不包括例如“user”接口类型，因为它是具有NAT到外部世界的虚拟LAN。<em>接口设备</em>可以是接口的目标名称或MAC地址。请注意，对于非托管<em>ethernet</em>类型，返回的统计信息可能交换了RX&#x2F;TX。</p><p><strong>域接口调优</strong></p><p><strong>语法：</strong></p><p>domiftune 域 接口设备 [[–config] [–live] | [–current]]<br>[–inbound 平均,峰值,突发,下限]<br>[–outbound 平均,峰值,突发]</p><p>设置或查询域的网络接口的带宽参数。<em>接口设备</em>可以是接口的目标名称（&lt;target dev&#x3D;’name’&#x2F;&gt;）或MAC地址。</p><p>如果未指定*–inbound<em>或</em>–outbound<em>，则此命令将查询并显示带宽设置。否则，它将设置入站或出站带宽。</em>平均,峰值,突发,下限<em>与命令</em>attach-interface<em>中的相同。</em>平均<em>、</em>峰值<em>和</em>下限<em>的值以千字节&#x2F;秒表示，而</em>突发<em>以</em>峰值*速度的单次突发中的千字节表示，如网络XML文档中所述：<a href="https://libvirt.org/formatnetwork.html#quality-of-service%E3%80%82">https://libvirt.org/formatnetwork.html#quality-of-service。</a></p><p>要清除入站或出站设置，分别使用*–inbound<em>或</em>–outbound*，平均值为零。</p><p>如果指定*–live<em>，则影响正在运行的客户机。如果指定</em>–config<em>，则影响持久客户机的下一次启动。如果指定</em>–current<em>，则根据客户机的当前状态等效于</em>–live<em>或</em>–config<em>。可以同时指定</em>–live<em>和</em>–config<em>标志，但</em>–current*是互斥的。如果未指定标志，行为因管理程序而异。</p><p><strong>域信息</strong></p><p><strong>语法：</strong></p><p>dominfo 域</p><p>返回有关域的基本信息。</p><p><strong>域作业中止</strong></p><p><strong>语法：</strong></p><p>domjobabort 域 [–postcopy]</p><p>中止当前正在运行的域作业。</p><p>当中止的作业是进入后复制模式的迁移时，由于迁移中涉及的没有一个主机具有域的完整状态，因此无法中止。可选的*–postcopy<em>可用于中断此类迁移，尽管这样做可能会有效地暂停域，直到迁移恢复（另请参见迁移的</em>–postcopy-resume*选项）。</p><p><strong>域作业信息</strong></p><p><strong>语法：</strong></p><p>domjobinfo 域 [–completed [–keep-completed]] [–anystats] [–rawstats]</p><p>返回在域上运行的作业的信息。*–completed<em>告诉virsh返回最近完成的作业的信息。完成的作业的统计信息在读取后自动销毁（除非使用</em>–keep-completed*）或重新启动libvirtd时。</p><p>通常仅打印正在运行和成功完成的作业的统计信息。*–anystats*也可用于显示失败作业的统计信息。</p><p>如果使用*–rawstats*，则所有字段按从服务器接收的方式打印，不尝试解释数据。“Job type:”字段是特殊的，因为它是通过API报告的，不是统计信息的一部分。</p><p>请注意，对于已完成的迁移返回的时间信息可能完全不相关，除非源主机和目标主机具有同步时间（即，两者都运行NTP守护程序）。</p><p><strong>域启动安全信息</strong></p><p><strong>语法：</strong></p><p>domlaunchsecinfo 域</p><p>返回与正在运行的域关联的启动安全参数的信息。</p><p>报告的参数集将根据活动的启动安全保护类型而变化。如果没有活动，则不报告任何参数。</p><p><strong>域设置启动安全状态</strong></p><p><strong>语法：</strong></p><p>domsetlaunchsecstate 域 –secrethdr hdr-filename<br>–secret secret-filename [–set-address 地址]</p><p>在客户内存中设置启动安全密钥。客户必须在其配置中启用launchSecurity类型并处于暂停状态。成功后，客户可以转换为运行状态。失败时，应销毁客户。</p><p><em>–secrethdr</em>指定包含base64编码的密钥头的文件名。头包括管理程序固件恢复启动密钥明文所需的工件。*–secret*指定包含base64编码的加密启动密钥的文件名。</p><p><em>–set-address</em>选项可用于指定客户内存中设置密钥的物理地址。如果未指定，地址将由管理程序确定。</p><p><strong>域内存统计</strong></p><p><strong>语法：</strong></p><p>dommemstat 域 [–period 秒] [[–config] [–live] | [–current]]</p><p>获取正在运行的域的内存统计信息。</p><p>这些字段的可用性取决于管理程序。不支持的字段将从输出中缺失。如果与较新版本的libvirtd通信，可能会出现其他字段。</p><p>字段说明：</p><ul><li><p>swap_in - 从交换空间读取的数据量（KiB）</p></li><li><p>swap_out - 写入交换空间的内存量（KiB）</p></li><li><p>major_fault - 需要磁盘IO的页面错误数</p></li><li><p>minor_fault - 其他页面错误数</p></li><li><p>unused - 系统未使用的内存量（KiB）</p></li><li><p>available - 域可见的可用内存量（KiB）</p></li><li><p>actual - 当前气球值（KiB）</p></li><li><p>rss - 运行域进程的驻留集大小（KiB）</p></li><li><p>usable - 可以通过气球回收而不会导致主机交换的内存量（KiB）</p></li><li><p>last-update - 上次统计信息更新的时间戳（秒）</p></li><li><p>disk_caches - 无需额外IO即可回收的内存量，通常是磁盘缓存（KiB）</p></li><li><p>hugetlb_pgalloc - 从域内启动的成功大页分配数</p></li><li><p>hugetlb_pgfail - 从域内启动的失败大页分配数</p></li></ul><p>对于带有内存气球的QEMU&#x2F;KVM，将可选的*–period<em>设置为大于0的值（秒）将允许气球驱动程序返回额外的统计信息，这些统计信息将由后续的dommemstat命令显示。将</em>–period*设置为0将停止气球驱动程序的收集，但不会清除气球驱动程序中的统计信息。至少需要QEMU&#x2F;KVM 1.5在主机上运行。</p><p><em>–live</em>、*–config<em>和</em>–current<em>标志仅在用于设置气球驱动程序的收集周期时有效。如果指定</em>–live<em>，则仅影响正在运行的客户机的收集周期。如果指定</em>–config<em>，则影响持久客户机的下一次启动。如果指定</em>–current<em>，则根据客户机的当前状态等效于</em>–live<em>或</em>–config*。</p><p>可以同时指定*–live<em>和</em>–config<em>标志，但</em>–current*是互斥的。如果未指定标志，行为因客户机状态而异。</p><p><strong>域名</strong></p><p><strong>语法：</strong></p><p>domname 域ID或UUID</p><p>将域ID（或UUID）转换为域名</p><p><strong>域电源管理挂起</strong></p><p><strong>语法：</strong></p><p>dompmsuspend 域 目标 [–duration 秒]</p><p>将正在运行的域挂起到以下状态之一（可能的<em>目标</em>值）：</p><ul><li><p>mem - 相当于S3 ACPI状态</p></li><li><p>disk - 相当于S4 ACPI状态</p></li><li><p>hybrid - RAM保存到磁盘但不关闭电源</p></li></ul><p><em>–duration</em>参数指定域挂起后唤醒前的秒数（另请参见dompmwakeup）。默认为0，表示无限挂起时间。（此功能目前不受任何管理程序驱动程序支持，应使用0。）</p><p>注意：此命令需要在域的客户机操作系统中配置并运行客户机代理。</p><p>请注意，至少对于QEMU，当使用目标磁盘时，域的进程将终止，并在libvirt请求唤醒域时启动新进程。因此，任何运行时更改（例如设备热插拔或内存设置）将丢失，除非这些更改是使用*–config*标志进行的。</p><p><strong>域电源管理唤醒</strong></p><p><strong>语法：</strong></p><p>dompmwakeup 域</p><p>从pmsuspended状态唤醒域（由dompmsuspend或客户机本身挂起）。向处于pmsuspended状态的客户注入唤醒，而不是等待先前请求的持续时间（如果有）过去。此操作不一定失败，如果域正在运行。</p><p><strong>域重命名</strong></p><p><strong>语法：</strong></p><p>domrename 域 新名称</p><p>重命名域。此命令将当前域名更改为第二个参数中指定的新名称。</p><p>注意：域必须处于非活动状态。</p><p><strong>域状态</strong></p><p><strong>语法：</strong></p><p>domstate 域 [–reason]</p><p>返回有关域的状态。*–reason*告诉virsh还打印状态的原因。</p><p><strong>域统计</strong></p><p><strong>语法：</strong></p><p>domstats [–raw] [–enforce] [–backing] [–nowait] [–state]<br>[–cpu-total] [–balloon] [–vcpu] [–interface]<br>[–block] [–perf] [–iothread] [–memory] [–dirtyrate] [–vm]<br>[[–list-active] [–list-inactive]<br>[–list-persistent] [–list-transient] [–list-running]<br>[–list-paused] [–list-shutoff] [–list-other]] | [域 …]</p><p>获取多个或所有域的统计信息。不带任何参数时，此命令打印所有域的所有可用统计信息。</p><p>要收集统计信息的域列表可以通过将域列为空格分隔的列表来限制，或通过指定其中一个过滤标志*–list-NNN*。（这些方法不能组合使用。）</p><p>默认情况下，某些返回的字段可能会通过一组漂亮的打印机转换为更人类友好的值。要抑制此行为，请使用*–raw*标志。</p><p>可以通过特定标志选择各个统计信息组。默认情况下，返回所有支持的统计信息组。支持的统计信息组标志包括：*–state<em>、</em>–cpu-total<em>、</em>–balloon<em>、</em>–vcpu<em>、</em>–interface<em>、</em>–block<em>、</em>–perf<em>、</em>–iothread<em>、</em>–memory<em>、</em>–dirtyrate<em>、</em>–vm*。</p><p>请注意，根据管理程序类型和版本或域状态，可能不会返回以下所有统计信息。</p><p>选择*–state*组时，返回以下字段：</p><ul><li><p>state.state - VM的状态，作为virDomainState枚举中的数字返回</p></li><li><p>state.reason - 进入给定状态的原因，作为与给定状态对应的virDomain*Reason枚举中的整数返回</p></li></ul><p><em>–cpu-total</em>返回：</p><ul><li><p>cpu.time - 此域的总CPU时间（纳秒）</p></li><li><p>cpu.user - 用户CPU时间（纳秒）</p></li><li><p>cpu.system - 系统CPU时间（纳秒）</p></li><li><p>cpu.haltpoll.success.time - CPU暂停轮询成功时间（纳秒）</p></li><li><p>cpu.haltpoll.fail.time - CPU暂停轮询失败时间（纳秒）</p></li><li><p>cpu.cache.monitor.count - 此域的缓存监视器数量</p></li><li><p>cpu.cache.monitor.&lt;num&gt;.name - 缓存监视器&lt;num&gt;的名称</p></li><li><p>cpu.cache.monitor.&lt;num&gt;.vcpus - 缓存监视器&lt;num&gt;的vcpu列表</p></li><li><p>cpu.cache.monitor.&lt;num&gt;.bank.count - 缓存监视器&lt;num&gt;中的缓存库数量</p></li><li><p>cpu.cache.monitor.&lt;num&gt;.bank.&lt;index&gt;.id - 主机为缓存监视器&lt;num&gt;中的库&lt;index&gt;分配的缓存ID</p></li><li><p>cpu.cache.monitor.&lt;num&gt;.bank.&lt;index&gt;.bytes - 域在缓存库&lt;index&gt;上使用的最后一级缓存的字节数</p></li></ul><p><em>–balloon</em>返回：</p><ul><li><p>balloon.current - 当前使用的内存（KiB）</p></li><li><p>balloon.maximum - 允许的最大内存（KiB）</p></li><li><p>balloon.swap_in - 从交换空间读取的数据量（KiB）</p></li><li><p>balloon.swap_out - 写入交换空间的内存量（KiB）</p></li><li><p>balloon.major_fault - 需要磁盘IO的页面错误数</p></li><li><p>balloon.minor_fault - 其他页面错误数</p></li><li><p>balloon.unused - 系统未使用的内存量（KiB）</p></li><li><p>balloon.available - 域可见的可用内存量（KiB）</p></li><li><p>balloon.rss - 运行域进程的驻留集大小（KiB）</p></li><li><p>balloon.usable - 可以通过气球回收而不会导致主机交换的内存量（KiB）</p></li><li><p>balloon.last-update - 上次统计信息更新的时间戳（秒）</p></li><li><p>balloon.disk_caches - 无需额外IO即可回收的内存量，通常是磁盘（KiB）</p></li><li><p>balloon.hugetlb_pgalloc - 通过virtio气球从域内启动的成功大页分配数</p></li><li><p>balloon.hugetlb_pgfail - 通过virtio气球从域内启动的失败大页分配数</p></li></ul><p><em>–vcpu</em>返回：</p><ul><li><p>vcpu.current - 当前在线虚拟CPU的数量</p></li><li><p>vcpu.maximum - 在线虚拟CPU的最大数量</p></li><li><p>vcpu.&lt;num&gt;.state - 虚拟CPU&lt;num&gt;的状态，作为virVcpuState枚举中的数字</p></li><li><p>vcpu.&lt;num&gt;.time - 虚拟CPU&lt;num&gt;花费的虚拟CPU时间（纳秒）</p></li><li><p>vcpu.&lt;num&gt;.wait - vCPU&lt;num&gt;线程在调度程序有其他任务在其前面运行时在运行队列中等待的时间（纳秒），在Linux上需要CONFIG_SCHED_INFO</p></li><li><p>vcpu.&lt;num&gt;.halted - 虚拟CPU&lt;num&gt;是否暂停：是或否（可能表示处理器空闲或甚至禁用，取决于架构）</p></li><li><p>vcpu.&lt;num&gt;.delay - vCPU&lt;num&gt;线程在调度程序有其他任务在其前面运行时在运行队列中等待的时间（纳秒）。作为窃取时间暴露给VM。</p></li></ul><p>此组统计信息还报告额外的管理程序来源的每vCPU统计信息。此组中的管理程序特定统计信息具有以下命名方案：</p><p>vcpu.&lt;num&gt;.$NAME.$TYPE</p><p><strong>$NAME</strong></p><p>管理程序提供的统计信息字段的名称</p><p><strong>$TYPE</strong></p><p>值的类型。返回以下类型：</p><p><strong>cur</strong></p><p>当前瞬时值</p><p><strong>sum</strong></p><p>聚合值</p><p><strong>max</strong></p><p>峰值值</p><p>返回值可以是无符号长整型或布尔型。含义是管理程序特定的。请参阅<em>--vm</em>组的免责声明，该组也由管理程序特定的统计信息组成。</p><p><em>–interface</em>返回：</p><ul><li><p>net.count - 此域上的网络接口数量</p></li><li><p>net.&lt;num&gt;.name - 接口&lt;num&gt;的名称</p></li><li><p>net.&lt;num&gt;.rx.bytes - 接收的字节数</p></li><li><p>net.&lt;num&gt;.rx.pkts - 接收的数据包数</p></li><li><p>net.&lt;num&gt;.rx.errs - 接收错误数</p></li><li><p>net.&lt;num&gt;.rx.drop - 丢弃的接收数据包数</p></li><li><p>net.&lt;num&gt;.tx.bytes - 发送的字节数</p></li><li><p>net.&lt;num&gt;.tx.pkts - 发送的数据包数</p></li><li><p>net.&lt;num&gt;.tx.errs - 发送错误数</p></li><li><p>net.&lt;num&gt;.tx.drop - 丢弃的发送数据包数</p></li></ul><p><em>–perf</em>返回所有启用的性能事件的统计信息：</p><ul><li><p>perf.cmt - 当前使用的缓存使用量（字节）</p></li><li><p>perf.mbmt - 从一级缓存到另一级的总系统带宽</p></li><li><p>perf.mbml - 内存控制器的内存流量带宽</p></li><li><p>perf.cpu_cycles - CPU周期计数（总&#x2F;经过）</p></li><li><p>perf.instructions - 指令计数</p></li><li><p>perf.cache_references - 缓存命中计数</p></li><li><p>perf.cache_misses - 缓存未命中计数</p></li><li><p>perf.branch_instructions - 分支指令计数</p></li><li><p>perf.branch_misses - 分支未命中计数</p></li><li><p>perf.bus_cycles - 总线周期计数</p></li><li><p>perf.stalled_cycles_frontend - 前端指令处理器管道中的停滞CPU周期计数</p></li><li><p>perf.stalled_cycles_backend - 后端指令处理器管道中的停滞CPU周期计数</p></li><li><p>perf.ref_cpu_cycles - 参考CPU周期计数</p></li><li><p>perf.cpu_clock - CPU时钟时间</p></li><li><p>perf.task_clock - 任务时钟时间</p></li><li><p>perf.page_faults - 页面错误计数</p></li><li><p>perf.context_switches - 上下文切换计数</p></li><li><p>perf.cpu_migrations - CPU迁移计数</p></li><li><p>perf.page_faults_min - 次要页面错误计数</p></li><li><p>perf.page_faults_maj - 主要页面错误计数</p></li><li><p>perf.alignment_faults - 对齐错误计数</p></li><li><p>perf.emulation_faults - 仿真错误计数</p></li></ul><p>有关每个事件的更多详细信息，请参阅perf命令。</p><p><em>–block</em>返回有关与每个域关联的磁盘的信息。使用*–backing*标志将此信息扩展到覆盖支持链中的所有资源，而不是默认情况下将信息限制为每个客户磁盘的活动层。列出的信息包括：</p><ul><li><p>block.count - 列出的块设备数量</p></li><li><p>block.&lt;num&gt;.name - 块设备&lt;num&gt;的目标名称（如果存在*–backing*，则多个条目使用相同的名称）</p></li><li><p>block.&lt;num&gt;.backingIndex - 当存在*–backing*时，与域XML中列出的&lt;backingStore&gt;索引匹配</p></li><li><p>block.&lt;num&gt;.path - 块设备&lt;num&gt;的文件源，如果是本地文件或块设备</p></li><li><p>block.&lt;num&gt;.rd.reqs - 读取请求数</p></li><li><p>block.&lt;num&gt;.rd.bytes - 读取字节数</p></li><li><p>block.&lt;num&gt;.rd.times - 读取花费的总时间（纳秒）</p></li><li><p>block.&lt;num&gt;.wr.reqs - 写入请求数</p></li><li><p>block.&lt;num&gt;.wr.bytes - 写入字节数</p></li><li><p>block.&lt;num&gt;.wr.times - 写入花费的总时间（纳秒）</p></li><li><p>block.&lt;num&gt;.fl.reqs - 总刷新请求数</p></li><li><p>block.&lt;num&gt;.fl.times - 缓存刷新花费的总时间（纳秒）</p></li><li><p>block.&lt;num&gt;.errors - 仅Xen：’oo_req’值</p></li><li><p>block.&lt;num&gt;.allocation - 最高写入扇区的偏移（字节）</p></li><li><p>block.&lt;num&gt;.capacity - 源文件的逻辑大小（字节）</p></li><li><p>block.&lt;num&gt;.physical - 源文件的物理大小（字节）</p></li><li><p>block.&lt;num&gt;.threshold - 传递VIR_DOMAIN_EVENT_ID_BLOCK_THRESHOLD事件的阈值（字节）。参见domblkthreshold。</p></li></ul><p><em>–iothread</em>返回有关运行客户机上的IOThread的信息（如果管理程序支持）。</p><p>每个线程的“poll-max-ns”是允许每个轮询间隔发生的最大纳秒数。轮询间隔是允许线程处理数据的时间段，然后客户将其CPU量子返回给主机。设置得太小的值不允许IOThread在CPU上运行足够长的时间来处理数据。设置得太高的值会消耗过多的CPU时间，每个IOThread无法允许CPU上运行的其他线程获得时间。轮询间隔不可用于统计目的。</p><ul><li><strong>iothread.count</strong> - 后续列表中的IOThread的最大数量</li></ul><p>作为无符号整数。列表中的每个IOThread将使用其iothread_id值作为&lt;id&gt;。如果轮询值不受支持，则&lt;id&gt;条目可能少于iothread.count值。</p><ul><li><p>iothread.&lt;id&gt;.poll-max-ns - &lt;id&gt; IOThread使用的最大轮询时间（纳秒）。值为0（零）表示轮询被禁用。</p></li><li><p>iothread.&lt;id&gt;.poll-grow - 轮询时间增长值。值为0（零）表示增长由管理程序管理。</p></li><li><p>iothread.&lt;id&gt;.poll-shrink - 轮询时间缩小值。值为（零）表示缩小由管理程序管理。</p></li></ul><p><em>–memory</em>返回：</p><ul><li><p>memory.bandwidth.monitor.count - 此域的内存带宽监视器数量</p></li><li><p>memory.bandwidth.monitor.&lt;num&gt;.name - 监视器&lt;num&gt;的名称</p></li><li><p>memory.bandwidth.monitor.&lt;num&gt;.vcpus - 监视器&lt;num&gt;的vcpu列表</p></li><li><p><strong>memory.bandwidth.monitor.&lt;num&gt;.node.count</strong> - 内存</p></li></ul><p>控制器在监视器&lt;num&gt;中的数量</p><ul><li><p>memory.bandwidth.monitor.&lt;num&gt;.node.&lt;index&gt;.id - 主机为监视器&lt;num&gt;中的控制器&lt;index&gt;分配的内存控制器ID</p></li><li><p>memory.bandwidth.monitor.&lt;num&gt;.node.&lt;index&gt;.bytes.local - 通过@vcpus消耗的字节数，这些vcpu通过属于调度主机CPU的同一处理器中的内存控制器。</p></li><li><p>memory.bandwidth.monitor.&lt;num&gt;.node.&lt;index&gt;.bytes.total - 通过@vcpus消耗的总字节数，这些vcpu通过所有内存控制器，无论是本地还是远程控制器。</p></li></ul><p><em>–dirtyrate</em>返回：</p><ul><li><p>dirtyrate.calc_status - 上次内存脏页率计算的状态，作为virDomainDirtyRateStatus枚举中的数字返回。</p></li><li><p>dirtyrate.calc_start_time - 上次内存脏页率计算的开始时间。</p></li><li><p>dirtyrate.calc_period - 上次内存脏页率计算的周期。</p></li><li><p>dirtyrate.megabytes_per_second - 计算的内存脏页率（MiB&#x2F;s）。</p></li><li><p>dirtyrate.calc_mode - 上次测量使用的计算模式（page-sampling&#x2F;dirty-bitmap&#x2F;dirty-ring）</p></li><li><p>dirtyrate.vcpu.&lt;num&gt;.megabytes_per_second - 虚拟CPU的内存脏页率（MiB&#x2F;s）</p></li></ul><p><em>–vm</em>返回：</p><p><em>--vm</em>选项启用管理程序特定统计信息的报告。字段的命名和含义完全取决于管理程序。</p><p>此组中的统计信息具有以下命名方案：</p><p>vm.$NAME.$TYPE</p><p><strong>$NAME</strong></p><p>管理程序提供的统计信息字段的名称</p><p><strong>$TYPE</strong></p><p>值的类型。返回以下类型：</p><p><strong>cur</strong></p><p>当前瞬时值</p><p><strong>sum</strong></p><p>聚合值</p><p><strong>max</strong></p><p>峰值值</p><p>返回值可以是无符号长整型或布尔型。</p><p><strong>警告</strong>：此组中报告的统计信息是运行时收集的，源自管理程序，因此不属于libvirt的常规稳定API策略。</p><p>Libvirt无法保证从外部源报告的统计信息将在管理程序的未来版本中存在，或命名或含义保持一致。但是，对现有字段的更改预计很少。</p><p>选择特定的统计信息组不保证守护程序支持所选统计信息组。标志<em>--enforce</em>强制命令在守护程序不支持所选组时失败。</p><p>在收集统计信息时，libvirtd可能会等待一段时间，如果给定域上已有另一个作业正在运行以完成。这可能导致不必要的延迟传递统计信息。使用<em>--nowait</em>抑制此行为。另一方面，此类域可能会缺少某些统计信息。</p><p><strong>域时间</strong></p><p><strong>语法：</strong></p><p>domtime 域 { [–now] [–pretty] [–sync] [–time 时间] }</p><p>获取或设置域的系统时间。当不带任何参数（但<em>域</em>）运行时，打印域的当前系统时间。<em>--pretty</em>修饰符可用于以更人类可读的形式打印时间。</p><p>当指定<em>--time</em>时间时，不获取域的时间，而是设置它。<em>--now</em>修饰符的作用类似于<em>--time</em> $now的别名，这意味着它设置virsh运行的主机上当前的时间。在这两种情况下（设置和获取），时间是以1970-01-01纪元以来的秒数为单位的UTC时间。<em>--sync</em>修改设置行为：忽略传递的时间，而是从域的RTC读取要设置的时间。请注意，某些管理程序可能需要配置客户代理才能获取或设置客户时间。</p><p><strong>域UUID</strong></p><p><strong>语法：</strong></p><p>domuuid 域名或ID</p><p>将域名或ID转换为域UUID</p><p><strong>域XML从原生格式转换</strong></p><p><strong>语法：</strong></p><p>domxml-from-native 格式 配置</p><p>将原生客户配置格式<em>格式</em>的文件<em>配置</em>转换为域XML格式。对于QEMU&#x2F;KVM管理程序，<em>格式</em>参数必须为qemu-argv。对于Xen管理程序，<em>格式</em>参数可以是xen-xm、xen-xl或xen-sxpr。对于LXC管理程序，<em>格式</em>参数必须为lxc-tools。对于VMware&#x2F;ESX管理程序，<em>格式</em>参数必须为vmware-vmx。对于Bhyve管理程序，<em>格式</em>参数必须为bhyve-argv。</p><p><strong>域XML转换为原生格式</strong></p><p><strong>语法：</strong></p><p>domxml-to-native 格式 { [–xml] xml | –domain 域名或ID或UUID }</p><p>将文件<em>xml</em>转换为域XML格式，或将现有的<em>--domain</em>转换为名为<em>格式</em>的原生客户配置格式。<em>xml</em>和<em>--domain</em>参数是互斥的。有关<em>格式</em>参数的类型，请参阅domxml-from-native。</p><p><strong>转储</strong></p><p><strong>语法：</strong></p><p>dump 域 核心文件路径 [–bypass-cache]<br>{ [–live] | [–crash] | [–reset] }<br>[–verbose] [–memory-only] [–format 字符串]</p><p>将域的核心转储到文件以进行分析。如果指定<em>--live</em>，域在核心转储完成之前继续运行，而不是提前暂停。如果指定<em>--crash</em>，域以崩溃状态停止，而不仅仅是保持在暂停状态。如果指定<em>--reset</em>，域在成功转储后重置。注意，这三个开关是互斥的。如果指定<em>--bypass-cache</em>，保存将避免文件系统缓存，尽管这可能会减慢操作速度。如果指定<em>--memory-only</em>，文件是elf文件，仅包含域的内存和CPU通用寄存器值。如果域直接使用主机设备，这将非常有用。<em>--format</em> <em>字符串</em>用于指定“memory-only”转储的格式，<em>字符串</em>可以是以下之一：elf、kdump-zlib（zlib压缩的kdump压缩格式）、kdump-lzo（lzo压缩的kdump压缩格式）、kdump-snappy（snappy压缩的kdump压缩格式）、win-dmp（Windows完整崩溃转储格式）。</p><p>可以使用domjobinfo virsh命令监视进度，并使用domjobabort命令（由另一个virsh实例发送）取消。另一个选项是向运行dump命令的virsh进程发送SIGINT（通常使用Ctrl-C）。<em>--verbose</em>显示转储的进度。</p><p>注意：某些管理程序可能需要用户手动确保<em>核心文件路径</em>参数指定的文件和路径具有适当的权限。</p><p>注意：旧kvmdump格式的崩溃转储正在过时，自其版本6.1.0以来无法由崩溃实用程序加载和处理。需要<em>--memory-only</em>选项以生成可由崩溃实用程序稍后处理的有效ELF文件。</p><p><strong>转储XML</strong></p><p><strong>语法：</strong></p><p>dumpxml [–inactive] [–security-info] [–update-cpu] [–migratable]<br>[–xpath 表达式] [–wrap] 域</p><p>将域信息作为XML转储输出到stdout，此格式可由create命令使用。可以使用影响XML转储的其他选项。<em>--inactive</em>告诉virsh转储将在域下次启动时使用的域配置，而不是当前域配置。使用<em>--security-info</em>还将包括XML转储中的安全敏感信息。<em>--update-cpu</em>根据主机CPU更新域CPU要求。使用<em>--migratable</em>可以请求适合迁移的XML，即与较旧版本的libvirt兼容，并可能使用内部运行时选项进行修改。此选项可能会自动启用其他选项（<em>--update-cpu</em>、<em>--security-info</em>，…）根据需要。</p><p>如果<strong>--xpath</strong>参数提供XPath表达式，则将对输出XML求值，并仅打印匹配的节点。默认行为是将每个匹配节点打印为独立文档，但是为了便于进一步处理，<strong>--wrap</strong>参数将使匹配节点包装在公共根节点中。</p><p><strong>编辑</strong></p><p><strong>语法：</strong></p><p>edit 域</p><p>编辑域的XML配置文件，这将影响客户机的下次启动。</p><p>这等效于：</p><p>virsh dumpxml –inactive –security-info 域 &gt; 域.xml</p><p>vi 域.xml（或使用其他文本编辑器进行更改）</p><p>virsh define 域.xml</p><p>不同之处在于它进行了一些错误检查。</p><p>使用的编辑器可以由$VISUAL或$EDITOR环境变量提供，默认为vi。</p><p><strong>模拟器绑定</strong></p><p><strong>语法：</strong></p><p>emulatorpin 域 [CPU列表] [[–live] [–config] | [–current]]</p><p>查询或更改域的模拟器线程到主机物理CPU的绑定。</p><p>有关<em>CPU列表</em>的信息，请参见vcpupin。</p><p>如果指定<em>--live</em>，则影响正在运行的客户机。如果指定<em>--config</em>，则影响持久客户机的下一次启动。如果指定<em>--current</em>，则根据客户机的当前状态等效于<em>--live</em>或<em>--config</em>。可以同时指定<em>--live</em>和<em>--config</em>标志（如果存在<em>CPU列表</em>），但<em>--current</em>是互斥的。如果未指定标志，行为因管理程序而异。</p><p><strong>事件</strong></p><p><strong>语法：</strong></p><p>event {[域] { 事件 | –all } [–loop] [–timeout 秒] [–timestamp] | –list}</p><p>等待一类域事件发生，并在事件发生时打印适当的详细信息。事件可以选择由<em>域</em>过滤。仅使用<em>--list</em>作为参数将提供此客户端已知的可能<em>事件</em>值的列表，尽管连接可能不允许注册所有这些事件。也可以使用<em>--all</em>代替<em>事件</em>一次注册所有可能的事件类型。</p><p>默认情况下，此命令是一次性的，一旦事件发生即返回成功；您可以发送SIGINT（通常通过Ctrl-C）立即退出。如果指定<em>--timeout</em>，则命令在<em>秒</em>后放弃等待事件。使用<em>--loop</em>，命令打印所有事件，直到超时或中断键。</p><p>当使用<em>--timestamp</em>时，将在事件之前打印人类可读的时间戳。</p><p><strong>获取用户SSH密钥</strong></p><p><strong>语法：</strong></p><p>get-user-sshkeys 域 用户</p><p>打印给定<em>用户</em>在客户<em>域</em>中的SSH授权密钥。请注意，文件中的条目具有*sshd(8)*定义的内部结构，virsh&#x2F;libvirt将密钥视为不透明字符串，即不解释它们。</p><p><strong>客户代理超时</strong></p><p><strong>语法：</strong></p><p>guest-agent-timeout 域 [–timeout 值]</p><p>设置等待客户代理命令响应的时长。默认情况下，代理命令无限期阻塞等待响应。值必须是正值（等待给定的秒数）或以下值之一：</p><ul><li><p>-2 - 无限期阻塞等待结果（当省略--timeout时使用），</p></li><li><p>-1 - 将超时重置为默认值（当前在libvirt守护程序中定义为5秒），</p></li><li><p>0 - 完全不等待，</p></li></ul><p>在所有基于客户代理的API中，当发生超时时，如果实际命令已发送到客户代理，则返回的错误代码将为VIR_ERR_AGENT_COMMAND_TIMEOUT。</p><p><strong>客户信息</strong></p><p><strong>语法：</strong></p><p>guestinfo 域 [–user] [–os] [–timezone] [–hostname] [–filesystem]<br>[–disk] [–interface]</p><p>从客户代理的角度打印有关客户的信息。请注意，此命令需要在域的客户操作系统中配置并运行客户代理。</p><p>当不带任何参数运行时，此命令打印客户代理当时支持的所有信息类型，省略不可用的类型。在这种情况下总是报告成功。</p><p>您可以通过指定一个或多个标志来限制返回的信息类型。可用的信息类型标志包括<em>--user</em>、<em>--os</em>、<em>--timezone</em>、<em>--hostname</em>、<em>--filesystem</em>、<em>--disk</em>、<em>--interface</em>和<em>--load</em>。如果明确请求的信息类型当时不受客户代理支持，则进程将提供退出代码1。</p><p>请注意，根据管理程序类型和在域内运行的客户代理的版本，可能不会返回以下所有信息。</p><p>选择<em>--user</em>信息类型时，可能会返回以下字段：</p><ul><li><p>user.count - 此域上的活动用户数</p></li><li><p>user.&lt;num&gt;.name - 用户&lt;num&gt;的用户名</p></li><li><p>user.&lt;num&gt;.domain - 用户&lt;num&gt;的域（可能仅在某些客户类型上存在）</p></li><li><p>user.&lt;num&gt;.login-time - 用户&lt;num&gt;的登录时间（自纪元以来的毫秒数）</p></li></ul><p><em>--os</em>返回：</p><ul><li><p>os.id - 标识操作系统的字符串</p></li><li><p>os.name - 操作系统的名称</p></li><li><p>os.pretty-name - 操作系统的漂亮名称</p></li><li><p>os.version - 操作系统的版本</p></li><li><p>os.version-id - 操作系统的版本ID</p></li><li><p>os.kernel-release - 操作系统内核的发布</p></li><li><p>os.kernel-version - 操作系统内核的版本</p></li><li><p>os.machine - 机器硬件名称</p></li><li><p>os.variant - 操作系统的特定变体或版本</p></li><li><p>os.variant-id - 操作系统的特定变体或版本的ID</p></li></ul><p><em>--timezone</em>返回：</p><ul><li><p>timezone.name - 时区的名称</p></li><li><p>timezone.offset - 与UTC的偏移（秒）</p></li></ul><p><em>--hostname</em>返回：</p><ul><li>hostname - 域的主机名</li></ul><p><em>--filesystem</em>返回：</p><ul><li><p>fs.count - 此域上定义的文件系统数量</p></li><li><p>fs.&lt;num&gt;.mountpoint - 文件系统&lt;num&gt;的挂载点路径</p></li><li><p>fs.&lt;num&gt;.name - 客户中的设备名称（例如sda1）用于文件系统&lt;num&gt;</p></li><li><p>fs.&lt;num&gt;.fstype - 文件系统&lt;num&gt;的类型</p></li><li><p>fs.&lt;num&gt;.total-bytes - 文件系统&lt;num&gt;的总大小</p></li><li><p>fs.&lt;num&gt;.used-bytes - 文件系统&lt;num&gt;中使用的字节数</p></li><li><p>fs.&lt;num&gt;.disk.count - 文件系统&lt;num&gt;目标的磁盘数量</p></li><li><p>fs.&lt;num&gt;.disk.&lt;num&gt;.alias - 磁盘&lt;num&gt;的设备别名（例如sda）</p></li><li><p>fs.&lt;num&gt;.disk.&lt;num&gt;.serial - 磁盘&lt;num&gt;的序列号</p></li><li><p>fs.&lt;num&gt;.disk.&lt;num&gt;.device - 磁盘&lt;num&gt;的设备节点</p></li></ul><p><em>--disk</em>返回：</p><ul><li><p>disk.count - 此域上定义的磁盘数量</p></li><li><p>disk.&lt;num&gt;.name - 设备节点（Linux）或设备UNC（Windows）</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1 概述&quot;&gt;&lt;/a&gt;1 &lt;strong&gt;概述&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;virsh [&lt;em&gt;选项&lt;/em&gt;]… [&lt;em&gt;命令字符串&lt;/em&gt;]&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="云计算" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="libvirt" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/libvirt/"/>
    
    
    <category term="云计算" scheme="https://watsonlu6.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="libvirt" scheme="https://watsonlu6.github.io/tags/libvirt/"/>
    
  </entry>
  
  <entry>
    <title>12 libvirt使用示例</title>
    <link href="https://watsonlu6.github.io/libvirt%E6%96%87%E6%A1%A3/12-libvirt%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/"/>
    <id>https://watsonlu6.github.io/libvirt%E6%96%87%E6%A1%A3/12-libvirt%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/</id>
    <published>2024-03-12T07:50:26.000Z</published>
    <updated>2025-03-15T08:00:51.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><p>本节将介绍该库的基础知识，旨在提供一个快速教程，让开发人员尽快掌握并运行该库。</p><h2 id="零到虚拟设备"><a href="#零到虚拟设备" class="headerlink" title="零到虚拟设备"></a>零到虚拟设备</h2><p>本节介绍创建虚拟机（或容器）的必要步骤。使用的驱动程序是 QEMU，但这些说明也可用于其他驱动程序。这里给出的命令是针对 python3 的，建议你在使用 ipython3 等交互式提示符时运行这些命令。</p><h3 id="示例-12-1：定义新存储池"><a href="#示例-12-1：定义新存储池" class="headerlink" title="示例 12.1：定义新存储池"></a>示例 12.1：定义新存储池</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> libvirt, sys</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们不需要定义容量，因为我们希望它是无限的。</span></span><br><span class="line">poolXML = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;pool type=&#x27;dir&#x27;&gt;</span></span><br><span class="line"><span class="string">  &lt;name&gt;示例池&lt;/name&gt;</span></span><br><span class="line"><span class="string">  &lt;uuid/&gt;</span></span><br><span class="line"><span class="string">  &lt;source&gt;</span></span><br><span class="line"><span class="string">  &lt;/source&gt;</span></span><br><span class="line"><span class="string">  &lt;target&gt;</span></span><br><span class="line"><span class="string">    &lt;path&gt;/var/lib/libvirt/images&lt;/path&gt;</span></span><br><span class="line"><span class="string">    &lt;permissions&gt;</span></span><br><span class="line"><span class="string">      &lt;mode&gt;0755&lt;/mode&gt;</span></span><br><span class="line"><span class="string">      &lt;owner&gt;-1&lt;/owner&gt;</span></span><br><span class="line"><span class="string">      &lt;group&gt;-1&lt;/group&gt;</span></span><br><span class="line"><span class="string">    &lt;/permissions&gt;</span></span><br><span class="line"><span class="string">  &lt;/target&gt;</span></span><br><span class="line"><span class="string">&lt;/pool&gt;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">pool = conn.storagePoolDefineXML(poolXML, <span class="number">0</span>)</span><br><span class="line">pool.setAutostart(<span class="number">1</span>)</span><br><span class="line">pool.create()</span><br></pre></td></tr></table></figure><h3 id="示例-12-2：定义新存储卷"><a href="#示例-12-2：定义新存储卷" class="headerlink" title="示例 12.2：定义新存储卷"></a>示例 12.2：定义新存储卷</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">volumeXML = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;volume&gt;</span></span><br><span class="line"><span class="string">  &lt;name&gt;Volume.qcow2&lt;/name&gt;</span></span><br><span class="line"><span class="string">  &lt;allocation&gt;0&lt;/allocation&gt;</span></span><br><span class="line"><span class="string">  &lt;capacity unit=&quot;G&quot;&gt;16&lt;/capacity&gt;</span></span><br><span class="line"><span class="string">  &lt;target&gt;</span></span><br><span class="line"><span class="string">    &lt;path&gt;/var/lib/libvirt/images/Volume.qcow2&lt;/path&gt;</span></span><br><span class="line"><span class="string">    &lt;format type=&#x27;qcow2&#x27;/&gt;</span></span><br><span class="line"><span class="string">    &lt;permissions&gt;</span></span><br><span class="line"><span class="string">      &lt;owner&gt;107&lt;/owner&gt;</span></span><br><span class="line"><span class="string">      &lt;group&gt;107&lt;/group&gt;</span></span><br><span class="line"><span class="string">      &lt;mode&gt;0744&lt;/mode&gt;</span></span><br><span class="line"><span class="string">      &lt;label&gt;体积示例&lt;/label&gt;</span></span><br><span class="line"><span class="string">    &lt;/permissions&gt;</span></span><br><span class="line"><span class="string">  &lt;/target&gt;</span></span><br><span class="line"><span class="string">&lt;/volume&gt;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">pool.createXML(volumeXML, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="示例-12-3：定义域"><a href="#示例-12-3：定义域" class="headerlink" title="示例 12.3：定义域"></a>示例 12.3：定义域</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">domainXML = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;domain type=&#x27;kvm&#x27;&gt;</span></span><br><span class="line"><span class="string">  &lt;name&gt;示例域&lt;/name&gt;</span></span><br><span class="line"><span class="string">  &lt;memory unit=&#x27;MiB&#x27;&gt;2048&lt;/memory&gt;</span></span><br><span class="line"><span class="string">  &lt;currentMemory unit=&#x27;MiB&#x27;&gt;2048&lt;/currentMemory&gt;</span></span><br><span class="line"><span class="string">  &lt;vcpu placement=&#x27;static&#x27;&gt;2&lt;/vcpu&gt;</span></span><br><span class="line"><span class="string">  &lt;os&gt;</span></span><br><span class="line"><span class="string">    &lt;type arch=&#x27;x86_64&#x27;&gt;hvm&lt;/type&gt;</span></span><br><span class="line"><span class="string">    &lt;boot dev=&#x27;hd&#x27;/&gt;</span></span><br><span class="line"><span class="string">    &lt;boot dev=&#x27;cdrom&#x27;/&gt;</span></span><br><span class="line"><span class="string">  &lt;/os&gt;</span></span><br><span class="line"><span class="string">  &lt;features&gt;</span></span><br><span class="line"><span class="string">    &lt;acpi/&gt;</span></span><br><span class="line"><span class="string">    &lt;apic/&gt;</span></span><br><span class="line"><span class="string">    &lt;vmport state=&#x27;off&#x27;/&gt;</span></span><br><span class="line"><span class="string">  &lt;/features&gt;</span></span><br><span class="line"><span class="string">  &lt;clock offset=&#x27;utc&#x27;&gt;</span></span><br><span class="line"><span class="string">    &lt;timer name=&#x27;rtc&#x27; tickpolicy=&#x27;catchup&#x27;/&gt;</span></span><br><span class="line"><span class="string">    &lt;timer name=&#x27;pit&#x27; tickpolicy=&#x27;delay&#x27;/&gt;</span></span><br><span class="line"><span class="string">    &lt;timer name=&#x27;hpet&#x27; present=&#x27;no&#x27;/&gt;</span></span><br><span class="line"><span class="string">  &lt;/clock&gt;</span></span><br><span class="line"><span class="string">  &lt;pm&gt;</span></span><br><span class="line"><span class="string">    &lt;suspend-to-mem enabled=&#x27;yes&#x27;/&gt;</span></span><br><span class="line"><span class="string">    &lt;suspend-to-disk enabled=&#x27;yes&#x27;/&gt;</span></span><br><span class="line"><span class="string">  &lt;/pm&gt;</span></span><br><span class="line"><span class="string">  &lt;devices&gt;</span></span><br><span class="line"><span class="string">    &lt;emulator&gt;/usr/bin/kvm-spice&lt;/emulator&gt;</span></span><br><span class="line"><span class="string">    &lt;disk type=&#x27;file&#x27; device=&#x27;disk&#x27;&gt;</span></span><br><span class="line"><span class="string">      &lt;driver name=&#x27;qemu&#x27; type=&#x27;qcow2&#x27;/&gt;</span></span><br><span class="line"><span class="string">      &lt;source file=&#x27;/var/lib/libvirt/images/Volume.qcow2&#x27;/&gt;</span></span><br><span class="line"><span class="string">      &lt;target dev=&#x27;hda&#x27; bus=&#x27;ide&#x27;/&gt;</span></span><br><span class="line"><span class="string">      &lt;address type=&#x27;drive&#x27; controller=&#x27;0&#x27; bus=&#x27;0&#x27; target=&#x27;0&#x27; unit=&#x27;0&#x27;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/disk&gt;</span></span><br><span class="line"><span class="string">    &lt;disk type=&#x27;file&#x27; device=&#x27;cdrom&#x27;&gt;</span></span><br><span class="line"><span class="string">      &lt;driver name=&#x27;qemu&#x27; type=&#x27;raw&#x27;/&gt;</span></span><br><span class="line"><span class="string">      &lt;source file=&#x27;&#x27;/&gt;</span></span><br><span class="line"><span class="string">      &lt;target dev=&#x27;hdb&#x27; bus=&#x27;ide&#x27;/&gt;</span></span><br><span class="line"><span class="string">      &lt;address type=&#x27;drive&#x27; controller=&#x27;0&#x27; bus=&#x27;0&#x27; target=&#x27;0&#x27; unit=&#x27;1&#x27;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/disk&gt;</span></span><br><span class="line"><span class="string">    &lt;controller type=&#x27;usb&#x27; index=&#x27;0&#x27; model=&#x27;ich9-ehci1&#x27;&gt;</span></span><br><span class="line"><span class="string">      &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x05&#x27; function=&#x27;0x7&#x27;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/controller&gt;</span></span><br><span class="line"><span class="string">    &lt;controller type=&#x27;usb&#x27; index=&#x27;0&#x27; model=&#x27;ich9-uhci1&#x27;&gt;</span></span><br><span class="line"><span class="string">      &lt;master startport=&#x27;0&#x27;/&gt;</span></span><br><span class="line"><span class="string">      &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x05&#x27; function=&#x27;0x0&#x27; multifunction=&#x27;on&#x27;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/controller&gt;</span></span><br><span class="line"><span class="string">    &lt;controller type=&#x27;usb&#x27; index=&#x27;0&#x27; model=&#x27;ich9-uhci2&#x27;&gt;</span></span><br><span class="line"><span class="string">      &lt;master startport=&#x27;2&#x27;/&gt;</span></span><br><span class="line"><span class="string">      &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x05&#x27; function=&#x27;0x1&#x27;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/controller&gt;</span></span><br><span class="line"><span class="string">    &lt;controller type=&#x27;usb&#x27; index=&#x27;0&#x27; model=&#x27;ich9-uhci3&#x27;&gt;</span></span><br><span class="line"><span class="string">      &lt;master startport=&#x27;4&#x27;/&gt;</span></span><br><span class="line"><span class="string">      &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x05&#x27; function=&#x27;0x2&#x27;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/controller&gt;</span></span><br><span class="line"><span class="string">    &lt;controller type=&#x27;pci&#x27; index=&#x27;0&#x27; model=&#x27;pci-root&#x27;/&gt;</span></span><br><span class="line"><span class="string">    &lt;controller type=&#x27;ide&#x27; index=&#x27;0&#x27;&gt;</span></span><br><span class="line"><span class="string">      &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x01&#x27; function=&#x27;0x1&#x27;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/controller&gt;</span></span><br><span class="line"><span class="string">    &lt;controller type=&#x27;virtio-serial&#x27; index=&#x27;0&#x27;&gt;</span></span><br><span class="line"><span class="string">      &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x06&#x27; function=&#x27;0x0&#x27;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/controller&gt;</span></span><br><span class="line"><span class="string">    &lt;serial type=&#x27;pty&#x27;&gt;</span></span><br><span class="line"><span class="string">      &lt;target type=&#x27;isa-serial&#x27; port=&#x27;0&#x27;&gt;</span></span><br><span class="line"><span class="string">        &lt;model name=&#x27;isa-serial&#x27;/&gt;</span></span><br><span class="line"><span class="string">      &lt;/target&gt;</span></span><br><span class="line"><span class="string">    &lt;/serial&gt;</span></span><br><span class="line"><span class="string">    &lt;console type=&#x27;pty&#x27;&gt;</span></span><br><span class="line"><span class="string">      &lt;target type=&#x27;serial&#x27; port=&#x27;0&#x27;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/console&gt;</span></span><br><span class="line"><span class="string">    &lt;channel type=&#x27;spicevmc&#x27;&gt;</span></span><br><span class="line"><span class="string">      &lt;target type=&#x27;virtio&#x27; name=&#x27;com.redhat.spice.0&#x27;/&gt;</span></span><br><span class="line"><span class="string">      &lt;address type=&#x27;virtio-serial&#x27; controller=&#x27;0&#x27; bus=&#x27;0&#x27; port=&#x27;1&#x27;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/channel&gt;</span></span><br><span class="line"><span class="string">    &lt;input type=&#x27;mouse&#x27; bus=&#x27;ps2&#x27;/&gt;</span></span><br><span class="line"><span class="string">    &lt;input type=&#x27;keyboard&#x27; bus=&#x27;ps2&#x27;/&gt;</span></span><br><span class="line"><span class="string">    &lt;graphics type=&#x27;spice&#x27; autoport=&#x27;yes&#x27;&gt;</span></span><br><span class="line"><span class="string">      &lt;listen type=&#x27;address&#x27;/&gt;</span></span><br><span class="line"><span class="string">      &lt;image compression=&#x27;off&#x27;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/graphics&gt;</span></span><br><span class="line"><span class="string">    &lt;sound model=&#x27;ich6&#x27;&gt;</span></span><br><span class="line"><span class="string">      &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x04&#x27; function=&#x27;0x0&#x27;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/sound&gt;</span></span><br><span class="line"><span class="string">    &lt;video&gt;</span></span><br><span class="line"><span class="string">      &lt;model type=&#x27;qxl&#x27; ram=&#x27;65536&#x27; vram=&#x27;65536&#x27; vgamem=&#x27;16384&#x27; heads=&#x27;1&#x27; primary=&#x27;yes&#x27;/&gt;</span></span><br><span class="line"><span class="string">      &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x02&#x27; function=&#x27;0x0&#x27;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/video&gt;</span></span><br><span class="line"><span class="string">    &lt;redirdev bus=&#x27;usb&#x27; type=&#x27;spicevmc&#x27;&gt;</span></span><br><span class="line"><span class="string">      &lt;address type=&#x27;usb&#x27; bus=&#x27;0&#x27; port=&#x27;1&#x27;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/redirdev&gt;</span></span><br><span class="line"><span class="string">    &lt;redirdev bus=&#x27;usb&#x27; type=&#x27;spicevmc&#x27;&gt;</span></span><br><span class="line"><span class="string">      &lt;address type=&#x27;usb&#x27; bus=&#x27;0&#x27; port=&#x27;2&#x27;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/redirdev&gt;</span></span><br><span class="line"><span class="string">    &lt;mballoon model=&#x27;virtio&#x27;&gt;</span></span><br><span class="line"><span class="string">      &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x07&#x27; function=&#x27;0x0&#x27;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/mballoon&gt;</span></span><br><span class="line"><span class="string">  &lt;/devices&gt;</span></span><br><span class="line"><span class="string">&lt;/domain&gt;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">dom = conn.defineXML(domainXML)</span><br></pre></td></tr></table></figure><h3 id="示例-12-4：将新磁盘附加到域"><a href="#示例-12-4：将新磁盘附加到域" class="headerlink" title="示例 12.4：将新磁盘附加到域"></a>示例 12.4：将新磁盘附加到域</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所需 &quot;.iso&quot; 文件的路径</span></span><br><span class="line">diskFile = <span class="string">&quot;/tmp/debian.iso&quot;</span></span><br><span class="line"></span><br><span class="line">diskXML = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;disk type=&#x27;file&#x27; device=&#x27;cdrom&#x27;&gt;</span></span><br><span class="line"><span class="string">  &lt;driver name=&#x27;qemu&#x27; type=&#x27;raw&#x27;/&gt;</span></span><br><span class="line"><span class="string">  &lt;source file=&#x27;&quot;&quot;&quot;</span> + diskFile + <span class="string">&quot;&quot;&quot;&#x27;/&gt;</span></span><br><span class="line"><span class="string">  &lt;target dev=&#x27;hdb&#x27; bus=&#x27;ide&#x27;/&gt;</span></span><br><span class="line"><span class="string">  &lt;address type=&#x27;drive&#x27; controller=&#x27;0&#x27; bus=&#x27;0&#x27; target=&#x27;0&#x27; unit=&#x27;1&#x27;/&gt;</span></span><br><span class="line"><span class="string">&lt;/disk&gt;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">dom.updateDeviceFlags(diskXML, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="示例-12-5：启动域"><a href="#示例-12-5：启动域" class="headerlink" title="示例 12.5：启动域"></a>示例 12.5：启动域</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dom.create()</span><br></pre></td></tr></table></figure><p>我们可以使用 <code>virt-viewer</code> 与我们的域进行交互。只需在终端运行它，我们就能获得可连接的虚拟机列表，从而启动图形会话。</p><h3 id="示例-12-6：拍摄快照"><a href="#示例-12-6：拍摄快照" class="headerlink" title="示例 12.6：拍摄快照"></a>示例 12.6：拍摄快照</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">snapXML = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;domainsnapshot&gt;</span></span><br><span class="line"><span class="string">  &lt;name&gt;第一快照&lt;/name&gt;</span></span><br><span class="line"><span class="string">  &lt;description&gt;刚刚创建的虚拟机&lt;/description&gt;</span></span><br><span class="line"><span class="string">&lt;/domainsnapshot&gt;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">dom.snapshotCreateXML(snapXML, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="示例-12-7：恢复到快照"><a href="#示例-12-7：恢复到快照" class="headerlink" title="示例 12.7：恢复到快照"></a>示例 12.7：恢复到快照</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有快照</span></span><br><span class="line">snapshotList = dom.listAllSnapshots()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用我们想要的名称查找快照</span></span><br><span class="line">revertTo = <span class="literal">None</span></span><br><span class="line"><span class="keyword">for</span> snap <span class="keyword">in</span> snapshotList:</span><br><span class="line">    <span class="keyword">if</span> snap.getName() == <span class="string">&#x27;FirstSnapshot&#x27;</span>:</span><br><span class="line">        revertTo = snap</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> revertTo <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    dom.revertToSnapshot(revertTo)</span><br></pre></td></tr></table></figure><h2 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h2><p>要执行涉及从虚拟化驱动程序上运行的软件发送和接收数据的操作，我们需要使用流。</p><h3 id="示例-12-8：查找域"><a href="#示例-12-8：查找域" class="headerlink" title="示例 12.8：查找域"></a>示例 12.8：查找域</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">domain = conn.lookupByName(<span class="string">&#x27;TestDomain&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="示例-12-9：使用数据流截屏"><a href="#示例-12-9：使用数据流截屏" class="headerlink" title="示例 12.9：使用数据流截屏"></a>示例 12.9：使用数据流截屏</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stream = conn.newStream()</span><br><span class="line">imageType = domain.screenshot(stream, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="示例-12-10：从数据流中读取数据"><a href="#示例-12-10：从数据流中读取数据" class="headerlink" title="示例 12.10：从数据流中读取数据"></a>示例 12.10：从数据流中读取数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="string">&quot;Screenshot of &quot;</span> + dom.name()</span><br><span class="line">fileHandler = <span class="built_in">open</span>(file, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">streamBytes = stream.recv(<span class="number">262120</span>)</span><br><span class="line"><span class="keyword">while</span> streamBytes != <span class="string">b&#x27;&#x27;</span>:</span><br><span class="line">    fileHandler.write(streamBytes)</span><br><span class="line">    streamBytes = stream.recv(<span class="number">262120</span>)</span><br><span class="line"></span><br><span class="line">fileHandler.close()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Screenshot saved as type: &#x27;</span> + imageType)</span><br></pre></td></tr></table></figure><h3 id="示例-12-11：截屏"><a href="#示例-12-11：截屏" class="headerlink" title="示例 12.11：截屏"></a>示例 12.11：截屏</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-11.py</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">domName = <span class="string">&#x27;TestAppliance&#x27;</span></span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dom = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    dom = conn.lookupByName(domName)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">stream = conn.newStream()</span><br><span class="line">imageType = domain.screenshot(stream, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">file = <span class="string">&quot;Screenshot of &quot;</span> + dom.name()</span><br><span class="line">fileHandler = <span class="built_in">open</span>(file, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">streamBytes = stream.recv(<span class="number">262120</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> streamBytes != <span class="string">b&#x27;&#x27;</span>:</span><br><span class="line">    fileHandler.write(streamBytes)</span><br><span class="line">    streamBytes = stream.recv(<span class="number">262120</span>)</span><br><span class="line"></span><br><span class="line">fileHandler.close()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Screenshot saved as type: &#x27;</span> + imageType)</span><br><span class="line">stream.finish()</span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用示例&quot;&gt;&lt;a href=&quot;#使用示例&quot; class=&quot;headerlink&quot; title=&quot;使用示例&quot;&gt;&lt;/a&gt;使用示例&lt;/h1&gt;&lt;p&gt;本节将介绍该库的基础知识，旨在提供一个快速教程，让开发人员尽快掌握并运行该库。&lt;/p&gt;
&lt;h2 id=&quot;零到虚拟设备&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="云计算" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="libvirt" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/libvirt/"/>
    
    
    <category term="云计算" scheme="https://watsonlu6.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="libvirt" scheme="https://watsonlu6.github.io/tags/libvirt/"/>
    
  </entry>
  
  <entry>
    <title>11 libvirt调试与日志</title>
    <link href="https://watsonlu6.github.io/libvirt%E6%96%87%E6%A1%A3/11-libvirt%E8%B0%83%E8%AF%95%E4%B8%8E%E6%97%A5%E5%BF%97/"/>
    <id>https://watsonlu6.github.io/libvirt%E6%96%87%E6%A1%A3/11-libvirt%E8%B0%83%E8%AF%95%E4%B8%8E%E6%97%A5%E5%BF%97/</id>
    <published>2024-03-11T07:50:26.000Z</published>
    <updated>2025-03-15T08:00:49.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="调试与日志"><a href="#调试与日志" class="headerlink" title="调试与日志"></a>调试与日志</h1><p>Libvirt 包含日志设施，以便于跟踪库的执行情况。在试图获得 libvirt 支持时，这些日志会经常被要求记录，因此熟悉这些日志至关重要。</p><p>libvirt 中的日志记录设施基于 3 个关键概念：</p><ol><li><p><strong>日志消息</strong> - 由 libvirt 代码在运行时生成，包括时间戳、优先级（DEBUG &#x3D; 1、INFO &#x3D; 2、WARNING &#x3D; 3、ERROR &#x3D; 4）、类别、函数名称和行号（表明消息的来源）以及格式化的消息。</p></li><li><p><strong>日志过滤器</strong> - 控制是否显示特定信息的模式和优先级。过滤器的格式为 <code>x:名称</code>，其中 <code>x</code> 是匹配应适用的最小优先级，<code>name</code> 是要匹配的字符串。优先级为：</p><ul><li>1（或调试）- 记录所有信息</li><li>2（或 info）- 记录所有非调试信息</li><li>3（或警告） - 只记录警告和错误 - 这是默认设置</li><li>4（或错误）- 只记录错误</li></ul><p>例如，要将所有调试信息记录到 qemu 驱动程序，可使用以下过滤器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1:qemu</span><br></pre></td></tr></table></figure><p>下例记录了来自 qemu 的所有调试信息，并记录了来自远程驱动程序的所有错误信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1:qemu 4:remote</span><br></pre></td></tr></table></figure></li><li><p><strong>日志输出</strong> - 信息通过过滤器后发送到哪里。日志输出的格式有以下几种：</p><ul><li><code>x:stderr</code> - 记录到 stderr</li><li><code>x:syslog:name</code> - 将日志记录到以 <code>name</code> 为前缀的 syslog 中</li><li><code>x:file:file_path</code> - 将日志记录到以 <code>file_path</code> 指定的文件中</li></ul><p>其中 <code>x</code> 是最小优先级。例如，要将所有警告和错误记录到以 <code>libvirtd</code> 为前缀的 syslog 中，可使用以下输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3:syslog:libvirtd</span><br></pre></td></tr></table></figure><p>以下示例将所有错误和警告信息记录到系统日志，并将所有调试、信息、警告和错误信息记录到 <code>/tmp/libvirt.log</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3:syslog:libvirtd 1:file:/tmp/libvirt.log</span><br></pre></td></tr></table></figure></li></ol><h2 id="11-1-环境变量"><a href="#11-1-环境变量" class="headerlink" title="11.1 环境变量"></a>11.1 环境变量</h2><p>通过使用环境变量，libvirt 库可以指定所需的日志优先级、过滤器和输出：</p><ol><li><p><strong>LIBVIRT_DEBUG</strong> 指定了日志信息的最低优先级。这可以看作是一个 “全局” 优先级；如果某条日志信息与 <strong>LIBVIRT_LOG_FILTERS</strong> 中的特定过滤器不匹配，就会与这个全局优先级进行比较，并根据情况记录下来。</p></li><li><p><strong>LIBVIRT_LOG_FILTERS</strong> 指定要应用的过滤器。</p></li><li><p><strong>LIBVIRT_LOG_OUTPUTS</strong> 指定了要发送信息的输出端。</p></li></ol><h3 id="示例-11-1：使用环境变量运行-virsh"><a href="#示例-11-1：使用环境变量运行-virsh" class="headerlink" title="示例 11.1：使用环境变量运行 virsh"></a>示例 11.1：使用环境变量运行 virsh</h3><p>要查看有关 virsh 运行情况的更详细信息，我们可以像下面这样运行它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIBVIRT_DEBUG=error LIBVIRT_LOG_FILTERS=<span class="string">&quot;1:remote&quot;</span> virsh list</span><br></pre></td></tr></table></figure><p>此示例将只打印来自 virsh 的错误信息，<em>但</em>远程驱动程序将打印所有调试、信息、警告和错误信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;调试与日志&quot;&gt;&lt;a href=&quot;#调试与日志&quot; class=&quot;headerlink&quot; title=&quot;调试与日志&quot;&gt;&lt;/a&gt;调试与日志&lt;/h1&gt;&lt;p&gt;Libvirt 包含日志设施，以便于跟踪库的执行情况。在试图获得 libvirt 支持时，这些日志会经常被要求记录，</summary>
      
    
    
    
    <category term="云计算" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="libvirt" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/libvirt/"/>
    
    
    <category term="云计算" scheme="https://watsonlu6.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="libvirt" scheme="https://watsonlu6.github.io/tags/libvirt/"/>
    
  </entry>
  
  <entry>
    <title>10 libvirt安全模式</title>
    <link href="https://watsonlu6.github.io/libvirt%E6%96%87%E6%A1%A3/10-libvirt%E5%AE%89%E5%85%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://watsonlu6.github.io/libvirt%E6%96%87%E6%A1%A3/10-libvirt%E5%AE%89%E5%85%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-03-10T07:50:26.000Z</published>
    <updated>2025-03-15T08:00:47.056Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h1><p>虽然 Python 模块提供了对安全和秘密方法的完全访问权限，但这一主题目前超出了本指南的范围。您可以运行以下命令来查找安全和秘密方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pydoc libvirt</span><br></pre></td></tr></table></figure><p>这将为您提供针对您的 Linux 发行版的 Python 类、方法和函数的 manpage。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;安全模式&quot;&gt;&lt;a href=&quot;#安全模式&quot; class=&quot;headerlink&quot; title=&quot;安全模式&quot;&gt;&lt;/a&gt;安全模式&lt;/h1&gt;&lt;p&gt;虽然 Python 模块提供了对安全和秘密方法的完全访问权限，但这一主题目前超出了本指南的范围。您可以运行以下命令来查找安全</summary>
      
    
    
    
    <category term="云计算" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="libvirt" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/libvirt/"/>
    
    
    <category term="云计算" scheme="https://watsonlu6.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="libvirt" scheme="https://watsonlu6.github.io/tags/libvirt/"/>
    
  </entry>
  
  <entry>
    <title>9 libvirt事件和计时器处理</title>
    <link href="https://watsonlu6.github.io/libvirt%E6%96%87%E6%A1%A3/9-libvirt%E4%BA%8B%E4%BB%B6%E5%92%8C%E8%AE%A1%E6%97%B6%E5%99%A8%E5%A4%84%E7%90%86/"/>
    <id>https://watsonlu6.github.io/libvirt%E6%96%87%E6%A1%A3/9-libvirt%E4%BA%8B%E4%BB%B6%E5%92%8C%E8%AE%A1%E6%97%B6%E5%99%A8%E5%A4%84%E7%90%86/</id>
    <published>2024-03-09T07:50:26.000Z</published>
    <updated>2025-03-15T08:00:44.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事件和计时器处理"><a href="#事件和计时器处理" class="headerlink" title="事件和计时器处理"></a>事件和计时器处理</h1><p>Python libvirt 模块提供了处理事件和计时器的完整接口。事件和定时器处理都是通过函数接口而非类&#x2F;方法接口调用的。这使得将接口集成到图形程序或控制台程序中更加容易。</p><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>Python libvirt 模块提供了一个事件处理框架。虽然它对图形程序最有用，但也可用于控制台程序，以提供一致的用户界面并控制控制台事件的处理。</p><p>事件处理通过以下函数完成：</p><ul><li><strong>virEventAddHandle</strong></li><li><strong>virEventRegisterDefaultImpl</strong></li><li><strong>virEventRegisterImpl</strong></li><li><strong>virEventRemoveHandle</strong></li><li><strong>virEventRunDefaultImpl</strong></li><li><strong>virEventUpdateHandle</strong></li></ul><p>创建事件时，需要事先在 <strong>virEventRegisterImpl</strong> 或 <strong>virEventRegisterDefaultImpl</strong> 中注册。</p><p>下面是一个使用了大部分这些功能的示例程序。请注意，要通过终端与客户机交互，需要在客户机系统中启用串行控制台。对于 Linux 主机，可以这样做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> serial-getty@ttyS0.service</span><br><span class="line"><span class="built_in">sudo</span> systemctl start serial-getty@ttyS0.service</span><br></pre></td></tr></table></figure><h3 id="示例-9-1：提供可在客户机重启后继续使用的持久控制台"><a href="#示例-9-1：提供可在客户机重启后继续使用的持久控制台" class="headerlink" title="示例 9.1：提供可在客户机重启后继续使用的持久控制台"></a>示例 9.1：提供可在客户机重启后继续使用的持久控制台</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例-1.py</span></span><br><span class="line"><span class="comment"># consolecallback - 提供一个持久的控制台，在客户机重启后仍可使用</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys, os, logging, libvirt, tty, termios, atexit</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reset_term</span>():</span><br><span class="line">    termios.tcsetattr(<span class="number">0</span>, termios.TCSADRAIN, attrs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">error_handler</span>(<span class="params">unused, error</span>):</span><br><span class="line">    <span class="comment"># 控制台流会在虚拟机关闭时出错</span></span><br><span class="line">    <span class="keyword">if</span> (error[<span class="number">0</span>] == libvirt.VIR_ERR_RPC <span class="keyword">and</span> error[<span class="number">1</span>] == libvirt.VIR_FROM_STREAMS):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    logging.warn(error)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Console</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, uri, uuid</span>):</span><br><span class="line">        <span class="variable language_">self</span>.uri = uri</span><br><span class="line">        <span class="variable language_">self</span>.uuid = uuid</span><br><span class="line">        <span class="variable language_">self</span>.connection = libvirt.<span class="built_in">open</span>(uri)</span><br><span class="line">        <span class="variable language_">self</span>.domain = <span class="variable language_">self</span>.connection.lookupByUUIDString(uuid)</span><br><span class="line">        <span class="variable language_">self</span>.state = <span class="variable language_">self</span>.domain.state(<span class="number">0</span>)</span><br><span class="line">        <span class="variable language_">self</span>.connection.domainEventRegister(lifecycle_callback, <span class="variable language_">self</span>)</span><br><span class="line">        <span class="variable language_">self</span>.stream = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.run_console = <span class="literal">True</span></span><br><span class="line">        logging.info(<span class="string">&quot;%s 初始状态 %d，原因 %d&quot;</span>, <span class="variable language_">self</span>.uuid, <span class="variable language_">self</span>.state[<span class="number">0</span>], <span class="variable language_">self</span>.state[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_console</span>(<span class="params">console</span>):</span><br><span class="line">    <span class="keyword">if</span> (console.state[<span class="number">0</span>] == libvirt.VIR_DOMAIN_RUNNING <span class="keyword">or</span> console.state[<span class="number">0</span>] == libvirt.VIR_DOMAIN_PAUSED):</span><br><span class="line">        <span class="keyword">if</span> console.stream <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            console.stream = console.connection.newStream(libvirt.VIR_STREAM_NONBLOCK)</span><br><span class="line">            console.domain.openConsole(<span class="literal">None</span>, console.stream, <span class="number">0</span>)</span><br><span class="line">            console.stream.eventAddCallback(libvirt.VIR_STREAM_EVENT_READABLE, stream_callback, console)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> console.stream:</span><br><span class="line">            console.stream.eventRemoveCallback()</span><br><span class="line">            console.stream = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> console.run_console</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stdin_callback</span>(<span class="params">watch, fd, events, console</span>):</span><br><span class="line">    readbuf = os.read(fd, <span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">if</span> readbuf.startswith(<span class="string">&quot;&quot;</span>):</span><br><span class="line">        console.run_console = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> console.stream:</span><br><span class="line">        console.stream.send(readbuf)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stream_callback</span>(<span class="params">stream, events, console</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        received_data = console.stream.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    os.write(<span class="number">0</span>, received_data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lifecycle_callback</span>(<span class="params">connection, domain, event, detail, console</span>):</span><br><span class="line">    console.state = console.domain.state(<span class="number">0</span>)</span><br><span class="line">    logging.info(<span class="string">&quot;%s 过渡到状态 %d，原因 %d&quot;</span>, console.uuid, console.state[<span class="number">0</span>], console.state[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># main</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">3</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Usage:&quot;</span>, sys.argv[<span class="number">0</span>], <span class="string">&quot;URI UUID&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;for example:&quot;</span>, sys.argv[<span class="number">0</span>], <span class="string">&quot;&#x27;qemu:///system&#x27; &#x27;32ad945f-7e78-c33a-e96d-39f25e025d81&#x27;&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">uri = sys.argv[<span class="number">1</span>]</span><br><span class="line">uuid = sys.argv[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Escape character is ^]&quot;</span>)</span><br><span class="line">logging.basicConfig(filename=<span class="string">&#x27;msg.log&#x27;</span>, level=logging.DEBUG)</span><br><span class="line">logging.info(<span class="string">&quot;URI: %s&quot;</span>, uri)</span><br><span class="line">logging.info(<span class="string">&quot;UUID: %s&quot;</span>, uuid)</span><br><span class="line"></span><br><span class="line">libvirt.virEventRegisterDefaultImpl()</span><br><span class="line">libvirt.registerErrorHandler(error_handler, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">atexit.register(reset_term)</span><br><span class="line">attrs = termios.tcgetattr(<span class="number">0</span>)</span><br><span class="line">tty.setraw(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">console = Console(uri, uuid)</span><br><span class="line">console.stdin_watch = libvirt.virEventAddHandle(<span class="number">0</span>, libvirt.VIR_EVENT_HANDLE_READABLE, stdin_callback, console)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> check_console(console):</span><br><span class="line">    libvirt.virEventRunDefaultImpl()</span><br></pre></td></tr></table></figure><h2 id="计时器处理"><a href="#计时器处理" class="headerlink" title="计时器处理"></a>计时器处理</h2><p>Python libvirt 模块为定时器处理提供了一个框架。创建定时器需要事先用 <strong>virEventRegisterImpl</strong> 或 <strong>virEventRegisterDefaultImpl</strong> 注册一个事件循环。</p><p>定时器处理通过以下函数完成：</p><ul><li><strong>virEventAddTimeout</strong></li><li><strong>virEventUpdateTimeout</strong></li><li><strong>virEventRemoveTimeout</strong></li></ul><p>实施过程将支持多个计时器。</p><p>要创建新的计时器，请在 <strong>virEventRegisterImpl</strong> 或 <strong>virEventRegisterDefaultImpl</strong> 函数已被调用。</p><p>可以使用 <strong>virEventRemoveTimeout</strong> 移除计时器，或使用 <strong>virEventUpdateTimeout</strong> 函数更新计时器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;事件和计时器处理&quot;&gt;&lt;a href=&quot;#事件和计时器处理&quot; class=&quot;headerlink&quot; title=&quot;事件和计时器处理&quot;&gt;&lt;/a&gt;事件和计时器处理&lt;/h1&gt;&lt;p&gt;Python libvirt 模块提供了处理事件和计时器的完整接口。事件和定时器处理都是通过</summary>
      
    
    
    
    <category term="云计算" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="libvirt" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/libvirt/"/>
    
    
    <category term="云计算" scheme="https://watsonlu6.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="libvirt" scheme="https://watsonlu6.github.io/tags/libvirt/"/>
    
  </entry>
  
  <entry>
    <title>8 libvirt错误处理</title>
    <link href="https://watsonlu6.github.io/libvirt%E6%96%87%E6%A1%A3/8-libvirt%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    <id>https://watsonlu6.github.io/libvirt%E6%96%87%E6%A1%A3/8-libvirt%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</id>
    <published>2024-03-08T07:50:26.000Z</published>
    <updated>2025-03-15T08:00:39.705Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Libvirt-错误处理"><a href="#Libvirt-错误处理" class="headerlink" title="Libvirt 错误处理"></a>Libvirt 错误处理</h1><p>libvirt 错误函数的设计目的是在普通 libvirt 函数或方法返回错误的情况下，提供更详细的失败原因信息。Python libvirt 错误报告中需要注意的一点是，错误是按线程而不是按连接存储的。</p><h2 id="libvirtError-类"><a href="#libvirtError-类" class="headerlink" title="libvirtError 类"></a>libvirtError 类</h2><p>libvirt Python 模块定义了一个标准异常类 <strong>libvirtError</strong>，可以对其进行子类化，以便在引发 libvirt 异常时添加其他功能。<strong>libvirtError</strong> 类的部分定义如下：</p><h3 id="示例-8-1：Libvirt-模块-libvirtError-类定义"><a href="#示例-8-1：Libvirt-模块-libvirtError-类定义" class="headerlink" title="示例 8.1：Libvirt 模块 libvirtError 类定义"></a>示例 8.1：Libvirt 模块 libvirtError 类定义</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">libvirtError</span>(exceptions.Exception):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, defmsg, conn=<span class="literal">None</span>, dom=<span class="literal">None</span>, net=<span class="literal">None</span>, pool=<span class="literal">None</span>, vol=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="comment"># 切勿调用 virGetLastError()。</span></span><br><span class="line">        <span class="comment"># virGetLastError() 现在是线程本地</span></span><br><span class="line">        err = virGetLastError()</span><br><span class="line">        <span class="keyword">if</span> err <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            msg = defmsg</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msg = err[<span class="number">2</span>]</span><br><span class="line">        Exception.__init__(<span class="variable language_">self</span>, msg)</span><br><span class="line">        <span class="variable language_">self</span>.err = err</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_error_code</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.err <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.err[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_error_domain</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.err <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.err[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_error_message</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.err <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.err[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_error_level</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.err <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.err[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_str1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.err <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.err[<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_str2</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.err <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.err[<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_str3</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.err <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.err[<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_int1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.err <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.err[<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_int2</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.err <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.err[<span class="number">8</span>]</span><br></pre></td></tr></table></figure><h3 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h3><p>方法 <strong>get_error_code</strong> 返回从错误中返回的错误代码。这是 Python libvirt 模块的数据定义之一。此列表中某些编号较高的条目可能在您的 Python libvirt 模块中不可用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">VIR_ERR_OK = <span class="number">0</span></span><br><span class="line">VIR_ERR_INTERNAL_ERROR = <span class="number">1</span>  <span class="comment"># 内部错误</span></span><br><span class="line">VIR_ERR_NO_MEMORY = <span class="number">2</span>  <span class="comment"># 内存分配失败</span></span><br><span class="line">VIR_ERR_NO_SUPPORT = <span class="number">3</span>  <span class="comment"># 不支持此函数</span></span><br><span class="line">VIR_ERR_UNKNOWN_HOST = <span class="number">4</span>  <span class="comment"># 无法解析主机名</span></span><br><span class="line">VIR_ERR_NO_CONNECT = <span class="number">5</span>  <span class="comment"># 无法连接到管理程序</span></span><br><span class="line">VIR_ERR_INVALID_CONN = <span class="number">6</span>  <span class="comment"># 连接对象无效</span></span><br><span class="line">VIR_ERR_INVALID_DOMAIN = <span class="number">7</span>  <span class="comment"># 域对象无效</span></span><br><span class="line">VIR_ERR_INVALID_ARG = <span class="number">8</span>  <span class="comment"># 函数参数无效</span></span><br><span class="line">VIR_ERR_OPERATION_FAILED = <span class="number">9</span>  <span class="comment"># 向管理程序发出的命令失败</span></span><br><span class="line">VIR_ERR_GET_FAILED = <span class="number">10</span>  <span class="comment"># HTTP GET 命令失败</span></span><br><span class="line">VIR_ERR_POST_FAILED = <span class="number">11</span>  <span class="comment"># HTTP POST 命令失败</span></span><br><span class="line">VIR_ERR_HTTP_ERROR = <span class="number">12</span>  <span class="comment"># 意外的 HTTP 错误代码</span></span><br><span class="line">VIR_ERR_SEXPR_SERIAL = <span class="number">13</span>  <span class="comment"># 序列化 S-Expr 失败</span></span><br><span class="line">VIR_ERR_NO_XEN = <span class="number">14</span>  <span class="comment"># 无法打开 Xen 虚拟机管理程序控件</span></span><br><span class="line">VIR_ERR_XEN_CALL = <span class="number">15</span>  <span class="comment"># 管理程序调用失败</span></span><br><span class="line">VIR_ERR_OS_TYPE = <span class="number">16</span>  <span class="comment"># 未知操作系统类型</span></span><br><span class="line">VIR_ERR_NO_KERNEL = <span class="number">17</span>  <span class="comment"># 缺少内核信息</span></span><br><span class="line">VIR_ERR_NO_ROOT = <span class="number">18</span>  <span class="comment"># 缺少根设备信息</span></span><br><span class="line">VIR_ERR_NO_SOURCE = <span class="number">19</span>  <span class="comment"># 缺少源设备信息</span></span><br><span class="line">VIR_ERR_NO_TARGET = <span class="number">20</span>  <span class="comment"># 缺少目标设备信息</span></span><br><span class="line">VIR_ERR_NO_NAME = <span class="number">21</span>  <span class="comment"># 缺少域名信息</span></span><br><span class="line">VIR_ERR_NO_OS = <span class="number">22</span>  <span class="comment"># 缺少域操作系统信息</span></span><br><span class="line">VIR_ERR_NO_DEVICE = <span class="number">23</span>  <span class="comment"># 缺少域设备信息</span></span><br><span class="line">VIR_ERR_NO_XENSTORE = <span class="number">24</span>  <span class="comment"># 无法打开 Xen 存储控制</span></span><br><span class="line">VIR_ERR_DRIVER_FULL = <span class="number">25</span>  <span class="comment"># 注册的驱动程序过多</span></span><br><span class="line">VIR_ERR_CALL_FAILED = <span class="number">26</span>  <span class="comment"># 驱动程序不支持（已删除）</span></span><br><span class="line">VIR_ERR_XML_ERROR = <span class="number">27</span>  <span class="comment"># XML 描述不完整或已损坏</span></span><br><span class="line">VIR_ERR_DOM_EXIST = <span class="number">28</span>  <span class="comment"># 域已经存在</span></span><br><span class="line">VIR_ERR_OPERATION_DENIED = <span class="number">29</span>  <span class="comment"># 只读连接上禁止操作</span></span><br><span class="line">VIR_ERR_OPEN_FAILED = <span class="number">30</span>  <span class="comment"># 打开配置文件失败</span></span><br><span class="line">VIR_ERR_READ_FAILED = <span class="number">31</span>  <span class="comment"># 读取配置文件失败</span></span><br><span class="line">VIR_ERR_PARSE_FAILED = <span class="number">32</span>  <span class="comment"># 解析配置文件失败</span></span><br><span class="line">VIR_ERR_CONF_SYNTAX = <span class="number">33</span>  <span class="comment"># 解析配置文件语法失败</span></span><br><span class="line">VIR_ERR_WRITE_FAILED = <span class="number">34</span>  <span class="comment"># 写入配置文件失败</span></span><br><span class="line">VIR_ERR_XML_DETAIL = <span class="number">35</span>  <span class="comment"># XML 错误细节</span></span><br><span class="line">VIR_ERR_INVALID_NETWORK = <span class="number">36</span>  <span class="comment"># 无效的网络对象</span></span><br><span class="line">VIR_ERR_NETWORK_EXIST = <span class="number">37</span>  <span class="comment"># 网络已经存在</span></span><br><span class="line">VIR_ERR_SYSTEM_ERROR = <span class="number">38</span>  <span class="comment"># 一般系统调用故障</span></span><br><span class="line">VIR_ERR_RPC = <span class="number">39</span>  <span class="comment"># 某种 RPC 错误</span></span><br><span class="line">VIR_ERR_GNUTLS_ERROR = <span class="number">40</span>  <span class="comment"># 因调用 GNUTLS 而出错</span></span><br><span class="line">VIR_WAR_NO_NETWORK = <span class="number">41</span>  <span class="comment"># 启动网络失败</span></span><br><span class="line">VIR_ERR_NO_DOMAIN = <span class="number">42</span>  <span class="comment"># 域未找到或意外消失</span></span><br><span class="line">VIR_ERR_NO_NETWORK = <span class="number">43</span>  <span class="comment"># 网络未找到</span></span><br><span class="line">VIR_ERR_INVALID_MAC = <span class="number">44</span>  <span class="comment"># 无效的 MAC 地址</span></span><br><span class="line">VIR_ERR_AUTH_FAILED = <span class="number">45</span>  <span class="comment"># 认证失败</span></span><br><span class="line">VIR_ERR_INVALID_STORAGE_POOL = <span class="number">46</span>  <span class="comment"># 无效的存储池对象</span></span><br><span class="line">VIR_ERR_INVALID_STORAGE_VOL = <span class="number">47</span>  <span class="comment"># 无效的存储卷对象</span></span><br><span class="line">VIR_WAR_NO_STORAGE = <span class="number">48</span>  <span class="comment"># 启动存储失败</span></span><br><span class="line">VIR_ERR_NO_STORAGE_POOL = <span class="number">49</span>  <span class="comment"># 存储池未找到</span></span><br><span class="line">VIR_ERR_NO_STORAGE_VOL = <span class="number">50</span>  <span class="comment"># 未找到存储卷</span></span><br><span class="line">VIR_WAR_NO_NODE = <span class="number">51</span>  <span class="comment"># 启动节点驱动失败</span></span><br><span class="line">VIR_ERR_INVALID_NODE_DEVICE = <span class="number">52</span>  <span class="comment"># 无效的节点设备对象</span></span><br><span class="line">VIR_ERR_NO_NODE_DEVICE = <span class="number">53</span>  <span class="comment"># 未找到节点设备</span></span><br><span class="line">VIR_ERR_NO_SECURITY_MODEL = <span class="number">54</span>  <span class="comment"># 未找到安全模型</span></span><br><span class="line">VIR_ERR_OPERATION_INVALID = <span class="number">55</span>  <span class="comment"># 操作此时不适用</span></span><br><span class="line">VIR_WAR_NO_INTERFACE = <span class="number">56</span>  <span class="comment"># 未能启动接口驱动程序</span></span><br><span class="line">VIR_ERR_NO_INTERFACE = <span class="number">57</span>  <span class="comment"># 接口驱动程序未运行</span></span><br><span class="line">VIR_ERR_INVALID_INTERFACE = <span class="number">58</span>  <span class="comment"># 接口对象无效</span></span><br><span class="line">VIR_ERR_MULTIPLE_INTERFACES = <span class="number">59</span>  <span class="comment"># 发现一个以上匹配的接口</span></span><br><span class="line">VIR_WAR_NO_NWFILTER = <span class="number">60</span>  <span class="comment"># 启动 nwfilter 驱动失败</span></span><br><span class="line">VIR_ERR_INVALID_NWFILTER = <span class="number">61</span>  <span class="comment"># 无效的 nwfilter 对象</span></span><br><span class="line">VIR_ERR_NO_NWFILTER = <span class="number">62</span>  <span class="comment"># 未找到 nw 过滤器池</span></span><br><span class="line">VIR_ERR_BUILD_FIREWALL = <span class="number">63</span>  <span class="comment"># 未找到 nw 过滤器池</span></span><br><span class="line">VIR_WAR_NO_SECRET = <span class="number">64</span>  <span class="comment"># 启动秘密存储失败</span></span><br><span class="line">VIR_ERR_INVALID_SECRET = <span class="number">65</span>  <span class="comment"># 无效密文</span></span><br><span class="line">VIR_ERR_NO_SECRET = <span class="number">66</span>  <span class="comment"># 未找到密文</span></span><br><span class="line">VIR_ERR_CONFIG_UNSUPPORTED = <span class="number">67</span>  <span class="comment"># 不支持配置结构</span></span><br><span class="line">VIR_ERR_OPERATION_TIMEOUT = <span class="number">68</span>  <span class="comment"># 运行期间发生超时</span></span><br><span class="line">VIR_ERR_MIGRATE_PERSIST_FAILED = <span class="number">69</span>  <span class="comment"># 迁移成功，但让虚拟机在目标主机上持续运行失败</span></span><br><span class="line">VIR_ERR_HOOK_SCRIPT_FAILED = <span class="number">70</span>  <span class="comment"># 同步钩子脚本失败</span></span><br><span class="line">VIR_ERR_INVALID_DOMAIN_SNAPSHOT = <span class="number">71</span>  <span class="comment"># 无效的域快照</span></span><br><span class="line">VIR_ERR_NO_DOMAIN_SNAPSHOT = <span class="number">72</span>  <span class="comment"># 未找到域快照</span></span><br><span class="line">VIR_ERR_INVALID_STREAM = <span class="number">73</span>  <span class="comment"># 无效的 i/o 流</span></span><br><span class="line">VIR_ERR_ARGUMENT_UNSUPPORTED = <span class="number">74</span>  <span class="comment"># 参数不支持</span></span><br><span class="line">VIR_ERR_STORAGE_PROBE_FAILED = <span class="number">75</span>  <span class="comment"># 存储探测失败</span></span><br><span class="line">VIR_ERR_STORAGE_POOL_BUILT = <span class="number">76</span></span><br><span class="line">VIR_ERR_SNAPSHOT_REVERT_RISKY = <span class="number">77</span></span><br><span class="line">VIR_ERR_OPERATION_ABORTED = <span class="number">78</span>  <span class="comment"># 操作被中止</span></span><br><span class="line">VIR_ERR_AUTH_CANCELLED = <span class="number">79</span></span><br><span class="line">VIR_ERR_NO_DOMAIN_METADATA = <span class="number">80</span>  <span class="comment"># 没有找到域元数据</span></span><br><span class="line">VIR_ERR_MIGRATE_UNSAFE = <span class="number">81</span></span><br><span class="line">VIR_ERR_OVERFLOW = <span class="number">82</span>  <span class="comment"># 检测到溢出情况</span></span><br><span class="line">VIR_ERR_BLOCK_COPY_ACTIVE = <span class="number">83</span></span><br><span class="line">VIR_ERR_OPERATION_UNSUPPORTED = <span class="number">84</span>  <span class="comment"># 该操作不支持</span></span><br><span class="line">VIR_ERR_SSH = <span class="number">85</span>  <span class="comment"># 检测到一个 ssh 错误</span></span><br><span class="line">VIR_ERR_AGENT_UNRESPONSIVE = <span class="number">86</span>  <span class="comment"># 检测到一个代理超时</span></span><br><span class="line">VIR_ERR_RESOURCE_BUSY = <span class="number">87</span></span><br><span class="line">VIR_ERR_ACCESS_DENIED = <span class="number">88</span></span><br><span class="line">VIR_ERR_DBUS_SERVICE = <span class="number">89</span></span><br><span class="line">VIR_ERR_STORAGE_VOL_EXIST = <span class="number">90</span></span><br><span class="line">VIR_ERR_CPU_INCOMPATIBLE = <span class="number">91</span></span><br><span class="line">VIR_ERR_XML_INVALID_SCHEMA = <span class="number">92</span></span><br></pre></td></tr></table></figure><h3 id="错误域"><a href="#错误域" class="headerlink" title="错误域"></a>错误域</h3><p><strong>get_error_domain</strong> 方法<strong>之所以</strong>命名为 <strong>get_error_domain，是</strong>出于传统原因，但实际上代表了 libvirt 中产生错误的部分。这是 Python libvirt 模块的数据定义之一。此列表中一些编号较高的条目可能在您的 Python libvirt 模块中不可用。完整列表如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">VIR_FROM_NONE = <span class="number">0</span></span><br><span class="line">VIR_FROM_XEN = <span class="number">1</span>  <span class="comment"># Xen 虚拟机管理程序层出现错误</span></span><br><span class="line">VIR_FROM_XEND = <span class="number">2</span>  <span class="comment"># 与 xend 守护进程连接时出错</span></span><br><span class="line">VIR_FROM_XENSTORE = <span class="number">3</span>  <span class="comment"># 与 xen 存储器连接时出错</span></span><br><span class="line">VIR_FROM_SEXPR = <span class="number">4</span>  <span class="comment"># S-Expression 代码中出错</span></span><br><span class="line">VIR_FROM_XML = <span class="number">5</span>  <span class="comment"># XML 代码中的错误</span></span><br><span class="line">VIR_FROM_DOM = <span class="number">6</span>  <span class="comment"># 在域上运行时出错</span></span><br><span class="line">VIR_FROM_RPC = <span class="number">7</span>  <span class="comment"># XML-RPC 代码中出错</span></span><br><span class="line">VIR_FROM_PROXY = <span class="number">8</span>  <span class="comment"># 代理代码中的错误</span></span><br><span class="line">VIR_FROM_CONF = <span class="number">9</span>  <span class="comment"># 配置文件处理错误</span></span><br><span class="line">VIR_FROM_QEMU = <span class="number">10</span>  <span class="comment"># QEMU 守护进程出错</span></span><br><span class="line">VIR_FROM_NET = <span class="number">11</span>  <span class="comment"># 在网络上运行时出错</span></span><br><span class="line">VIR_FROM_TEST = <span class="number">12</span>  <span class="comment"># 测试驱动程序出错</span></span><br><span class="line">VIR_FROM_REMOTE = <span class="number">13</span>  <span class="comment"># 远程驱动程序出错</span></span><br><span class="line">VIR_FROM_OPENVZ = <span class="number">14</span>  <span class="comment"># OpenVZ 驱动程序出错</span></span><br><span class="line">VIR_FROM_XENXM = <span class="number">15</span>  <span class="comment"># Xen XM 层出错</span></span><br><span class="line">VIR_FROM_STATS_LINUX = <span class="number">16</span>  <span class="comment"># Linux 统计代码中的错误</span></span><br><span class="line">VIR_FROM_LXC = <span class="number">17</span>  <span class="comment"># Linux 容器驱动程序出错</span></span><br><span class="line">VIR_FROM_STORAGE = <span class="number">18</span>  <span class="comment"># 存储驱动程序出错</span></span><br><span class="line">VIR_FROM_NETWORK = <span class="number">19</span>  <span class="comment"># 网络配置出错</span></span><br><span class="line">VIR_FROM_DOMAIN = <span class="number">20</span>  <span class="comment"># 域配置出错</span></span><br><span class="line">VIR_FROM_UML = <span class="number">21</span>  <span class="comment"># UML 驱动出错</span></span><br><span class="line">VIR_FROM_NODEDEV = <span class="number">22</span>  <span class="comment"># 来自节点设备监控器的错误</span></span><br><span class="line">VIR_FROM_XEN_INOTIFY = <span class="number">23</span>  <span class="comment"># 来自 xen inotify 层的错误</span></span><br><span class="line">VIR_FROM_SECURITY = <span class="number">24</span>  <span class="comment"># 安全框架出错</span></span><br><span class="line">VIR_FROM_VBOX = <span class="number">25</span>  <span class="comment"># VirtualBox 驱动程序出错</span></span><br><span class="line">VIR_FROM_INTERFACE = <span class="number">26</span>  <span class="comment"># 在接口上操作时出错</span></span><br><span class="line">VIR_FROM_ONE = <span class="number">27</span>  <span class="comment"># OpenNebula 驱动程序出错</span></span><br><span class="line">VIR_FROM_ESX = <span class="number">28</span>  <span class="comment"># ESX 驱动程序出错</span></span><br><span class="line">VIR_FROM_PHYP = <span class="number">29</span>  <span class="comment"># 来自 IBM Power 管理程序的错误</span></span><br><span class="line">VIR_FROM_SECRET = <span class="number">30</span>  <span class="comment"># 来自秘密存储的错误</span></span><br><span class="line">VIR_FROM_CPU = <span class="number">31</span>  <span class="comment"># 来自 CPU 驱动程序的错误</span></span><br><span class="line">VIR_FROM_XENAPI = <span class="number">32</span>  <span class="comment"># 来自 XenAPI 的错误</span></span><br><span class="line">VIR_FROM_NWFILTER = <span class="number">33</span>  <span class="comment"># 网络过滤器驱动程序出错</span></span><br><span class="line">VIR_FROM_HOOK = <span class="number">34</span>  <span class="comment"># 同步钩子出错</span></span><br><span class="line">VIR_FROM_DOMAIN_SNAPSHOT = <span class="number">35</span>  <span class="comment"># 域快照中的错误</span></span><br><span class="line">VIR_FROM_AUDIT = <span class="number">36</span></span><br><span class="line">VIR_FROM_SYSINFO = <span class="number">37</span></span><br><span class="line">VIR_FROM_STREAMS = <span class="number">38</span></span><br><span class="line">VIR_FROM_VMWARE = <span class="number">39</span></span><br><span class="line">VIR_FROM_EVENT = <span class="number">40</span></span><br><span class="line">VIR_FROM_LIBXL = <span class="number">41</span></span><br><span class="line">VIR_FROM_LOCKING = <span class="number">42</span></span><br><span class="line">VIR_FROM_HYPERV = <span class="number">43</span></span><br><span class="line">VIR_FROM_CAPABILITIES = <span class="number">44</span></span><br><span class="line">VIR_FROM_URI = <span class="number">45</span></span><br><span class="line">VIR_FROM_AUTH = <span class="number">46</span></span><br><span class="line">VIR_FROM_DBUS = <span class="number">47</span></span><br><span class="line">VIR_FROM_PARALLELS = <span class="number">48</span></span><br><span class="line">VIR_FROM_DEVICE = <span class="number">49</span></span><br><span class="line">VIR_FROM_SSH = <span class="number">50</span></span><br><span class="line">VIR_FROM_LOCKSPACE = <span class="number">51</span></span><br><span class="line">VIR_FROM_INITCTL = <span class="number">52</span></span><br><span class="line">VIR_FROM_IDENTITY = <span class="number">53</span></span><br><span class="line">VIR_FROM_CGROUP = <span class="number">54</span></span><br><span class="line">VIR_FROM_ACCESS = <span class="number">55</span></span><br><span class="line">VIR_FROM_SYSTEMD = <span class="number">56</span></span><br><span class="line">VIR_FROM_BHYVE = <span class="number">57</span></span><br><span class="line">VIR_FROM_CRYPTO = <span class="number">58</span></span><br><span class="line">VIR_FROM_FIREWALL = <span class="number">59</span></span><br><span class="line">VIR_FROM_POLKIT = <span class="number">60</span></span><br></pre></td></tr></table></figure><h3 id="错误级别"><a href="#错误级别" class="headerlink" title="错误级别"></a>错误级别</h3><p><strong>get_error_level</strong> 方法描述了错误的严重程度。这是 Python libvirt 模块的数据定义之一。错误级别的完整列表如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VIR_ERR_NONE = <span class="number">0</span></span><br><span class="line">VIR_ERR_WARNING = <span class="number">1</span>  <span class="comment"># 简单警告</span></span><br><span class="line">VIR_ERR_ERROR = <span class="number">2</span>  <span class="comment"># 错误</span></span><br></pre></td></tr></table></figure><h3 id="其他错误信息"><a href="#其他错误信息" class="headerlink" title="其他错误信息"></a>其他错误信息</h3><ul><li><strong>get_error_message</strong> 方法是一个描述错误的可读字符串。</li><li><strong>get_error_str1</strong> 方法提供了额外的人类可读信息。</li><li><strong>get_error_str2</strong> 方法提供额外的可读信息。</li><li><strong>get_error_str3</strong> 方法提供了额外的可读信息。</li><li><strong>get_error_int1</strong> 方法提供了额外的数字信息，这些信息可能有助于进一步对错误进行分类。</li><li><strong>get_error_int2</strong> 方法会提供额外的数字信息，这些信息可能有助于进一步对错误进行分类。</li></ul><h2 id="virGetLastError"><a href="#virGetLastError" class="headerlink" title="virGetLastError"></a>virGetLastError</h2><p><strong>virGetLastError</strong> 函数可用于获取一个 Python <strong>列表</strong>，其中包含 libvirt 报告的所有错误信息。此信息保存在线程本地存储中，因此不同线程可以安全地同时使用此函数。需要注意的是，该函数不会进行复制，因此如果当前线程随后调用该函数，错误信息可能会丢失。以下代码演示了 <strong>virGetLastError</strong> 的使用：</p><h3 id="示例-8-2：使用-virGetLastError"><a href="#示例-8-2：使用-virGetLastError" class="headerlink" title="示例 8.2：使用 virGetLastError"></a>示例 8.2：使用 virGetLastError</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-24.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">report_libvirt_error</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;调用 virGetLastError 函数获取最后一次错误信息&quot;&quot;&quot;</span></span><br><span class="line">    err = libvirt.virGetLastError()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Error code: &#x27;</span> + <span class="built_in">str</span>(err[<span class="number">0</span>]), file=sys.stderr)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Error domain: &#x27;</span> + <span class="built_in">str</span>(err[<span class="number">1</span>]), file=sys.stderr)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Error message: &#x27;</span> + err[<span class="number">2</span>], file=sys.stderr)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Error level: &#x27;</span> + <span class="built_in">str</span>(err[<span class="number">3</span>]), file=sys.stderr)</span><br><span class="line">    <span class="keyword">if</span> err[<span class="number">4</span>] != <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Error string1: &#x27;</span> + err[<span class="number">4</span>], file=sys.stderr)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Error string1:&#x27;</span>, file=sys.stderr)</span><br><span class="line">    <span class="keyword">if</span> err[<span class="number">5</span>] != <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Error string2: &#x27;</span> + err[<span class="number">5</span>], file=sys.stderr)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Error string2:&#x27;</span>, file=sys.stderr)</span><br><span class="line">    <span class="keyword">if</span> err[<span class="number">6</span>] != <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Error string3: &#x27;</span> + err[<span class="number">6</span>], file=sys.stderr)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Error string3:&#x27;</span>, file=sys.stderr)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Error int1: &#x27;</span> + <span class="built_in">str</span>(err[<span class="number">7</span>]), file=sys.stderr)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Error int2: &#x27;</span> + <span class="built_in">str</span>(err[<span class="number">8</span>]), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&#x27;qemu:///system&#x27;</span>)</span><br><span class="line">    <span class="comment"># 使参数无效以强制出错</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    report_libvirt_error()</span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="子类化-libvirtError"><a href="#子类化-libvirtError" class="headerlink" title="子类化 libvirtError"></a>子类化 libvirtError</h2><p><strong>可以对 libvirtError</strong> 类进行子类化以添加功能。默认 <strong>libvirtError</strong> 不提供任何保存错误信息或向用户显示信息的功能。通过子类化 <strong>libvirtError，</strong>程序员可以灵活地添加任何所需的功能。下面是一个例子：</p><h3 id="示例-8-3：子类化-libvirtError"><a href="#示例-8-3：子类化-libvirtError" class="headerlink" title="示例 8.3：子类化 libvirtError"></a>示例 8.3：子类化 libvirtError</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-25.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">report_libvirt_error</span>(libvirt.libvirtError):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;子类 virError 可获取最后一条错误信息。&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, defmsg, conn=<span class="literal">None</span>, dom=<span class="literal">None</span>, net=<span class="literal">None</span>, pool=<span class="literal">None</span>, vol=<span class="literal">None</span></span>):</span><br><span class="line">        libvirt.libvirtError.__init__(<span class="variable language_">self</span>, defmsg, conn=<span class="literal">None</span>, dom=<span class="literal">None</span>, net=<span class="literal">None</span>, pool=<span class="literal">None</span>, vol=<span class="literal">None</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Default msg: &#x27;</span> + <span class="built_in">str</span>(defmsg), file=sys.stderr)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Error code: &#x27;</span> + <span class="built_in">str</span>(<span class="variable language_">self</span>.get_error_code()), file=sys.stderr)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Error domain: &#x27;</span> + <span class="built_in">str</span>(<span class="variable language_">self</span>.get_error_domain()), file=sys.stderr)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Error message: &#x27;</span> + <span class="variable language_">self</span>.get_error_message(), file=sys.stderr)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Error level: &#x27;</span> + <span class="built_in">str</span>(<span class="variable language_">self</span>.get_error_level()), file=sys.stderr)</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.err[<span class="number">4</span>] != <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Error string1: &#x27;</span> + <span class="variable language_">self</span>.get_str1(), file=sys.stderr)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Error string1:&#x27;</span>, file=sys.stderr)</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.err[<span class="number">5</span>] != <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Error string2: &#x27;</span> + <span class="variable language_">self</span>.get_str2(), file=sys.stderr)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Error string2:&#x27;</span>, file=sys.stderr)</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.err[<span class="number">6</span>] != <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Error string3: &#x27;</span> + <span class="variable language_">self</span>.get_str3(), file=sys.stderr)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Error string3:&#x27;</span>, file=sys.stderr)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Error int1: &#x27;</span> + <span class="built_in">str</span>(<span class="variable language_">self</span>.get_int1()), file=sys.stderr)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Error int2: &#x27;</span> + <span class="built_in">str</span>(<span class="variable language_">self</span>.get_int2()), file=sys.stderr)</span><br><span class="line">        exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&#x27;qemu:///system&#x27;</span>)</span><br><span class="line">    <span class="comment"># 使参数无效以强制出错</span></span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError:</span><br><span class="line">    <span class="keyword">raise</span> report_libvirt_error(<span class="string">&#x27;连接错误&#x27;</span>)</span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="注册错误处理程序函数"><a href="#注册错误处理程序函数" class="headerlink" title="注册错误处理程序函数"></a>注册错误处理程序函数</h2><p>Libvirt 还支持设置错误处理程序 Python 函数。可以使用 libvirt 函数 <strong>registerErrorHandler</strong>。成功时返回 1。</p><p>已注册的函数会以 <strong>f(ctx, error)</strong> 的形式被调用，其中 <strong>error</strong> 是一个有关错误信息的列表。</p><h3 id="示例-8-4：子类化-libvirtError"><a href="#示例-8-4：子类化-libvirtError" class="headerlink" title="示例 8.4：子类化 libvirtError"></a>示例 8.4：子类化 libvirtError</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-26.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">libvirt_error_handler</span>(<span class="params">ctx, err</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Error code: &#x27;</span> + <span class="built_in">str</span>(err[<span class="number">0</span>]), file=sys.stderr)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Error domain: &#x27;</span> + <span class="built_in">str</span>(err[<span class="number">1</span>]), file=sys.stderr)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Error message: &#x27;</span> + err[<span class="number">2</span>], file=sys.stderr)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Error level: &#x27;</span> + <span class="built_in">str</span>(err[<span class="number">3</span>]), file=sys.stderr)</span><br><span class="line">    <span class="keyword">if</span> err[<span class="number">4</span>] != <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Error string1: &#x27;</span> + err[<span class="number">4</span>], file=sys.stderr)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Error string1:&#x27;</span>, file=sys.stderr)</span><br><span class="line">    <span class="keyword">if</span> err[<span class="number">5</span>] != <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Error string2: &#x27;</span> + err[<span class="number">5</span>], file=sys.stderr)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Error string2:&#x27;</span>, file=sys.stderr)</span><br><span class="line">    <span class="keyword">if</span> err[<span class="number">6</span>] != <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Error string3: &#x27;</span> + err[<span class="number">6</span>], file=sys.stderr)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Error string3:&#x27;</span>, file=sys.stderr)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Error int1: &#x27;</span> + <span class="built_in">str</span>(err[<span class="number">7</span>]), file=sys.stderr)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Error int2: &#x27;</span> + <span class="built_in">str</span>(err[<span class="number">8</span>]), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">ctx = <span class="string">&#x27;只是一些信息&#x27;</span></span><br><span class="line">libvirt.registerErrorHandler(libvirt_error_handler, ctx)</span><br><span class="line"></span><br><span class="line">conn = libvirt.<span class="built_in">open</span>(<span class="string">&#x27;qemu:///system&#x27;</span>)</span><br><span class="line"><span class="comment"># 使参数无效以强制出错</span></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Libvirt-错误处理&quot;&gt;&lt;a href=&quot;#Libvirt-错误处理&quot; class=&quot;headerlink&quot; title=&quot;Libvirt 错误处理&quot;&gt;&lt;/a&gt;Libvirt 错误处理&lt;/h1&gt;&lt;p&gt;libvirt 错误函数的设计目的是在普通 libvirt </summary>
      
    
    
    
    <category term="云计算" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="libvirt" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/libvirt/"/>
    
    
    <category term="云计算" scheme="https://watsonlu6.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="libvirt" scheme="https://watsonlu6.github.io/tags/libvirt/"/>
    
  </entry>
  
  <entry>
    <title>7 libvirt网络接口</title>
    <link href="https://watsonlu6.github.io/libvirt%E6%96%87%E6%A1%A3/7-libvirt%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3/"/>
    <id>https://watsonlu6.github.io/libvirt%E6%96%87%E6%A1%A3/7-libvirt%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3/</id>
    <published>2024-03-07T07:50:26.000Z</published>
    <updated>2025-03-15T08:00:36.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络接口"><a href="#网络接口" class="headerlink" title="网络接口"></a>网络接口</h1><p>本节介绍使用libvirt virInterface管理物理网络接口类</p><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><p>可以使用 <strong>virInterface</strong> 类中的方法检查和修改物理主机上的网络接口配置。这对于设置主机以便在多个希望直接连接到网络的客户域之间共享一个物理接口（简而言之——将一个物理接口奴役到网桥，然后为每个希望共享接口的虚拟机创建一个分路设备），以及对于一般的主机网络接口管理都很有用。除物理硬件外，这些方法还可用于配置网桥、绑定接口和 VLAN 接口。</p><p><strong>virInterface</strong> 类<em>不</em>用于配置虚拟网络（用于将客户域的接口隐藏在 NAT 后面）；而是使用第 <em>6 章（虚拟网络）</em>中描述的 <strong>virNetwork</strong> 类来配置虚拟网络。</p><p>每个主机接口都由 <strong>virInterface</strong> 类的一个实例表示，每个实例都有一个唯一标识符：</p><ul><li><strong>name</strong> 方法返回主机上所有接口（活动或非活动）中唯一的字符串。该字符串与操作系统用于标识接口的字符串相同（例如：<code>eth0</code> 或 <code>br1</code>）。</li><li><strong>MACString</strong> 方法返回该接口 MAC 地址的 ASCII 字符串。由于多个接口可以共享相同的 MAC 地址（例如，在 VLAN 的情况下），因此这<em>不是</em>一个唯一的标识符。不过，它仍可用于搜索接口。</li></ul><p>使用 libvirt 配置的所有接口都应视为持久接口，因为 libvirt 实际上是在更改主机自身的持久配置数据（通常包含在 <code>/etc</code> 下的某个文件中），而不是接口本身。</p><p>定义新接口（使用 <strong>interfaceDefineXML</strong> 方法）或更改现有接口的配置（同样使用 <strong>interfaceDefineXML</strong> 方法）时，该配置将存储在主机上。在手动重启接口或重启主机之前，接口本身的实时配置不会改变。</p><h2 id="7-2-XML-接口描述格式"><a href="#7-2-XML-接口描述格式" class="headerlink" title="7.2 XML 接口描述格式"></a>7.2 XML 接口描述格式</h2><p><strong>interfaceDefineXML</strong> 和 <strong>XMLDesc</strong> 生成并接受的 XML 的当前 Relax NG 定义<strong>可在</strong> <em>libvirt</em> 存储库的 <strong>docs&#x2F;schema&#x2F;interface.rng</strong> 文件中找到，该文件可在 <a href="https://gitlab.com/libvirt/libvirt/">https://gitlab.com/libvirt/libvirt/</a> 上获取。下面是一些常见接口配置的示例。</p><h3 id="示例-7-1：使用-DHCP-的以太网接口的-XML-定义"><a href="#示例-7-1：使用-DHCP-的以太网接口的-XML-定义" class="headerlink" title="示例 7.1：使用 DHCP 的以太网接口的 XML 定义"></a>示例 7.1：使用 DHCP 的以太网接口的 XML 定义</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">interface</span> <span class="attr">type</span>=<span class="string">&#x27;ethernet&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;eth0&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">start</span> <span class="attr">mode</span>=<span class="string">&#x27;onboot&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mac</span> <span class="attr">address</span>=<span class="string">&#x27;aa:bb:cc:dd:ee:ff&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">protocol</span> <span class="attr">family</span>=<span class="string">&#x27;ipv4&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dhcp</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">protocol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="示例-7-2：使用静态-IP-的以太网接口的-XML-定义"><a href="#示例-7-2：使用静态-IP-的以太网接口的-XML-定义" class="headerlink" title="示例 7.2：使用静态 IP 的以太网接口的 XML 定义"></a>示例 7.2：使用静态 IP 的以太网接口的 XML 定义</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">interface</span> <span class="attr">type</span>=<span class="string">&#x27;ethernet&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;eth0&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">start</span> <span class="attr">mode</span>=<span class="string">&#x27;onboot&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mac</span> <span class="attr">address</span>=<span class="string">&#x27;aa:bb:cc:dd:ee:ff&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">protocol</span> <span class="attr">family</span>=<span class="string">&#x27;ipv4&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ip</span> <span class="attr">address</span>=<span class="string">&quot;192.168.0.5&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;24&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">route</span> <span class="attr">gateway</span>=<span class="string">&quot;192.168.0.1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">protocol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="示例-7-3：连接有-eth0-和-eth1-的网桥设备的-XML-定义"><a href="#示例-7-3：连接有-eth0-和-eth1-的网桥设备的-XML-定义" class="headerlink" title="示例 7.3：连接有 eth0 和 eth1 的网桥设备的 XML 定义"></a>示例 7.3：连接有 eth0 和 eth1 的网桥设备的 XML 定义</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">interface</span> <span class="attr">type</span>=<span class="string">&quot;bridge&quot;</span> <span class="attr">name</span>=<span class="string">&quot;br0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">start</span> <span class="attr">mode</span>=<span class="string">&quot;onboot&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mtu</span> <span class="attr">size</span>=<span class="string">&quot;1500&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">protocol</span> <span class="attr">family</span>=<span class="string">&quot;ipv4&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dhcp</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">protocol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bridge</span> <span class="attr">stp</span>=<span class="string">&quot;off&quot;</span> <span class="attr">delay</span>=<span class="string">&quot;0.01&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interface</span> <span class="attr">type</span>=<span class="string">&quot;ethernet&quot;</span> <span class="attr">name</span>=<span class="string">&quot;eth0&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mac</span> <span class="attr">address</span>=<span class="string">&quot;ab:bb:cc:dd:ee:ff&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interface</span> <span class="attr">type</span>=<span class="string">&quot;ethernet&quot;</span> <span class="attr">name</span>=<span class="string">&quot;eth1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bridge</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="示例-7-4：与-eth0-相关联的-VLAN-接口的-XML-定义"><a href="#示例-7-4：与-eth0-相关联的-VLAN-接口的-XML-定义" class="headerlink" title="示例 7.4：与 eth0 相关联的 VLAN 接口的 XML 定义"></a>示例 7.4：与 eth0 相关联的 VLAN 接口的 XML 定义</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">interface</span> <span class="attr">type</span>=<span class="string">&quot;vlan&quot;</span> <span class="attr">name</span>=<span class="string">&quot;eth0.42&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">start</span> <span class="attr">mode</span>=<span class="string">&quot;onboot&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">protocol</span> <span class="attr">family</span>=<span class="string">&quot;ipv4&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dhcp</span> <span class="attr">peerdns</span>=<span class="string">&quot;no&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">protocol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">vlan</span> <span class="attr">tag</span>=<span class="string">&quot;42&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interface</span> <span class="attr">name</span>=<span class="string">&quot;eth0&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">vlan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="7-3-检索接口信息"><a href="#7-3-检索接口信息" class="headerlink" title="7.3 检索接口信息"></a>7.3 检索接口信息</h2><h3 id="枚举接口"><a href="#枚举接口" class="headerlink" title="枚举接口"></a>枚举接口</h3><p>与主机建立连接后，可以使用 <strong>numOfInterfaces</strong> 和 <strong>numOfDefinedInterfaces</strong> 方法确定主机上的接口数量。使用 <strong>listInterfaces</strong> 方法和 <strong>listDefinedInterfaces</strong> 方法（”已定义” 接口是指那些已经定义但当前处于非活动状态的接口）可以获得这些接口名称的列表。list 方法返回一个 Python <strong>列表</strong>。如果遇到错误，所有四个函数都返回 <strong>None</strong>。</p><h4 id="示例-7-5：获取主机上活动（”up”）接口列表"><a href="#示例-7-5：获取主机上活动（”up”）接口列表" class="headerlink" title="示例 7.5：获取主机上活动（”up”）接口列表"></a>示例 7.5：获取主机上活动（”up”）接口列表</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-5.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">ifaceNames = conn.listInterfaces()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Active host interfaces:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> ifaceName <span class="keyword">in</span> ifaceNames:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span> + ifaceName)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h4 id="示例-7-6：获取主机上不活动（”停机”）接口的列表"><a href="#示例-7-6：获取主机上不活动（”停机”）接口的列表" class="headerlink" title="示例 7.6：获取主机上不活动（”停机”）接口的列表"></a>示例 7.6：获取主机上不活动（”停机”）接口的列表</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-6.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">ifaceNames = conn.listDefinedInterfaces()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Inactive host interfaces:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> ifaceName <span class="keyword">in</span> ifaceNames:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span> + ifaceName)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="为接口获取-virInterface-实例"><a href="#为接口获取-virInterface-实例" class="headerlink" title="为接口获取 virInterface 实例"></a>为接口获取 virInterface 实例</h3><p>许多操作要求您有 <strong>virInterface</strong> 的实例，但您可能只有接口的名称或 MAC 地址。在这种情况下，您可以使用 <strong>interfaceLookupByName</strong> 和 <strong>interfaceLookupByMACString</strong> 获取 <strong>virInterface</strong> 实例。</p><h4 id="示例-7-7：获取给定接口名称的-virInterface-实例"><a href="#示例-7-7：获取给定接口名称的-virInterface-实例" class="headerlink" title="示例 7.7：获取给定接口名称的 virInterface 实例"></a>示例 7.7：获取给定接口名称的 virInterface 实例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-7.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">iface = conn.interfaceLookupByName(<span class="string">&#x27;eth0&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The interface name is: &quot;</span> + iface.name())</span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h4 id="示例-7-8：获取给定接口-MAC-地址的-virInterface-实例"><a href="#示例-7-8：获取给定接口-MAC-地址的-virInterface-实例" class="headerlink" title="示例 7.8：获取给定接口 MAC 地址的 virInterface 实例"></a>示例 7.8：获取给定接口 MAC 地址的 virInterface 实例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-8.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">iface = conn.interfaceLookupByMACString(<span class="string">&#x27;00:01:02:03:04:05&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The interface name is: &quot;</span> + iface.name())</span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="检索详细的接口信息"><a href="#检索详细的接口信息" class="headerlink" title="检索详细的接口信息"></a>检索详细的接口信息</h3><p>您也可能会发现自己有一个 <strong>virInterface</strong> 实例，需要该接口的名称或 MAC 地址，或想检查完整的接口配置。<strong>name</strong>、<strong>MACString</strong> 和 <strong>XMLDesc</strong> 方法提供了这种功能。</p><h4 id="示例-7-9：从接口对象获取名称和-MAC-地址"><a href="#示例-7-9：从接口对象获取名称和-MAC-地址" class="headerlink" title="示例 7.9：从接口对象获取名称和 MAC 地址"></a>示例 7.9：从接口对象获取名称和 MAC 地址</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-9.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">iface = conn.interfaceLookupByName(<span class="string">&#x27;eth0&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The interface name is: &quot;</span> + iface.name())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The interface mac string is: &quot;</span> + iface.MACString())</span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h4 id="示例-7-10：从接口对象获取-XML-配置字符串"><a href="#示例-7-10：从接口对象获取-XML-配置字符串" class="headerlink" title="示例 7.10：从接口对象获取 XML 配置字符串"></a>示例 7.10：从接口对象获取 XML 配置字符串</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-10.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">iface = conn.interfaceLookupByName(<span class="string">&#x27;eth0&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The interface XML description is:\n &quot;</span> + iface.XMLDesc(<span class="number">0</span>))</span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="检索接口网络地址"><a href="#检索接口网络地址" class="headerlink" title="检索接口网络地址"></a>检索接口网络地址</h3><p>您可能会发现自己有一个 <strong>virDomain</strong> 实例，并需要一个或多个访客域接口的 IP 地址。<strong>interfaceAddresses</strong> 方法提供了这种功能。</p><h4 id="示例-7-11：获取所有客户域网络接口的-IP-地址"><a href="#示例-7-11：获取所有客户域网络接口的-IP-地址" class="headerlink" title="示例 7.11：获取所有客户域网络接口的 IP 地址"></a>示例 7.11：获取所有客户域网络接口的 IP 地址</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-14.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">domainName = <span class="string">&quot;CentOS7&quot;</span></span><br><span class="line">dom = conn.lookupByName(domainName)</span><br><span class="line"><span class="keyword">if</span> dom == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to get the domain object&#x27;</span>, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">ifaces = dom.interfaceAddresses(libvirt.VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_AGENT, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The interface IP addresses:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (name, val) <span class="keyword">in</span> ifaces.iteritems():</span><br><span class="line">    <span class="keyword">if</span> val[<span class="string">&#x27;addrs&#x27;</span>]:</span><br><span class="line">        <span class="keyword">for</span> ipaddr <span class="keyword">in</span> val[<span class="string">&#x27;addrs&#x27;</span>]:</span><br><span class="line">            <span class="keyword">if</span> ipaddr[<span class="string">&#x27;type&#x27;</span>] == libvirt.VIR_IP_ADDR_TYPE_IPV4:</span><br><span class="line">                <span class="built_in">print</span>(ipaddr[<span class="string">&#x27;addr&#x27;</span>] + <span class="string">&quot; VIR_IP_ADDR_TYPE_IPV4&quot;</span>)</span><br><span class="line">            <span class="keyword">elif</span> ipaddr[<span class="string">&#x27;type&#x27;</span>] == libvirt.VIR_IP_ADDR_TYPE_IPV6:</span><br><span class="line">                <span class="built_in">print</span>(ipaddr[<span class="string">&#x27;addr&#x27;</span>] + <span class="string">&quot; VIR_IP_ADDR_TYPE_IPV6&quot;</span>)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="7-4-管理接口配置文件"><a href="#7-4-管理接口配置文件" class="headerlink" title="7.4 管理接口配置文件"></a>7.4 管理接口配置文件</h2><p>在 libvirt 中，”定义” 接口意味着创建或更改配置，而 “取消定义” 意味着从系统中删除该配置。新用户有时可能会将这两个操作与创建&#x2F;删除（实际用于激活和停用现有接口，请参见*第 7.5 节 “Interface 生命周期管理”*）混淆。</p><h3 id="定义接口配置"><a href="#定义接口配置" class="headerlink" title="定义接口配置"></a>定义接口配置</h3><p><strong>interfaceDefineXML</strong> 方法用于添加新的接口配置和修改现有配置。它可以添加一个新接口（包括接口名称在内的所有信息都在 XML 数据中给出），也可以修改现有接口的配置。新定义的接口将处于非活动状态，直到采取单独的措施使新配置生效（例如，重启主机或调用<strong>创建</strong>（参见<em>第 7.5 节 “接口生命周期管理”）</em>）。</p><p>如果在主机配置中成功添加&#x2F;修改了接口，<strong>interfaceDefineXML</strong> 会返回一个 <strong>virInterface</strong> 实例。该实例可用作对新界面执行进一步操作的句柄，例如通过<strong>创建</strong>使其激活。</p><p>目前，flags 参数应始终为 <strong>0</strong>。</p><h4 id="示例-7-12：定义新接口"><a href="#示例-7-12：定义新接口" class="headerlink" title="示例 7.12：定义新接口"></a>示例 7.12：定义新接口</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-11.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">xml = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;interface type=&#x27;ethernet&#x27; name=&#x27;eth0&#x27;&gt;</span></span><br><span class="line"><span class="string">  &lt;start mode=&#x27;onboot&#x27;/&gt;</span></span><br><span class="line"><span class="string">  &lt;mac address=&#x27;aa:bb:cc:dd:ee:ff&#x27;/&gt;</span></span><br><span class="line"><span class="string">  &lt;protocol family=&#x27;ipv4&#x27;&gt;</span></span><br><span class="line"><span class="string">    &lt;ip address=&quot;192.168.0.5&quot; prefix=&quot;24&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;route gateway=&quot;192.168.0.1&quot;/&gt;</span></span><br><span class="line"><span class="string">  &lt;/protocol&gt;</span></span><br><span class="line"><span class="string">&lt;/interface&gt;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&#x27;qemu:///system&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建/修改网络接口</span></span><br><span class="line">iface = conn.interfaceDefineXML(xml, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 激活接口</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    iface.create(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    iface.undefine()</span><br><span class="line">    conn.close()</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The interface name is: &quot;</span> + iface.name())</span><br><span class="line">iface.destroy()</span><br><span class="line">iface.undefine()</span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="取消定义接口配置"><a href="#取消定义接口配置" class="headerlink" title="取消定义接口配置"></a>取消定义接口配置</h3><p><strong>undefine</strong> 方法会从主机配置文件中彻底、永久删除给定接口的配置。如果将来要重新创建该配置，应调用 <strong>XMLDesc</strong> 方法，并在 undefine 之前保存字符串。</p><h4 id="示例-7-13：保存-XML-数据后取消定义-br0-接口"><a href="#示例-7-13：保存-XML-数据后取消定义-br0-接口" class="headerlink" title="示例 7.13：保存 XML 数据后取消定义 br0 接口"></a>示例 7.13：保存 XML 数据后取消定义 br0 接口</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-12.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">iface = conn.interfaceLookupByName(<span class="string">&#x27;br0&#x27;</span>)</span><br><span class="line"><span class="comment"># 在取消定义接口之前获取 XML</span></span><br><span class="line">xml = iface.XMLDesc(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 现在取消定义接口</span></span><br><span class="line">iface.undefine()</span><br><span class="line"><span class="comment"># 接口现在未定义，iface 变量不再可用</span></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="更改回滚"><a href="#更改回滚" class="headerlink" title="更改回滚"></a>更改回滚</h3><p>该方法回滚自上次调用 <strong>changeCommit</strong> 方法被调用。</p><p>注意：如果没有待定的接口定义，则会出错。</p><h4 id="示例-7-14：使用-changeRollback"><a href="#示例-7-14：使用-changeRollback" class="headerlink" title="示例 7.14：使用 changeRollback"></a>示例 7.14：使用 changeRollback</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-30.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">iface = conn.changeRollback()</span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="更改开始"><a href="#更改开始" class="headerlink" title="更改开始"></a>更改开始</h3><p>该方法会创建一个还原点，以后可以通过调用 <strong>changeRollback</strong> 方法返回该点。该函数应在使用接口配置的任何事务之前调用。一旦知道新配置有效，就可以通过 <strong>changeCommit</strong> 方法提交新配置，从而释放还原点。</p><p>如果在事务已打开的情况下调用 <strong>changeBegin</strong> 方法，则会出现错误。</p><h4 id="示例-7-15：使用-changeBegin"><a href="#示例-7-15：使用-changeBegin" class="headerlink" title="示例 7.15：使用 changeBegin"></a>示例 7.15：使用 changeBegin</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-31.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">iface = conn.changeBegin()</span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="更改提交"><a href="#更改提交" class="headerlink" title="更改提交"></a>更改提交</h3><p>这将提交对界面所做的更改，并释放由 <strong>changeBegin</strong> 方法。</p><h4 id="示例-7-16：使用-changeCommit"><a href="#示例-7-16：使用-changeCommit" class="headerlink" title="示例 7.16：使用 changeCommit"></a>示例 7.16：使用 changeCommit</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-32.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">conn.changeCommit()</span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><strong>changeRollback</strong> 方法可用于回滚未提交的变更。</p><h2 id="7-5-接口生命周期管理"><a href="#7-5-接口生命周期管理" class="headerlink" title="7.5 接口生命周期管理"></a>7.5 接口生命周期管理</h2><p>在 libvirt 术语中，”创建” 接口意味着使其处于活动状态或 “启动”，而 “删除” 接口意味着使其处于非活动状态或 “关闭”。在使用 <em>netcf</em> 后端进行接口配置的主机（如 Fedora 和 Red Hat Enterprise Linux）上，这与为接口调用系统 shell 脚本 <strong>ifup</strong> 和 <strong>ifdown</strong> 相同。</p><h3 id="激活接口"><a href="#激活接口" class="headerlink" title="激活接口"></a>激活接口</h3><p><strong>创建</strong>方法会将给定的非活动接口激活（”up”）。如果在使接口激活时出现任何问题，则返回 -1。*例 7.12 “定义新接口 “*展示了该方法的典型用法。</p><h3 id="停用接口"><a href="#停用接口" class="headerlink" title="停用接口"></a>停用接口</h3><p><strong>destroy</strong> 方法会使给定的接口处于非活动状态（”停机”）。如果在使接口处于激活状态时出现任何问题，则返回 -1。</p><h4 id="示例-7-17：暂时关闭-eth2，然后将其恢复正常"><a href="#示例-7-17：暂时关闭-eth2，然后将其恢复正常" class="headerlink" title="示例 7.17：暂时关闭 eth2，然后将其恢复正常"></a>示例 7.17：暂时关闭 eth2，然后将其恢复正常</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-12.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">iface = conn.interfaceLookupByName(<span class="string">&#x27;br0&#x27;</span>)</span><br><span class="line"><span class="comment"># 在取消定义接口之前获取 XML</span></span><br><span class="line">xml = iface.XMLDesc(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 现在取消定义接口</span></span><br><span class="line">iface.undefine()</span><br><span class="line"><span class="comment"># 接口现在未定义，iface 变量不再可用</span></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络接口&quot;&gt;&lt;a href=&quot;#网络接口&quot; class=&quot;headerlink&quot; title=&quot;网络接口&quot;&gt;&lt;/a&gt;网络接口&lt;/h1&gt;&lt;p&gt;本节介绍使用libvirt virInterface管理物理网络接口类&lt;/p&gt;
&lt;h2 id=&quot;7-1-概述&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="云计算" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="libvirt" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/libvirt/"/>
    
    
    <category term="云计算" scheme="https://watsonlu6.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="libvirt" scheme="https://watsonlu6.github.io/tags/libvirt/"/>
    
  </entry>
  
  <entry>
    <title>6 libvirt虚拟网络</title>
    <link href="https://watsonlu6.github.io/libvirt%E6%96%87%E6%A1%A3/6-libvirt%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C/"/>
    <id>https://watsonlu6.github.io/libvirt%E6%96%87%E6%A1%A3/6-libvirt%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C/</id>
    <published>2024-03-06T07:50:26.000Z</published>
    <updated>2025-03-15T08:00:32.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="libvirt虚拟网络"><a href="#libvirt虚拟网络" class="headerlink" title="libvirt虚拟网络"></a>libvirt虚拟网络</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><p>虚拟网络提供了一种连接单个主机内一个或多个访客域的网络设备的方法。虚拟网络可以：</p><ul><li>与宿主保持隔离。</li><li>允许通过主机操作系统的活动网络接口路由节点外流量。这包括对 IPv4 流量应用 NAT 的选项。</li></ul><p>虚拟网络由 <strong>virNetwork</strong> 对象表示，有两个唯一标识符：</p><ul><li><strong>name</strong>：短字符串，在一台主机上的所有虚拟网络（包括运行中和未激活的）中都是唯一的。为最大限度地提高虚拟机管理程序之间的可移植性，应用程序只能使用字符 <code>a-Z</code>、<code>0-9</code>、<code>-</code>、<code>_</code>。</li><li><strong>UUID</strong>：16 个无符号字节，保证在任何主机上的所有虚拟网络中都是唯一的。RFC 4122 定义了 UUID 的格式，并提供了生成具有唯一性的 UUID 的推荐算法。</li></ul><p>虚拟网络可以是瞬时的，也可以是持久的。瞬态虚拟网络在创建时启动，只能在主机上运行时对其进行管理。脱机后，所有痕迹都会消失。持久虚拟网络的配置以实施定义的格式保存在主机上的数据存储中。因此，当持久网络离线时，仍可管理其非活动配置。瞬态网络可以通过为其定义配置，即时转变为持久网络。</p><p>安装 libvirt 后，每台主机都将获得一个名为 “default” 的虚拟网络实例，为访客提供 DHCP 服务，并允许通过 NAT 连接主机接口的 IP。这项服务对网络连接时断时续的主机最有用。例如，使用无线网络的笔记本电脑。该网络被配置为自动启动。</p><h2 id="6-2-监听网络"><a href="#6-2-监听网络" class="headerlink" title="6.2 监听网络"></a>6.2 监听网络</h2><p>使用 <strong>networkLookupByName</strong>、<strong>networkLookupByUUID</strong>、<strong>networkLookupByUUIDString</strong> 和 <strong>listNetworks</strong> 方法可以发现虚拟网络。下面的示例展示了如何使用这些方法。</p><h3 id="示例-6-1：发现和查找虚拟网络"><a href="#示例-6-1：发现和查找虚拟网络" class="headerlink" title="示例 6.1：发现和查找虚拟网络"></a>示例 6.1：发现和查找虚拟网络</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-1.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发现所有虚拟网络</span></span><br><span class="line">networks = conn.listNetworks()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Virtual networks:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> network <span class="keyword">in</span> networks:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span> + network)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按名称查找默认网络</span></span><br><span class="line">network = conn.networkLookupByName(<span class="string">&#x27;default&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Virtual network default:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; name: &#x27;</span> + network.name())</span><br><span class="line">uuid = network.UUIDString()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; UUID: &#x27;</span> + uuid)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; bridge: &#x27;</span> + network.bridgeName())</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按 UUID 查找默认网络</span></span><br><span class="line">network = conn.networkLookupByUUIDString(uuid)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Virtual network default:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; name: &#x27;</span> + network.name())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; UUID: &#x27;</span> + network.UUIDString())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; bridge: &#x27;</span> + network.bridgeName())</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="6-3-生命周期控制"><a href="#6-3-生命周期控制" class="headerlink" title="6.3 生命周期控制"></a>6.3 生命周期控制</h2><p>下面的示例展示了如何使用 <strong>networkDefineXML</strong>、<strong>networkCreateXML</strong>、<strong>destroy</strong> 和 <strong>undefine</strong> 方法。</p><h3 id="示例-6-2：创建和销毁虚拟网络"><a href="#示例-6-2：创建和销毁虚拟网络" class="headerlink" title="示例 6.2：创建和销毁虚拟网络"></a>示例 6.2：创建和销毁虚拟网络</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-2.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">xml = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;network&gt;</span></span><br><span class="line"><span class="string">  &lt;name&gt;mynetwork&lt;/name&gt;</span></span><br><span class="line"><span class="string">  &lt;bridge name=&quot;virbr1&quot;/&gt;</span></span><br><span class="line"><span class="string">  &lt;forward mode=&quot;nat&quot;/&gt;</span></span><br><span class="line"><span class="string">  &lt;ip address=&quot;192.168.142.1&quot; netmask=&quot;255.255.255.0&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;dhcp&gt;</span></span><br><span class="line"><span class="string">      &lt;range start=&quot;192.168.142.2&quot; end=&quot;192.168.142.254&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/dhcp&gt;</span></span><br><span class="line"><span class="string">  &lt;/ip&gt;</span></span><br><span class="line"><span class="string">&lt;/network&gt;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个持久的虚拟网络</span></span><br><span class="line">network = conn.networkDefineXML(xml)</span><br><span class="line"><span class="keyword">if</span> network == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to create a virtual network&#x27;</span>, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">active = network.isActive()</span><br><span class="line"><span class="keyword">if</span> active == <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The new persistent virtual network is active&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The new persistent virtual network is not active&#x27;</span>)</span><br><span class="line"></span><br><span class="line">network.create()  <span class="comment"># 设置网络激活</span></span><br><span class="line">active = network.isActive()</span><br><span class="line"><span class="keyword">if</span> active == <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The new transient virtual network is active&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The new transient virtual network is not active&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在销毁持久虚拟网络</span></span><br><span class="line">network.destroy()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除持久虚拟网络</span></span><br><span class="line">network.undefine()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建临时虚拟网络</span></span><br><span class="line">network = conn.networkCreateXML(xml)</span><br><span class="line"><span class="keyword">if</span> network == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to define a virtual network&#x27;</span>, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">active = network.isActive()</span><br><span class="line"><span class="keyword">if</span> active == <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The new transient virtual network is active&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The new transient virtual network is not active&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在销毁暂存虚拟网络</span></span><br><span class="line">network.destroy()</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="6-4-网络配置"><a href="#6-4-网络配置" class="headerlink" title="6.4 网络配置"></a>6.4 网络配置</h2><p>下面的示例展示了如何使用 <strong>XMLDesc</strong>、<strong>autostart</strong>、<strong>isActive</strong>、<strong>isPersistent</strong> 和 <strong>setAutostart</strong> 方法。</p><h3 id="示例-6-3：配置虚拟网络"><a href="#示例-6-3：配置虚拟网络" class="headerlink" title="示例 6.3：配置虚拟网络"></a>示例 6.3：配置虚拟网络</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-3.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按名称查找默认网络</span></span><br><span class="line">network = conn.networkLookupByName(<span class="string">&#x27;default&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Virtual network default:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; name: &#x27;</span> + network.name())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; UUID: &#x27;</span> + network.UUIDString())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; bridge: &#x27;</span> + network.bridgeName())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; autostart: &#x27;</span> + <span class="built_in">str</span>(network.autostart()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; is active: &#x27;</span> + <span class="built_in">str</span>(network.isActive()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; is persistent: &#x27;</span> + <span class="built_in">str</span>(network.isPersistent()))</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Unsetting autostart&#x27;</span>)</span><br><span class="line">network.setAutostart(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; autostart: &#x27;</span> + <span class="built_in">str</span>(network.autostart()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Setting autostart&#x27;</span>)</span><br><span class="line">network.setAutostart(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; autostart: &#x27;</span> + <span class="built_in">str</span>(network.autostart()))</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">xml = network.XMLDesc(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;XML description:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(xml)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;libvirt虚拟网络&quot;&gt;&lt;a href=&quot;#libvirt虚拟网络&quot; class=&quot;headerlink&quot; title=&quot;libvirt虚拟网络&quot;&gt;&lt;/a&gt;libvirt虚拟网络&lt;/h1&gt;&lt;h2 id=&quot;6-1-概述&quot;&gt;&lt;a href=&quot;#6-1-概述&quot; cla</summary>
      
    
    
    
    <category term="云计算" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="libvirt" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/libvirt/"/>
    
    
    <category term="云计算" scheme="https://watsonlu6.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="libvirt" scheme="https://watsonlu6.github.io/tags/libvirt/"/>
    
  </entry>
  
  <entry>
    <title>5 libvirt存储管理</title>
    <link href="https://watsonlu6.github.io/libvirt%E6%96%87%E6%A1%A3/5-libvirt%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
    <id>https://watsonlu6.github.io/libvirt%E6%96%87%E6%A1%A3/5-libvirt%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</id>
    <published>2024-03-05T07:50:26.000Z</published>
    <updated>2025-03-15T08:00:30.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Libvirt-存储管理"><a href="#Libvirt-存储管理" class="headerlink" title="Libvirt 存储管理"></a>Libvirt 存储管理</h1><p>Libvirt 通过存储池和存储卷在物理主机上提供存储管理。存储池是由管理员（通常是专门的存储管理员）为虚拟机预留的一定量的存储空间。存储池被存储管理员或系统管理员划分为存储卷，这些存储卷作为块设备分配给虚拟机。</p><h2 id="存储池和存储卷的示例"><a href="#存储池和存储卷的示例" class="headerlink" title="存储池和存储卷的示例"></a>存储池和存储卷的示例</h2><h3 id="NFS-示例"><a href="#NFS-示例" class="headerlink" title="NFS 示例"></a>NFS 示例</h3><p>负责 NFS 服务器的存储管理员创建了一个共享以存储虚拟机的数据。系统管理员在虚拟化主机上定义一个包含共享详细信息的池（例如，<code>nfs.example.com:/path/to/share</code> 应挂载在 <code>/vm_data</code>）。当池启动时，libvirt 将共享挂载到指定目录，就像系统管理员登录并执行 <code>mount nfs.example.com:/path/to/share /vmdata</code> 一样。如果池配置为自动启动，当 libvirt 启动时，libvirt 会确保 NFS 共享挂载到指定目录。一旦池启动，NFS 共享中的文件将被报告为卷，可以使用 libvirt API 查询存储卷的路径。这些卷的路径可以复制到虚拟机的 XML 定义部分，用于描述虚拟机块设备的源存储。对于 NFS，使用 libvirt 方法的应用程序可以在池中创建和删除卷（NFS 共享中的文件），直到达到池的大小限制（共享的存储容量）。并非所有池类型都支持创建和删除卷。停止池（virsh 和 API 中不幸地称为“池销毁”）会撤销启动操作，在这种情况下会卸载 NFS 共享。尽管名称如此，但销毁操作不会修改共享上的数据。更多详细信息请参阅 <code>man virsh</code>。</p><h3 id="iSCSI-示例"><a href="#iSCSI-示例" class="headerlink" title="iSCSI 示例"></a>iSCSI 示例</h3><p>存储管理员配置一个 iSCSI 目标以向运行虚拟机的主机提供一组 LUN。当 libvirt 配置为管理该 iSCSI 目标作为池时，libvirt 将确保主机登录到 iSCSI 目标，然后 libvirt 可以报告可用的 LUN 作为存储卷。可以查询这些卷的路径并在虚拟机的 XML 定义中使用，如 NFS 示例中那样。在这种情况下，LUN 在 iSCSI 服务器上定义，libvirt 无法创建和删除卷。</p><h2 id="存储池和存储卷的必要性"><a href="#存储池和存储卷的必要性" class="headerlink" title="存储池和存储卷的必要性"></a>存储池和存储卷的必要性</h2><p>存储池和存储卷不是虚拟机正常运行所必需的。池和卷为 libvirt 提供了一种确保特定存储可供虚拟机使用的方法，但一些管理员可能更愿意自己管理存储，虚拟机在没有定义任何池或卷的情况下也能正常运行。在不使用池的系统上，系统管理员必须使用他们喜欢的工具确保虚拟机存储的可用性，例如，将 NFS 共享添加到主机的 fstab 中，以便在启动时挂载共享。</p><h2 id="Libvirt-的远程协议功能"><a href="#Libvirt-的远程协议功能" class="headerlink" title="Libvirt 的远程协议功能"></a>Libvirt 的远程协议功能</h2><p>如果此时池和卷相对于传统系统管理工具的价值尚不清楚，请注意 libvirt 的一个功能是其远程协议，因此可以管理虚拟机生命周期的所有方面以及虚拟机所需资源的配置。这些操作可以在远程主机上完全通过 Python libvirt 模块执行。换句话说，使用 libvirt 的管理应用程序可以让用户执行配置虚拟机主机所需的所有任务：分配资源、运行虚拟机、关闭虚拟机和释放资源，而无需 shell 访问或任何其他控制通道。</p><h2 id="Libvirt-支持的存储池类型"><a href="#Libvirt-支持的存储池类型" class="headerlink" title="Libvirt 支持的存储池类型"></a>Libvirt 支持的存储池类型</h2><p>Libvirt 支持以下存储池类型：</p><ul><li>目录后台</li><li>本地文件系统后台</li><li>网络文件系统后台</li><li>逻辑后台</li><li>磁盘后台</li><li>iSCSI 后端</li><li>SCSI 后端</li><li>多路径后端</li><li>RBD（RADOS 块设备）后台</li><li>Sheepdog 后台</li><li>Gluster 后端</li><li>ZFS 后端</li></ul><p>存储池 XML 格式在 <a href="https://libvirt.org/formatstorage.html#StoragePool">https://libvirt.org/formatstorage.html#StoragePool</a> 中指定。</p><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>存储池是存储卷的容器。一个系统可以根据需要拥有任意多个存储池，每个存储池可以包含任意多个存储卷。</p><h2 id="5-2-列出存储池"><a href="#5-2-列出存储池" class="headerlink" title="5.2 列出存储池"></a>5.2 列出存储池</h2><p>存储池对象的<strong>列表</strong>可以使用 <strong>virConnect</strong> 类。</p><p><code>flags</code> 参数可以是以下一个或多个常量：</p><ul><li><code>VIR_CONNECT_LIST_STORAGE_POOLS_INACTIVE</code></li><li><code>VIR_CONNECT_LIST_STORAGE_POOLS_ACTIVE</code></li><li><code>VIR_CONNECT_LIST_STORAGE_POOLS_PERSISTENT</code></li><li><code>VIR_CONNECT_LIST_STORAGE_POOLS_TRANSIENT</code></li><li><code>VIR_CONNECT_LIST_STORAGE_POOLS_AUTOSTART</code></li><li><code>VIR_CONNECT_LIST_STORAGE_POOLS_NO_AUTOSTART</code></li><li><code>VIR_CONNECT_LIST_STORAGE_POOLS_DIR</code></li><li><code>VIR_CONNECT_LIST_STORAGE_POOLS_FS</code></li><li><code>VIR_CONNECT_LIST_STORAGE_POOLS_NETFS</code></li><li><code>VIR_CONNECT_LIST_STORAGE_POOLS_LOGICAL</code></li><li><code>VIR_CONNECT_LIST_STORAGE_POOLS_DISK</code></li><li><code>VIR_CONNECT_LIST_STORAGE_POOLS_ISCSI</code></li><li><code>VIR_CONNECT_LIST_STORAGE_POOLS_SCSI</code></li><li><code>VIR_CONNECT_LIST_STORAGE_POOLS_MPATH</code></li><li><code>VIR_CONNECT_LIST_STORAGE_POOLS_RBD</code></li><li><code>VIR_CONNECT_LIST_STORAGE_POOLS_SHEEPDOG</code></li><li><code>VIR_CONNECT_LIST_STORAGE_POOLS_GLUSTER</code></li><li><code>VIR_CONNECT_LIST_STORAGE_POOLS_ZFS</code></li></ul><h3 id="示例-5-1：获取存储池列表"><a href="#示例-5-1：获取存储池列表" class="headerlink" title="示例 5.1：获取存储池列表"></a>示例 5.1：获取存储池列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-1.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">pools = conn.listAllStoragePools(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> pools == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to locate any StoragePool objects.&#x27;</span>, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pool <span class="keyword">in</span> pools:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Pool: &#x27;</span> + pool.name())</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="5-3-存储池的使用"><a href="#5-3-存储池的使用" class="headerlink" title="5.3 存储池的使用"></a>5.3 存储池的使用</h2><p><strong>virStoragePool</strong> 类中有许多可用的方法。下面的示例程序介绍了其中一些描述池某些属性的方法。</p><h3 id="示例-5-2：展示一些存储池方法的用法"><a href="#示例-5-2：展示一些存储池方法的用法" class="headerlink" title="示例 5.2：展示一些存储池方法的用法"></a>示例 5.2：展示一些存储池方法的用法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-2.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">pool = conn.storagePoolLookupByName(<span class="string">&#x27;default&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> pool == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to locate any StoragePool objects.&#x27;</span>, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">info = pool.info()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Pool: &#x27;</span> + pool.name())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; UUID: &#x27;</span> + pool.UUIDString())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; Autostart: &#x27;</span> + <span class="built_in">str</span>(pool.autostart()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; Is active: &#x27;</span> + <span class="built_in">str</span>(pool.isActive()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; Is persistent: &#x27;</span> + <span class="built_in">str</span>(pool.isPersistent()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; Num volumes: &#x27;</span> + <span class="built_in">str</span>(pool.numOfVolumes()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; Pool state: &#x27;</span> + <span class="built_in">str</span>(info[<span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; Capacity: &#x27;</span> + <span class="built_in">str</span>(info[<span class="number">1</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; Allocation: &#x27;</span> + <span class="built_in">str</span>(info[<span class="number">2</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; Available: &#x27;</span> + <span class="built_in">str</span>(info[<span class="number">3</span>]))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="示例-5-3：获取存储池的-XML-描述"><a href="#示例-5-3：获取存储池的-XML-描述" class="headerlink" title="示例 5.3：获取存储池的 XML 描述"></a>示例 5.3：获取存储池的 XML 描述</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-3.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">pool = conn.storagePoolLookupByName(<span class="string">&#x27;default&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> pool == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to locate any StoragePool objects.&#x27;</span>, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">xml = pool.XMLDesc(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(xml)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="5-4-生命周期控制"><a href="#5-4-生命周期控制" class="headerlink" title="5.4 生命周期控制"></a>5.4 生命周期控制</h2><h3 id="示例-5-4：创建和销毁存储池"><a href="#示例-5-4：创建和销毁存储池" class="headerlink" title="示例 5.4：创建和销毁存储池"></a>示例 5.4：创建和销毁存储池</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-4.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">xmlDesc = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;pool type=&#x27;dir&#x27;&gt;</span></span><br><span class="line"><span class="string">  &lt;name&gt;my-pool&lt;/name&gt;</span></span><br><span class="line"><span class="string">  &lt;uuid&gt;8c79f996-cb2a-d24d-9822-ac7547ab2d01&lt;/uuid&gt;</span></span><br><span class="line"><span class="string">  &lt;capacity unit=&#x27;bytes&#x27;&gt;4306780815&lt;/capacity&gt;</span></span><br><span class="line"><span class="string">  &lt;allocation unit=&#x27;bytes&#x27;&gt;237457858&lt;/allocation&gt;</span></span><br><span class="line"><span class="string">  &lt;available unit=&#x27;bytes&#x27;&gt;4069322956&lt;/available&gt;</span></span><br><span class="line"><span class="string">  &lt;source&gt;</span></span><br><span class="line"><span class="string">  &lt;/source&gt;</span></span><br><span class="line"><span class="string">  &lt;target&gt;</span></span><br><span class="line"><span class="string">    &lt;path&gt;/home/dashley/images&lt;/path&gt;</span></span><br><span class="line"><span class="string">    &lt;permissions&gt;</span></span><br><span class="line"><span class="string">      &lt;mode&gt;0755&lt;/mode&gt;</span></span><br><span class="line"><span class="string">      &lt;owner&gt;-1&lt;/owner&gt;</span></span><br><span class="line"><span class="string">      &lt;group&gt;-1&lt;/group&gt;</span></span><br><span class="line"><span class="string">    &lt;/permissions&gt;</span></span><br><span class="line"><span class="string">  &lt;/target&gt;</span></span><br><span class="line"><span class="string">&lt;/pool&gt;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个新的持久性存储池</span></span><br><span class="line">pool = conn.storagePoolDefineXML(xmlDesc, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> pool == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to create StoragePool object.&#x27;</span>, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 销毁存储池</span></span><br><span class="line">pool.undefine()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个新的非持久性存储池</span></span><br><span class="line">pool = conn.storagePoolCreateXML(xmlDesc, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> pool == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to create StoragePool object.&#x27;</span>, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 销毁存储池</span></span><br><span class="line">pool.undefine()</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="5-5-发现存储池源"><a href="#5-5-发现存储池源" class="headerlink" title="5.5 发现存储池源"></a>5.5 发现存储池源</h2><h3 id="示例-5-5：发现存储池的源"><a href="#示例-5-5：发现存储池的源" class="headerlink" title="示例 5.5：发现存储池的源"></a>示例 5.5：发现存储池的源</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-5.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"><span class="keyword">from</span> xml.dom <span class="keyword">import</span> minidom</span><br><span class="line"></span><br><span class="line">poolName = <span class="string">&#x27;default&#x27;</span></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">sp = conn.storagePoolLookupByName(poolName)</span><br><span class="line"><span class="keyword">if</span> sp == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to find storage pool &#x27;</span> + poolName, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">raw_xml = sp.XMLDesc(<span class="number">0</span>)</span><br><span class="line">xml = minidom.parseString(raw_xml)</span><br><span class="line"></span><br><span class="line">name = xml.getElementsByTagName(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;pool name: &#x27;</span> + poolName)</span><br><span class="line"></span><br><span class="line">spType = xml.getElementsByTagName(<span class="string">&#x27;source&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> spType <span class="keyword">in</span> spType:</span><br><span class="line">    attr = spType.getAttribute(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> attr != <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27; name = &#x27;</span> + attr)</span><br><span class="line">    attr = spType.getAttribute(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> attr != <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27; path = &#x27;</span> + attr)</span><br><span class="line">    attr = spType.getAttribute(<span class="string">&#x27;dir&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> attr != <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27; dir = &#x27;</span> + attr)</span><br><span class="line">    attr = spType.getAttribute(<span class="string">&#x27;type&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> attr != <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27; type = &#x27;</span> + attr)</span><br><span class="line">    attr = spType.getAttribute(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> attr != <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27; username = &#x27;</span> + attr)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="示例-5-6：演示-setAutostart-方法"><a href="#示例-5-6：演示-setAutostart-方法" class="headerlink" title="示例 5.6：演示 setAutostart 方法"></a>示例 5.6：演示 <code>setAutostart</code> 方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-6.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">poolName = <span class="string">&#x27;default&#x27;</span></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">sp = conn.storagePoolLookupByName(poolName)</span><br><span class="line"><span class="keyword">if</span> sp == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to find storage pool &#x27;</span> + poolName, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Current autostart setting: &#x27;</span> + <span class="built_in">str</span>(sp.autostart()))</span><br><span class="line"><span class="keyword">if</span> sp.autostart() == <span class="literal">True</span>:</span><br><span class="line">    sp.setAutostart(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    sp.setAutostart(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Current autostart setting: &#x27;</span> + <span class="built_in">str</span>(sp.autostart()))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="5-7-存储卷概述"><a href="#5-7-存储卷概述" class="headerlink" title="5.7 存储卷概述"></a>5.7 存储卷概述</h2><p>存储卷是满足客户域存储需求的基本存储单元。存储卷封装了用于容纳客户域的所有必要分区。存储卷又包含在存储池中。底层磁盘分区能容纳多少存储池，存储池就能容纳多少存储池。</p><p>存储卷 XML 格式在 <a href="https://libvirt.org/formatstorage.html#StorageVol">https://libvirt.org/formatstorage.html#StorageVol</a> 中指定。</p><h2 id="5-8-列出存储卷"><a href="#5-8-列出存储卷" class="headerlink" title="5.8 列出存储卷"></a>5.8 列出存储卷</h2><h3 id="示例-5-7：演示列出存储卷"><a href="#示例-5-7：演示列出存储卷" class="headerlink" title="示例 5.7：演示列出存储卷"></a>示例 5.7：演示列出存储卷</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-7.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"><span class="keyword">from</span> xml.dom <span class="keyword">import</span> minidom</span><br><span class="line"></span><br><span class="line">poolName = <span class="string">&quot;default&quot;</span></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">sp = conn.storagePoolLookupByName(poolName)</span><br><span class="line"><span class="keyword">if</span> sp == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to find storage pool &#x27;</span> + poolName, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">stgvols = sp.listVolumes()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Storage pool: &#x27;</span> + poolName)</span><br><span class="line"><span class="keyword">for</span> stgvol <span class="keyword">in</span> stgvols:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; Storage volume: &#x27;</span> + stgvol)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="5-9-存储卷信息"><a href="#5-9-存储卷信息" class="headerlink" title="5.9 存储卷信息"></a>5.9 存储卷信息</h2><h3 id="示例-5-8：列出存储卷信息"><a href="#示例-5-8：列出存储卷信息" class="headerlink" title="示例 5.8：列出存储卷信息"></a>示例 5.8：列出存储卷信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-8.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">pool = conn.storagePoolLookupByName(<span class="string">&#x27;default&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> pool == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to locate any StoragePool objects.&#x27;</span>, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">stgvols = pool.listVolumes()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Pool: &#x27;</span> + pool.name())</span><br><span class="line"><span class="keyword">for</span> stgvolname <span class="keyword">in</span> stgvols:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; volume: &#x27;</span> + stgvolname)</span><br><span class="line">    stgvol = pool.storageVolLookupByName(stgvolname)</span><br><span class="line">    info = stgvol.info()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; Type: &#x27;</span> + <span class="built_in">str</span>(info[<span class="number">0</span>]))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; Capacity: &#x27;</span> + <span class="built_in">str</span>(info[<span class="number">1</span>]))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; Allocation: &#x27;</span> + <span class="built_in">str</span>(info[<span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="5-10-创建和删除存储卷"><a href="#5-10-创建和删除存储卷" class="headerlink" title="5.10 创建和删除存储卷"></a>5.10 创建和删除存储卷</h2><h3 id="示例-5-9：创建存储卷"><a href="#示例-5-9：创建存储卷" class="headerlink" title="示例 5.9：创建存储卷"></a>示例 5.9：创建存储卷</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-9.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">stgvol_xml = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;volume&gt;</span></span><br><span class="line"><span class="string">  &lt;name&gt;sparse.img&lt;/name&gt;</span></span><br><span class="line"><span class="string">  &lt;allocation&gt;0&lt;/allocation&gt;</span></span><br><span class="line"><span class="string">  &lt;capacity unit=&quot;G&quot;&gt;2&lt;/capacity&gt;</span></span><br><span class="line"><span class="string">  &lt;target&gt;</span></span><br><span class="line"><span class="string">    &lt;path&gt;/var/lib/virt/images/sparse.img&lt;/path&gt;</span></span><br><span class="line"><span class="string">    &lt;permissions&gt;</span></span><br><span class="line"><span class="string">      &lt;owner&gt;107&lt;/owner&gt;</span></span><br><span class="line"><span class="string">      &lt;group&gt;107&lt;/group&gt;</span></span><br><span class="line"><span class="string">      &lt;mode&gt;0744&lt;/mode&gt;</span></span><br><span class="line"><span class="string">      &lt;label&gt;virt_image_t&lt;/label&gt;</span></span><br><span class="line"><span class="string">    &lt;/permissions&gt;</span></span><br><span class="line"><span class="string">  &lt;/target&gt;</span></span><br><span class="line"><span class="string">&lt;/volume&gt;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">pool = <span class="string">&#x27;default&#x27;</span></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">pool = conn.storagePoolLookupByName(pool)</span><br><span class="line"><span class="keyword">if</span> pool == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to locate any StoragePool objects.&#x27;</span>, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">stgvol = pool.createXML(stgvol_xml, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> stgvol == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to create a StorageVol object.&#x27;</span>, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除存储卷</span></span><br><span class="line"><span class="comment"># 从底层磁盘介质中物理移除存储卷</span></span><br><span class="line">stgvol.wipe(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 从逻辑上将存储卷从存储池中删除</span></span><br><span class="line">stgvol.delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="5-11-克隆存储卷"><a href="#5-11-克隆存储卷" class="headerlink" title="5.11 克隆存储卷"></a>5.11 克隆存储卷</h2><h3 id="示例-5-10：克隆现有存储卷"><a href="#示例-5-10：克隆现有存储卷" class="headerlink" title="示例 5.10：克隆现有存储卷"></a>示例 5.10：克隆现有存储卷</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-10.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">stgvol_xml = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;volume&gt;</span></span><br><span class="line"><span class="string">  &lt;name&gt;sparse.img&lt;/name&gt;</span></span><br><span class="line"><span class="string">  &lt;allocation&gt;0&lt;/allocation&gt;</span></span><br><span class="line"><span class="string">  &lt;capacity unit=&quot;G&quot;&gt;2&lt;/capacity&gt;</span></span><br><span class="line"><span class="string">  &lt;target&gt;</span></span><br><span class="line"><span class="string">    &lt;path&gt;/var/lib/virt/images/sparse.img&lt;/path&gt;</span></span><br><span class="line"><span class="string">    &lt;permissions&gt;</span></span><br><span class="line"><span class="string">      &lt;owner&gt;107&lt;/owner&gt;</span></span><br><span class="line"><span class="string">      &lt;group&gt;107&lt;/group&gt;</span></span><br><span class="line"><span class="string">      &lt;mode&gt;0744&lt;/mode&gt;</span></span><br><span class="line"><span class="string">      &lt;label&gt;virt_image_t&lt;/label&gt;</span></span><br><span class="line"><span class="string">    &lt;/permissions&gt;</span></span><br><span class="line"><span class="string">  &lt;/target&gt;</span></span><br><span class="line"><span class="string">&lt;/volume&gt;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">stgvol_xml2 = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;volume&gt;</span></span><br><span class="line"><span class="string">  &lt;name&gt;sparse2.img&lt;/name&gt;</span></span><br><span class="line"><span class="string">  &lt;allocation&gt;0&lt;/allocation&gt;</span></span><br><span class="line"><span class="string">  &lt;capacity unit=&quot;G&quot;&gt;2&lt;/capacity&gt;</span></span><br><span class="line"><span class="string">  &lt;target&gt;</span></span><br><span class="line"><span class="string">    &lt;path&gt;/var/lib/virt/images/sparse.img&lt;/path&gt;</span></span><br><span class="line"><span class="string">    &lt;permissions&gt;</span></span><br><span class="line"><span class="string">      &lt;owner&gt;107&lt;/owner&gt;</span></span><br><span class="line"><span class="string">      &lt;group&gt;107&lt;/group&gt;</span></span><br><span class="line"><span class="string">      &lt;mode&gt;0744&lt;/mode&gt;</span></span><br><span class="line"><span class="string">      &lt;label&gt;virt_image_t&lt;/label&gt;</span></span><br><span class="line"><span class="string">    &lt;/permissions&gt;</span></span><br><span class="line"><span class="string">  &lt;/target&gt;</span></span><br><span class="line"><span class="string">&lt;/volume&gt;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">pool = <span class="string">&#x27;default&#x27;</span></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">pool = conn.storagePoolLookupByName(pool)</span><br><span class="line"><span class="keyword">if</span> pool == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to locate any StoragePool objects.&#x27;</span>, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个新的存储卷</span></span><br><span class="line">stgvol = pool.createXML(stgvol_xml, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> stgvol == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to create a StorageVol object.&#x27;</span>, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在克隆现有存储卷</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;This could take some time...&#x27;</span>)</span><br><span class="line">stgvol2 = pool.createXMLFrom(stgvol_xml2, stgvol, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> stgvol2 == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to clone a StorageVol object.&#x27;</span>, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除克隆的存储卷</span></span><br><span class="line"><span class="comment"># 从底层磁盘介质中物理移除存储卷</span></span><br><span class="line">stgvol2.wipe(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 从逻辑上将存储卷从存储池中删除</span></span><br><span class="line">stgvol2.delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除存储卷</span></span><br><span class="line"><span class="comment"># 从底层磁盘介质中物理移除存储卷</span></span><br><span class="line">stgvol.wipe(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 从逻辑上将存储卷从存储池中删除</span></span><br><span class="line">stgvol.delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Libvirt-存储管理&quot;&gt;&lt;a href=&quot;#Libvirt-存储管理&quot; class=&quot;headerlink&quot; title=&quot;Libvirt 存储管理&quot;&gt;&lt;/a&gt;Libvirt 存储管理&lt;/h1&gt;&lt;p&gt;Libvirt 通过存储池和存储卷在物理主机上提供存储管理。</summary>
      
    
    
    
    <category term="云计算" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="libvirt" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/libvirt/"/>
    
    
    <category term="云计算" scheme="https://watsonlu6.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="libvirt" scheme="https://watsonlu6.github.io/tags/libvirt/"/>
    
  </entry>
  
  <entry>
    <title>4 libvirt客户域Domain</title>
    <link href="https://watsonlu6.github.io/libvirt%E6%96%87%E6%A1%A3/4-libvirt%E5%AE%A2%E6%88%B7%E5%9F%9FDomain/"/>
    <id>https://watsonlu6.github.io/libvirt%E6%96%87%E6%A1%A3/4-libvirt%E5%AE%A2%E6%88%B7%E5%9F%9FDomain/</id>
    <published>2024-03-04T07:50:26.000Z</published>
    <updated>2025-03-15T08:00:27.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="4-1-Domain-概述"><a href="#4-1-Domain-概述" class="headerlink" title="4.1 Domain 概述"></a>4.1 Domain 概述</h1><p>域是运行在虚拟化机器上的操作系统实例。一个客域可以指正在运行的虚拟机或可用于启动虚拟机的配置。连接对象提供了枚举客域、创建新客域和管理现有域的方法。客域由 <code>virDomainPtr</code> 对象表示，并具有多个唯一标识符：</p><h2 id="唯一标识符"><a href="#唯一标识符" class="headerlink" title="唯一标识符"></a>唯一标识符</h2><ul><li><p><strong>ID</strong>：正整数，在一台主机上运行的客户域中是唯一的。非活动域没有 ID。如果主机操作系统是虚拟域，默认情况下 ID 为 0。例如，在 Xen 虚拟机管理程序中，<strong>Dom0</strong> 表示访客域。其他域 ID 将从 1 开始分配，每次启动新域时都会递增。通常情况下，在整个 ID 空间被包围之前，域 ID 不会被重复使用。域 ID 空间的大小至少为 16 位，但通常会扩展到 32 位。</p></li><li><p><strong>name</strong>：短字符串，在一台主机上的所有客户域（包括运行中和非活动域）中都是唯一的。为了在不同管理程序之间实现最大的可移植性，应用程序只能在名称中使用 <strong>a-Z、0-9、-、_</strong> 字符。许多管理程序会根据域名将非活动域配置作为文件存储在磁盘上。</p></li><li><p><strong>UUID</strong>：16 个无符号字节，保证在任何主机上的所有客户域中都是唯一的。RFC 4122 定义了 UUID 的格式，并提供了生成具有唯一性的 UUID 的推荐算法。如果主机操作系统本身就是一个虚拟域，那么按照惯例，它将获得一个全为 0 的 UUID。Xen 虚拟机管理程序就是这种情况，其中 <strong>Dom0</strong> 本身就是一个客户域。</p></li></ul><p>客户域可以是短暂的，也可以是持久的。瞬时访客域只能在主机上运行时进行管理，关闭电源后，所有痕迹都会消失。持久客户域的配置由管理程序以实施定义的格式保存在主机上的数据存储中。因此，当持久客户机关闭电源时，仍可管理其非活动配置。通过为临时客户机定义配置，可以将其快速转变为持久客户机。</p><p>当应用程序获得域的唯一标识符后，通常会希望获取相应的 <strong>virDomain</strong> 对象。有三种方法可用于查找现有域，它们的名字很有想象力，分别是 <strong>lookupByID</strong>、<strong>lookupByName</strong> 和 <strong>lookupByUUID</strong>。每个方法都将域标识符作为参数。如果没有匹配的域存在，它们将返回 <strong>None</strong>。如果需要，可以查询错误对象，以查找错误的具体细节。</p><h3 id="例-4-1-从-ID-获取域对象"><a href="#例-4-1-从-ID-获取域对象" class="headerlink" title="例 4.1. 从 ID 获取域对象"></a>例 4.1. 从 ID 获取域对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-1.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">domainID = <span class="number">6</span></span><br><span class="line">dom = conn.lookupByID(domainID)</span><br><span class="line"><span class="keyword">if</span> dom == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to get the domain object&#x27;</span>, file=sys.stderr)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>需要注意的是，如果域未激活，<strong>lookupByID</strong> 方法将不起作用。非活动域的 ID 都是 <strong>-1</strong>。</p><h3 id="例-4-2-从名称中获取域对象"><a href="#例-4-2-从名称中获取域对象" class="headerlink" title="例 4.2. 从名称中获取域对象"></a>例 4.2. 从名称中获取域对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-2.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">domainName = <span class="string">&#x27;someguest&#x27;</span></span><br><span class="line">dom = conn.lookupByName(domainName)</span><br><span class="line"><span class="keyword">if</span> dom == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to get the domain object&#x27;</span>, file=sys.stderr)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="例-4-3-从-UUID-获取域对象"><a href="#例-4-3-从-UUID-获取域对象" class="headerlink" title="例 4.3. 从 UUID 获取域对象"></a>例 4.3. 从 UUID 获取域对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-3.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">domainUUID = <span class="string">&quot;00311636-7767-71d2-e94a-26e7b8bad250&quot;</span></span><br><span class="line">dom = conn.lookupByUUID(domainUUID)</span><br><span class="line"><span class="keyword">if</span> dom == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to get the domain object&#x27;</span>, file=sys.stderr)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>上面的 UUID 示例使用的是 UUID 的可打印格式。Python 不支持使用等价的原始字节。</p><h1 id="列举-Domains"><a href="#列举-Domains" class="headerlink" title="列举 Domains"></a>列举 Domains</h1><p>libvirt 类公开了两个域列表，第一个列表包含运行中的域，第二个列表包含非活动的持久域。这两个列表是互不重叠的排他性集合，但在每个集合的查询过程中，域停止或启动的可能性很小。本节后面描述的事件类提供了一种跟踪所有生命周期变化的方法，可以避免这种潜在的竞赛条件。</p><p>该方法用于列出活动域，返回域 ID 列表。每个运行中的域都有一个正整数 ID，在主机上所有运行中的域中唯一标识。列出活动域的方法 <strong>listDomainsID</strong> 不需要任何参数。如果出错，返回值将是 <strong>None</strong>，或者是以 <strong>ints</strong> 表示的 ID 的 Python 列表。</p><h3 id="例-4-4-列出活动域"><a href="#例-4-4-列出活动域" class="headerlink" title="例 4.4. 列出活动域"></a>例 4.4. 列出活动域</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-4.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">domainIDs = conn.listDomainsID()</span><br><span class="line"><span class="keyword">if</span> domainIDs == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to get a list of domain IDs&#x27;</span>, file=sys.stderr)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Active domain IDs:&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(domainIDs) == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;None&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">for</span> domainID <span class="keyword">in</span> domainIDs:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span> + <span class="built_in">str</span>(domainID))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>除了运行中的域外，主机上还可能存储有一些持久的非活动域配置。由于非活动域没有任何 ID 标识符，因此非活动域列表将以名称字符串列表的形式显示。如果出错，返回值将是 <strong>None</strong>，或者是一个由名称（字符串）填充的 Python 元素列表。</p><h3 id="例-4-5-列出非活动域"><a href="#例-4-5-列出非活动域" class="headerlink" title="例 4.5. 列出非活动域"></a>例 4.5. 列出非活动域</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-5.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">domainNames = conn.listDefinedDomains()</span><br><span class="line"><span class="keyword">if</span> domainNames == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to get a list of domain names&#x27;</span>, file=sys.stderr)</span><br><span class="line"></span><br><span class="line">domainIDs = conn.listDomainsID()</span><br><span class="line"><span class="keyword">if</span> domainIDs == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to get a list of domain IDs&#x27;</span>, file=sys.stderr)</span><br><span class="line"></span><br><span class="line">domainNames = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(domainIDs) != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> domainID <span class="keyword">in</span> domainIDs:</span><br><span class="line">            domain = conn.lookupByID(domainID)</span><br><span class="line">            domainNames.append(domain.name)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    conn.close()</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;All (active and inactive domain names:&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(domainNames) == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">for</span> domainName <span class="keyword">in</span> domainNames:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span> + domainName)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>列出域的方法不会直接返回 <strong>virDomain</strong> 对象，因为这可能会给希望频繁查询域列表的应用程序带来不必要的性能损失。不过，Python libvirt 模块提供了 <strong>listAllDomains</strong> 方法，该方法可列出所有活动或非活动域。该方法会返回一个 <strong>virDomain</strong> 实例的 Python 列表，如果出错则返回 <strong>None</strong>。当没有持久域存在时，列表可能为空。</p><h3 id="例-4-6-获取所有域对象"><a href="#例-4-6-获取所有域对象" class="headerlink" title="例 4.6. 获取所有域对象"></a>例 4.6. 获取所有域对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-6.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;All (active and inactive) domain names:&quot;</span>)</span><br><span class="line">domains = conn.listAllDomains(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(domains) != <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">for</span> domain <span class="keyword">in</span> domains:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span> + domain.name())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;None&quot;</span>)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h1 id="4-3-获取域名的状态信息"><a href="#4-3-获取域名的状态信息" class="headerlink" title="4.3 获取域名的状态信息"></a>4.3 获取域名的状态信息</h1><p>获得域实例后，就可以获取有关域状态的信息。这些信息包括托管的操作系统类型、运行状态、ID、UUID 等。以下方法将演示如何获取这些信息。</p><h2 id="获取域的-ID"><a href="#获取域的-ID" class="headerlink" title="获取域的 ID"></a>获取域的 ID</h2><p>使用 <strong>ID</strong> 方法可以获取域的 ID。只有运行中的域才有 ID，获取非运行中域的 ID 总是返回 <strong>-1</strong>。</p><h3 id="例-4-7-获取域的-ID"><a href="#例-4-7-获取域的-ID" class="headerlink" title="例 4.7. 获取域的 ID"></a>例 4.7. 获取域的 ID</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-43.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"><span class="keyword">from</span> xml.dom <span class="keyword">import</span> minidom</span><br><span class="line"></span><br><span class="line">domName = <span class="string">&#x27;Cent0S7&#x27;</span></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dom = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    dom = conn.lookupByName(domName)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">id</span> = dom.ID()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">id</span> == -<span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The domain is not running so has no ID.&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The ID of the domain is &#x27;</span> + <span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="获取域的-UUID"><a href="#获取域的-UUID" class="headerlink" title="获取域的 UUID"></a>获取域的 UUID</h2><p>域的 UUID 可以通过 <strong>UUID</strong> 或 <strong>UUIDString</strong> 方法获得。<strong>UUID</strong> 方法对 Python 程序并不十分有用，因为它是一个二进制值。<strong>UUIDString 方法</strong>则有用得多，因为它返回的是一个格式化的字符串值，可以很容易地进行解析。</p><p>UUID 与域的运行状态无关，并始终返回一个有效的 UUID。</p><h3 id="例-4-8-获取域的-UUID"><a href="#例-4-8-获取域的-UUID" class="headerlink" title="例 4.8. 获取域的 UUID"></a>例 4.8. 获取域的 UUID</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-44.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"><span class="keyword">from</span> xml.dom <span class="keyword">import</span> minidom</span><br><span class="line"></span><br><span class="line">domName = <span class="string">&#x27;Cent0S7&#x27;</span></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dom = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    dom = conn.lookupByName(domName)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">uuid = dom.UUIDString()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The UUID of the domain is &#x27;</span> + uuid)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="获取域的操作系统类型"><a href="#获取域的操作系统类型" class="headerlink" title="获取域的操作系统类型"></a>获取域的操作系统类型</h2><p>域托管的操作系统类型也可用。只有运行中的域才有 ID，获取非运行中域的 ID 总是返回 <strong>-1</strong>。同样的信息也可以通过 <em>info</em> 方法获取。</p><h3 id="例-4-9-获取域的-ID"><a href="#例-4-9-获取域的-ID" class="headerlink" title="例 4.9. 获取域的 ID"></a>例 4.9. 获取域的 ID</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-45.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"><span class="keyword">from</span> xml.dom <span class="keyword">import</span> minidom</span><br><span class="line"></span><br><span class="line">domName = <span class="string">&#x27;Cent0S7&#x27;</span></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dom = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    dom = conn.lookupByName(domName)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> = dom.OSType()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The OS type of the domain is &quot;&#x27;</span> + <span class="built_in">type</span> + <span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="确定域是否有当前快照"><a href="#确定域是否有当前快照" class="headerlink" title="确定域是否有当前快照"></a>确定域是否有当前快照</h2><p><strong>hasCurrentSnapshot</strong> 方法返回一个布尔值，表示当前快照是否可用。该方法始终返回有效值，且不依赖于域的运行状态。</p><h3 id="例-4-10-确定域是否有当前快照"><a href="#例-4-10-确定域是否有当前快照" class="headerlink" title="例 4.10. 确定域是否有当前快照"></a>例 4.10. 确定域是否有当前快照</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-47.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"><span class="keyword">from</span> xml.dom <span class="keyword">import</span> minidom</span><br><span class="line"></span><br><span class="line">domName = <span class="string">&#x27;Cent0S7&#x27;</span></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dom = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    dom = conn.lookupByName(domName)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">flag = dom.hasCurrentSnapshot()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The value of the current snapshot flag is &#x27;</span> + <span class="built_in">str</span>(flag))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="确定域是否已管理保存镜像"><a href="#确定域是否已管理保存镜像" class="headerlink" title="确定域是否已管理保存镜像"></a>确定域是否已管理保存镜像</h2><p><strong>hasManagedSaveImages</strong> 方法返回一个布尔值，表示域是否有托管的保存镜像。请注意，运行中的域不应该有已保存的镜像，因为该镜像应在重启域时删除。</p><h3 id="例-4-11-确定域是否有托管保存镜像"><a href="#例-4-11-确定域是否有托管保存镜像" class="headerlink" title="例 4.11. 确定域是否有托管保存镜像"></a>例 4.11. 确定域是否有托管保存镜像</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-48.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"><span class="keyword">from</span> xml.dom <span class="keyword">import</span> minidom</span><br><span class="line"></span><br><span class="line">domName = <span class="string">&#x27;Cent0S7&#x27;</span></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dom = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    dom = conn.lookupByName(domName)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">flag = dom.hasManagedSaveImage()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The value of the managed save images flag is &#x27;</span> + <span class="built_in">str</span>(flag))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="获取域名的主机名"><a href="#获取域名的主机名" class="headerlink" title="获取域名的主机名"></a>获取域名的主机名</h2><p><strong>hostname</strong> 方法返回域的主机名。</p><p><strong>hostname</strong> 方法高度依赖于管理程序和&#x2F;或 qemu-guest-agent。如果该方法无法成功完成，可能会出错。</p><h3 id="例-4-12-获取域的主机名"><a href="#例-4-12-获取域的主机名" class="headerlink" title="例 4.12. 获取域的主机名"></a>例 4.12. 获取域的主机名</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-49.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"><span class="keyword">from</span> xml.dom <span class="keyword">import</span> minidom</span><br><span class="line"></span><br><span class="line">domName = <span class="string">&#x27;Cent0S7&#x27;</span></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dom = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    dom = conn.lookupByName(domName)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">name = dom.hostname()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The hostname of the domain is &#x27;</span> + <span class="built_in">str</span>(name))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="获取网域硬件信息"><a href="#获取网域硬件信息" class="headerlink" title="获取网域硬件信息"></a>获取网域硬件信息</h2><p><strong>info</strong> 方法会返回域硬件的一些常规信息。在 Python 列表中应返回八个条目，包括域的状态、最大内存、内存、cpus 和 cpu 时间。</p><h3 id="例-4-13-获取域名信息"><a href="#例-4-13-获取域名信息" class="headerlink" title="例 4.13. 获取域名信息"></a>例 4.13. 获取域名信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-50.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"><span class="keyword">from</span> xml.dom <span class="keyword">import</span> minidom</span><br><span class="line"></span><br><span class="line">domName = <span class="string">&#x27;Cent0S7&#x27;</span></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dom = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    dom = conn.lookupByName(domName)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">state, maxmem, mem, cpus, cput = dom.info()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The state is &#x27;</span> + <span class="built_in">str</span>(state))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The max memory is &#x27;</span> + <span class="built_in">str</span>(maxmem))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The memory is &#x27;</span> + <span class="built_in">str</span>(mem))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The number of cpus is &#x27;</span> + <span class="built_in">str</span>(cpus))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The cpu time is &#x27;</span> + <span class="built_in">str</span>(cput))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="确定网域是否正在运行"><a href="#确定网域是否正在运行" class="headerlink" title="确定网域是否正在运行"></a>确定网域是否正在运行</h2><p><strong>isActive</strong> 方法返回一个布尔标志，表示域是否处于活动（运行）状态。</p><h3 id="例-4-14-确定网域是否正在运行"><a href="#例-4-14-确定网域是否正在运行" class="headerlink" title="例 4.14. 确定网域是否正在运行"></a>例 4.14. 确定网域是否正在运行</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-51.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"><span class="keyword">from</span> xml.dom <span class="keyword">import</span> minidom</span><br><span class="line"></span><br><span class="line">domName = <span class="string">&#x27;Cent0S7&#x27;</span></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dom = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    dom = conn.lookupByName(domName)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">flag = dom.isActive()</span><br><span class="line"><span class="keyword">if</span> flag == <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The domain is active.&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The domain is not active.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="确定网域是否具有持久性"><a href="#确定网域是否具有持久性" class="headerlink" title="确定网域是否具有持久性"></a>确定网域是否具有持久性</h2><p><strong>isPersistent</strong> 方法返回一个布尔标志，表示域是否持久（重启后域将持久）。</p><h3 id="例-4-15-确定域是否持久"><a href="#例-4-15-确定域是否持久" class="headerlink" title="例 4.15. 确定域是否持久"></a>例 4.15. 确定域是否持久</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-52.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"><span class="keyword">from</span> xml.dom <span class="keyword">import</span> minidom</span><br><span class="line"></span><br><span class="line">domName = <span class="string">&#x27;Cent0S7&#x27;</span></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dom = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    dom = conn.lookupByName(domName)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">flag = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    flag = dom.isPersistent()</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    conn.close()</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The domain is persistent.&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> flag == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The domain is not persistent.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="确定网域是否已更新"><a href="#确定网域是否已更新" class="headerlink" title="确定网域是否已更新"></a>确定网域是否已更新</h2><p><strong>isUpdated</strong> 方法返回一个布尔标志，表示域自创建以来是否更新过。</p><h3 id="例-4-16-确定域是否已更新"><a href="#例-4-16-确定域是否已更新" class="headerlink" title="例 4.16. 确定域是否已更新"></a>例 4.16. 确定域是否已更新</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-58.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"><span class="keyword">from</span> xml.dom <span class="keyword">import</span> minidom</span><br><span class="line"></span><br><span class="line">domName = <span class="string">&#x27;Cent0S7&#x27;</span></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dom = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    dom = conn.lookupByName(domName)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">flag = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    flag = dom.isUpdated()</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    conn.close()</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The domain is updated.&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> flag == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The domain is not updated.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="确定域的最大内存"><a href="#确定域的最大内存" class="headerlink" title="确定域的最大内存"></a>确定域的最大内存</h2><p><strong>maxMemory</strong> 方法返回分配给域的最大内存。</p><h3 id="例-4-17-确定域的最大内存"><a href="#例-4-17-确定域的最大内存" class="headerlink" title="例 4.17. 确定域的最大内存"></a>例 4.17. 确定域的最大内存</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-53.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"><span class="keyword">from</span> xml.dom <span class="keyword">import</span> minidom</span><br><span class="line"></span><br><span class="line">domName = <span class="string">&#x27;Cent0S7&#x27;</span></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dom = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    dom = conn.lookupByName(domName)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">mem = dom.maxMemory()</span><br><span class="line"><span class="keyword">if</span> mem <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The max memory for domain is &#x27;</span> + <span class="built_in">str</span>(mem) + <span class="string">&#x27;MB&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;There was an error.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="确定网域的最大-Vcpus"><a href="#确定网域的最大-Vcpus" class="headerlink" title="确定网域的最大 Vcpus"></a>确定网域的最大 Vcpus</h2><p><strong>maxVcpus</strong> 方法返回分配给域的虚拟 CPU 的最大数量。</p><h3 id="例-4-18-确定域的最大-Vcpus"><a href="#例-4-18-确定域的最大-Vcpus" class="headerlink" title="例 4.18. 确定域的最大 Vcpus"></a>例 4.18. 确定域的最大 Vcpus</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-54.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"><span class="keyword">from</span> xml.dom <span class="keyword">import</span> minidom</span><br><span class="line"></span><br><span class="line">domName = <span class="string">&#x27;Cent0S7&#x27;</span></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dom = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    dom = conn.lookupByName(domName)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">cpus = dom.maxVcpus()</span><br><span class="line"><span class="keyword">if</span> cpus != -<span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The max Vcpus for domain is &#x27;</span> + <span class="built_in">str</span>(cpus))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;There was an error.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="获取网域名称"><a href="#获取网域名称" class="headerlink" title="获取网域名称"></a>获取网域名称</h2><p><strong>name</strong> 方法返回域名的名称。</p><h3 id="例-4-19-获取网域名称"><a href="#例-4-19-获取网域名称" class="headerlink" title="例 4.19. 获取网域名称"></a>例 4.19. 获取网域名称</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-55.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"><span class="keyword">from</span> xml.dom <span class="keyword">import</span> minidom</span><br><span class="line"></span><br><span class="line">domName = <span class="string">&#x27;Cent0S7&#x27;</span></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dom = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    dom = conn.lookupByName(domName)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">name = dom.name()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The name of the domain is &quot;&#x27;</span> + name + <span class="string">&#x27;&quot;.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="获取域的状态"><a href="#获取域的状态" class="headerlink" title="获取域的状态"></a>获取域的状态</h2><p><strong>状态</strong> 方法返回域的状态。</p><h3 id="例-4-20-获取域的状态"><a href="#例-4-20-获取域的状态" class="headerlink" title="例 4.20. 获取域的状态"></a>例 4.20. 获取域的状态</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-56.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"><span class="keyword">from</span> xml.dom <span class="keyword">import</span> minidom</span><br><span class="line"></span><br><span class="line">domName = <span class="string">&#x27;Cent0S7&#x27;</span></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dom = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    dom = conn.lookupByName(domName)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">state, reason = dom.state()</span><br><span class="line"><span class="keyword">if</span> state == libvirt.VIR_DOMAIN_NOSTATE:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The state is VIR_DOMAIN_NOSTATE&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> state == libvirt.VIR_DOMAIN_RUNNING:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The state is VIR_DOMAIN_RUNNING&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> state == libvirt.VIR_DOMAIN_BLOCKED:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The state is VIR_DOMAIN_BLOCKED&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> state == libvirt.VIR_DOMAIN_PAUSED:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The state is VIR_DOMAIN_PAUSED&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> state == libvirt.VIR_DOMAIN_SHUTDOWN:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The state is VIR_DOMAIN_SHUTDOWN&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> state == libvirt.VIR_DOMAIN_SHUTOFF:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The state is VIR_DOMAIN_SHUTOFF&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> state == libvirt.VIR_DOMAIN_CRASHED:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The state is VIR_DOMAIN_CRASHED&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> state == libvirt.VIR_DOMAIN_PMSUSPENDED:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The state is VIR_DOMAIN_PMSUSPENDED&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The state is unknown&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The reason code is &#x27;</span> + <span class="built_in">str</span>(reason))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="从域中提取时间信息"><a href="#从域中提取时间信息" class="headerlink" title="从域中提取时间信息"></a>从域中提取时间信息</h2><p><strong>getTime</strong> 方法从域中提取当前时间戳。该方法返回与 Python <strong>time.struct_time</strong> 函数相同的值。</p><h3 id="例-4-21-获取域的状态"><a href="#例-4-21-获取域的状态" class="headerlink" title="例 4.21. 获取域的状态"></a>例 4.21. 获取域的状态</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-57.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys, time</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"><span class="keyword">from</span> xml.dom <span class="keyword">import</span> minidom</span><br></pre></td></tr></table></figure><h1 id="抵御主机重启"><a href="#抵御主机重启" class="headerlink" title="抵御主机重启"></a>抵御主机重启</h1><p>抵御主机重启，而不会认为自己已经重启。libvirt 重启后，访客域将自动恢复。由于 libvirt 必须知道路径而无需用户输入，因此这将由独立于常规保存和还原的 API 来处理。</p><h3 id="例-4-34-为域设置自动启动"><a href="#例-4-34-为域设置自动启动" class="headerlink" title="例 4.34. 为域设置自动启动"></a>例 4.34. 为域设置自动启动</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-25.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">domName = <span class="string">&#x27;Fedora22-x86_64-1&#x27;</span></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dom = conn.lookupByID(<span class="number">6</span>)</span><br><span class="line"><span class="keyword">if</span> dom == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to find the domain &#x27;</span> + domName, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dom.setAutostart(<span class="number">1</span>)  <span class="comment"># 打开自动启动</span></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h1 id="网域配置"><a href="#网域配置" class="headerlink" title="网域配置"></a>网域配置</h1><p>libvirt 中使用 XML 定义域。与域相关的所有内容（如内存和 CPU）都在域 XML 中定义。域 XML 格式指定在 <a href="http://libvirt.org/"><em>http://libvirt.org/</em></a> <em>formatdomain.html</em>。可在本地访问 <strong>&#x2F;usr&#x2F;share&#x2F;doc&#x2F;libvirt-devel-version&#x2F;</strong> 如果系统已安装 <em>libvirt-devel</em> 软件包。</p><p>访客域的配置信息可通过 <strong>XMLDesc</strong> 方法获取。该方法以 XML 数据流的形式返回域的当前描述。然后可以对该数据流进行解析，以获取有关域和构成域的所有部分的详细信息。</p><p>flags 参数可包含以下任意常数：</p><ul><li>VIR_DOMAIN_XML_SECURE</li><li>VIR_DOMAIN_XML_INACTIVE</li><li>VIR_DOMAIN_XML_UPDATE_CPU</li><li>VIR_DOMAIN_XML_MIGRATABLE</li></ul><h3 id="例-4-35-从域的-XML-描述中获取基本域信息"><a href="#例-4-35-从域的-XML-描述中获取基本域信息" class="headerlink" title="例 4.35. 从域的 XML 描述中获取基本域信息"></a>例 4.35. 从域的 XML 描述中获取基本域信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-36.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"><span class="keyword">from</span> xml.dom <span class="keyword">import</span> minidom</span><br><span class="line"></span><br><span class="line">domName = <span class="string">&#x27;Fedora22-x86_64-1&#x27;</span></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dom = conn.lookupByID(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span> dom == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to find the domain &#x27;</span> + domName, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">raw_xml = dom.XMLDesc(<span class="number">0</span>)</span><br><span class="line">xml = minidom.parseString(raw_xml)</span><br><span class="line">domainTypes = xml.getElementsByTagName(<span class="string">&#x27;type&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> domainType <span class="keyword">in</span> domainTypes:</span><br><span class="line">    <span class="built_in">print</span>(domainType.getAttribute(<span class="string">&#x27;machine&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(domainType.getAttribute(<span class="string">&#x27;arch&#x27;</span>))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="Emulator"><a href="#Emulator" class="headerlink" title="Emulator"></a>Emulator</h2><p>要发现访客域的模拟器，请查找并显示模拟器 XML 标记的内容。</p><h3 id="例-4-36-获取域的模拟器信息"><a href="#例-4-36-获取域的模拟器信息" class="headerlink" title="例 4.36. 获取域的模拟器信息"></a>例 4.36. 获取域的模拟器信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-37.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"><span class="keyword">from</span> xml.dom <span class="keyword">import</span> minidom</span><br><span class="line"></span><br><span class="line">domName = <span class="string">&#x27;Fedora22-x86_64-1&#x27;</span></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dom = conn.lookupByID(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span> dom == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to find the domain &#x27;</span> + domName, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">raw_xml = dom.XMLDesc(<span class="number">0</span>)</span><br><span class="line">xml = minidom.parseString(raw_xml)</span><br><span class="line">domainEmulator = xml.getElementsByTagName(<span class="string">&#x27;emulator&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;emulator: &#x27;</span> + domainEmulator[<span class="number">0</span>].firstChild.data)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>仿真器的 XML 配置通常如下：</p><h3 id="例-4-37-域仿真器-XML-信息"><a href="#例-4-37-域仿真器-XML-信息" class="headerlink" title="例 4.37. 域仿真器 XML 信息"></a>例 4.37. 域仿真器 XML 信息</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">domain</span> <span class="attr">type</span>=<span class="string">&#x27;kvm&#x27;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">emulator</span>&gt;</span>/usr/libexec/qemu-kvm<span class="tag">&lt;/<span class="name">emulator</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h2><p>通过 BIOS 启动适用于支持完全虚拟化的管理程序。在这种情况下，BIOS 有一个启动顺序优先级（软盘、硬盘、cdrom、网络），决定从哪里获取&#x2F;查找启动映像。</p><h3 id="例-4-38-设置启动模式"><a href="#例-4-38-设置启动模式" class="headerlink" title="例 4.38. 设置启动模式"></a>例 4.38. 设置启动模式</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">domain</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>HVM<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">loader</span> <span class="attr">readonly</span>=<span class="string">&#x27;yes&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;rom&#x27;</span>&gt;</span>/usr/lib/xen/boot/hvmloader<span class="tag">&lt;/<span class="name">loader</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">nvram</span> <span class="attr">template</span>=<span class="string">&#x27;/usr/share/OVMF/OVMF_VARS.fd&#x27;</span>&gt;</span>/var/lib/libvirt/nvram/guest_VARS.fd<span class="tag">&lt;/<span class="name">nvram</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">boot</span> <span class="attr">dev</span>=<span class="string">&#x27;hd&#x27;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">boot</span> <span class="attr">dev</span>=<span class="string">&#x27;cdrom&#x27;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bootmenu</span> <span class="attr">enable</span>=<span class="string">&#x27;yes&#x27;</span> <span class="attr">timeout</span>=<span class="string">&#x27;3000&#x27;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">smbios</span> <span class="attr">mode</span>=<span class="string">&#x27;sysinfo&#x27;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bios</span> <span class="attr">useserial</span>=<span class="string">&#x27;yes&#x27;</span> <span class="attr">rebootTimeout</span>=<span class="string">&#x27;0&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="内存和-CPU-资源"><a href="#内存和-CPU-资源" class="headerlink" title="内存和 CPU 资源"></a>内存和 CPU 资源</h2><p>CPU 和内存资源可以在创建域时设置，也可以在域处于活动或非活动状态时动态设置。</p><p>CPU 资源是在创建域时使用 XML 定义中的标记设置的。管理程序定义了虚拟 CPU 的数量限制，无论是在创建域时还是以后都不能超过。这个最大值可能取决于许多资源和管理程序限制。下面是 CPU XML 规范的示例。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">domain</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">vcpu</span> <span class="attr">placement</span>=<span class="string">&#x27;static&#x27;</span> <span class="attr">cpuset</span>=<span class="string">&quot;1-4,^3,6&quot;</span> <span class="attr">current</span>=<span class="string">&quot;1&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">vcpu</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br></pre></td></tr></table></figure><p>内存资源也可在创建域时使用 XML 定义中的标记进行设置。域的最大内存分配和当前内存分配都应设置。内存 XML 规范示例如下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">domain</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">maxMemory</span> <span class="attr">slots</span>=<span class="string">&#x27;16&#x27;</span> <span class="attr">unit</span>=<span class="string">&#x27;KiB&#x27;</span>&gt;</span>1524288<span class="tag">&lt;/<span class="name">maxMemory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">memory</span> <span class="attr">unit</span>=<span class="string">&#x27;KiB&#x27;</span>&gt;</span>524288<span class="tag">&lt;/<span class="name">memory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">currentMemory</span> <span class="attr">unit</span>=<span class="string">&#x27;KiB&#x27;</span>&gt;</span>524288<span class="tag">&lt;/<span class="name">currentMemory</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br></pre></td></tr></table></figure><p>域创建后，可通过 <strong>setVcpus</strong> 或 <strong>setVcpusFlags</strong> 方法增加虚拟 CPU 的数量。CPU 数量不得超过上文讨论的管理程序最大值。</p><h3 id="例-4-39-设置域的最大虚拟-CPU-数量"><a href="#例-4-39-设置域的最大虚拟-CPU-数量" class="headerlink" title="例 4.39. 设置域的最大虚拟 CPU 数量"></a>例 4.39. 设置域的最大虚拟 CPU 数量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-29.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">domName = <span class="string">&#x27;Fedora22-x86_64-1&#x27;</span></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dom = conn.lookupByID(<span class="number">6</span>)</span><br><span class="line"><span class="keyword">if</span> dom == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to find the domain &#x27;</span> + domName, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dom.setVcpus(<span class="number">2</span>)</span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>创建域后，还可以通过 <strong>setMemory</strong> 或 <strong>setMemoryFlags</strong> 方法更改内存大小。内存大小应以千字节为单位。</p><h3 id="例-4-40-设置域的内存量"><a href="#例-4-40-设置域的内存量" class="headerlink" title="例 4.40. 设置域的内存量"></a>例 4.40. 设置域的内存量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-30.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">domName = <span class="string">&#x27;Fedora22-x86_64-1&#x27;</span></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dom = conn.lookupByID(<span class="number">6</span>)</span><br><span class="line"><span class="keyword">if</span> dom == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to find the domain &#x27;</span> + domName, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dom.setMemory(<span class="number">4096</span>)  <span class="comment"># 4 GigaBytes</span></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>除了 <strong>setMemory</strong> 方法外，还有另一种方法 <strong>setMemoryFlags</strong>。</p><h1 id="监测性能"><a href="#监测性能" class="headerlink" title="监测性能"></a>监测性能</h1><p>统计指标可用于监控域、vCPU、内存、块设备和网络接口的利用率。</p><h2 id="域块设备性能"><a href="#域块设备性能" class="headerlink" title="域块设备性能"></a>域块设备性能</h2><p><strong>blockStats</strong> 方法提供了磁盘使用统计信息：</p><h3 id="例-4-41-获取磁盘块-I-O-统计信息"><a href="#例-4-41-获取磁盘块-I-O-统计信息" class="headerlink" title="例 4.41. 获取磁盘块 I&#x2F;O 统计信息"></a>例 4.41. 获取磁盘块 I&#x2F;O 统计信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-31.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">domName = <span class="string">&#x27;Fedora22-x86_64-1&#x27;</span></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dom = conn.lookupByID(<span class="number">6</span>)</span><br><span class="line"><span class="keyword">if</span> dom == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to find the domain &#x27;</span> + domName, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">rd_req, rd_bytes, wr_req, wr_bytes, err = dom.blockStats(<span class="string">&#x27;/path/to/linux-0.2.img&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Read requests issued: &#x27;</span> + <span class="built_in">str</span>(rd_req))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Bytes read: &#x27;</span> + <span class="built_in">str</span>(rd_bytes))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Write requests issued: &#x27;</span> + <span class="built_in">str</span>(wr_req))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;写入字节数: &#x27;</span> + <span class="built_in">str</span>(wr_bytes))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;错误次数: &#x27;</span> + <span class="built_in">str</span>(err))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>返回的元组包含发出的读（写）请求数和实际传输的字节数。块设备由映像文件路径或域 XML 中的 devices&#x2F;disk&#x2F;target[@dev] 元素设置的设备总线名称指定。</p><p>除了 <strong>blockStats</strong> 方法外，还有 <strong>blockStatsFlags</strong> 备选方法。</p><h2 id="vCPU-性能"><a href="#vCPU-性能" class="headerlink" title="vCPU 性能"></a>vCPU 性能</h2><p>要获取单个 VCPU 统计数据，请使用 <strong>getCPUStats</strong> 方法。</p><h3 id="例-4-42-获取单个-CPU-统计数据"><a href="#例-4-42-获取单个-CPU-统计数据" class="headerlink" title="例 4.42. 获取单个 CPU 统计数据"></a>例 4.42. 获取单个 CPU 统计数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-33.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">domName = <span class="string">&#x27;Fedora22-x86_64-1&#x27;</span></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dom = conn.lookupByID(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span> dom == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to find the domain &#x27;</span> + domName, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">cpu_stats = dom.getCPUStats(<span class="literal">False</span>)</span><br><span class="line"><span class="keyword">for</span> (i, cpu) <span class="keyword">in</span> <span class="built_in">enumerate</span>(cpu_stats):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;CPU &#x27;</span> + <span class="built_in">str</span>(i) + <span class="string">&#x27; Time: &#x27;</span> + <span class="built_in">str</span>(cpu[<span class="string">&#x27;cpu_time&#x27;</span>] / <span class="number">1000000000.</span>))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><strong>getCPUStats</strong> 使用一个布尔参数。当使用 <strong>True</strong> 时，报告的统计数据是所有 CPU 的总和。如果使用 <strong>False</strong>，则每个 CPU 都会报告各自的统计数据。无论采用哪种方式，都会返回一个<strong>列表</strong>。统计数据以纳秒为单位报告。如果一台主机有四个 CPU，cpu_stats 列表中就会有四个条目。</p><p><strong>getCPUStats(True)</strong> 汇集主机上所有 CPU 的统计数据：</p><h3 id="例-4-43-获取-CPU-综合统计数据"><a href="#例-4-43-获取-CPU-综合统计数据" class="headerlink" title="例 4.43. 获取 CPU 综合统计数据"></a>例 4.43. 获取 CPU 综合统计数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-34.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">domName = <span class="string">&#x27;Fedora22-x86_64-1&#x27;</span></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dom = conn.lookupByID(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span> dom == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to find the domain &#x27;</span> + domName, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">stats = dom.getCPUStats(<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;cpu_time: &#x27;</span> + <span class="built_in">str</span>(stats[<span class="number">0</span>][<span class="string">&#x27;cpu_time&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;system_time: &#x27;</span> + <span class="built_in">str</span>(stats[<span class="number">0</span>][<span class="string">&#x27;system_time&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;user_time: &#x27;</span> + <span class="built_in">str</span>(stats[<span class="number">0</span>][<span class="string">&#x27;user_time&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="内存统计"><a href="#内存统计" class="headerlink" title="内存统计"></a>内存统计</h2><p>要获取域当前使用的内存量，可以使用 <strong>memoryStats</strong> 方法。</p><h3 id="例-4-44-获取内存统计信息"><a href="#例-4-44-获取内存统计信息" class="headerlink" title="例 4.44. 获取内存统计信息"></a>例 4.44. 获取内存统计信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-35.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">domName = <span class="string">&#x27;Fedora22-x86_64-1&#x27;</span></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dom = conn.lookupByID(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span> dom == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to find the domain &#x27;</span> + domName, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">stats = dom.memoryStats()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;memory used:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> stats:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span> + <span class="built_in">str</span>(stats[name]) + <span class="string">&#x27; (&#x27;</span> + name + <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>请注意，<strong>memoryStats</strong> 返回的是一个字典对象。根据管理程序和客户域的功能，该对象将包含数量不等的条目。</p><h2 id="网络-I-O-统计数据"><a href="#网络-I-O-统计数据" class="headerlink" title="网络 I&#x2F;O 统计数据"></a>网络 I&#x2F;O 统计数据</h2><p>要获取网络统计信息，需要域所连接主机接口的名称（通常为 vnetX）。要找到它，请检索域 XML 描述（libvirt 会在运行时修改它）。然后，查找 devices&#x2F;interface&#x2F;target[@dev] 元素：</p><h3 id="例-4-45-获取网络-I-O-统计信息"><a href="#例-4-45-获取网络-I-O-统计信息" class="headerlink" title="例 4.45. 获取网络 I&#x2F;O 统计信息"></a>例 4.45. 获取网络 I&#x2F;O 统计信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-32.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"><span class="keyword">from</span> xml.etree <span class="keyword">import</span> ElementTree</span><br></pre></td></tr></table></figure><h1 id="监测性能-1"><a href="#监测性能-1" class="headerlink" title="监测性能"></a>监测性能</h1><p>统计指标可用于监控域、vCPU、内存、块设备和网络接口的利用率。</p><h2 id="域块设备性能-1"><a href="#域块设备性能-1" class="headerlink" title="域块设备性能"></a>域块设备性能</h2><p><strong>blockStats</strong> 方法提供了磁盘使用统计信息：</p><h3 id="例-4-41-获取磁盘块-I-O-统计信息-1"><a href="#例-4-41-获取磁盘块-I-O-统计信息-1" class="headerlink" title="例 4.41. 获取磁盘块 I&#x2F;O 统计信息"></a>例 4.41. 获取磁盘块 I&#x2F;O 统计信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-31.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">domName = <span class="string">&#x27;Fedora22-x86_64-1&#x27;</span></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dom = conn.lookupByID(<span class="number">6</span>)</span><br><span class="line"><span class="keyword">if</span> dom == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to find the domain &#x27;</span> + domName, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">rd_req, rd_bytes, wr_req, wr_bytes, err = dom.blockStats(<span class="string">&#x27;/path/to/linux-0.2.img&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Read requests issued: &#x27;</span> + <span class="built_in">str</span>(rd_req))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Bytes read: &#x27;</span> + <span class="built_in">str</span>(rd_bytes))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Write requests issued: &#x27;</span> + <span class="built_in">str</span>(wr_req))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;写入字节数: &#x27;</span> + <span class="built_in">str</span>(wr_bytes))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;错误次数: &#x27;</span> + <span class="built_in">str</span>(err))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>返回的元组包含发出的读（写）请求数和实际传输的字节数。块设备由映像文件路径或域 XML 中的 <code>devices/disk/target[@dev]</code> 元素设置的设备总线名称指定。</p><p>除了 <strong>blockStats</strong> 方法外，还有 <strong>blockStatsFlags</strong> 备选方法。</p><h2 id="vCPU-性能-1"><a href="#vCPU-性能-1" class="headerlink" title="vCPU 性能"></a>vCPU 性能</h2><p>要获取单个 VCPU 统计数据，请使用 <strong>getCPUStats</strong> 方法。</p><h3 id="例-4-42-获取单个-CPU-统计数据-1"><a href="#例-4-42-获取单个-CPU-统计数据-1" class="headerlink" title="例 4.42. 获取单个 CPU 统计数据"></a>例 4.42. 获取单个 CPU 统计数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-33.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">domName = <span class="string">&#x27;Fedora22-x86_64-1&#x27;</span></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dom = conn.lookupByID(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span> dom == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to find the domain &#x27;</span> + domName, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">cpu_stats = dom.getCPUStats(<span class="literal">False</span>)</span><br><span class="line"><span class="keyword">for</span> (i, cpu) <span class="keyword">in</span> <span class="built_in">enumerate</span>(cpu_stats):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;CPU &#x27;</span> + <span class="built_in">str</span>(i) + <span class="string">&#x27; Time: &#x27;</span> + <span class="built_in">str</span>(cpu[<span class="string">&#x27;cpu_time&#x27;</span>] / <span class="number">1000000000.</span>))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><strong>getCPUStats</strong> 使用一个布尔参数。当使用 <strong>True</strong> 时，报告的统计数据是所有 CPU 的总和。如果使用 <strong>False</strong>，则每个 CPU 都会报告各自的统计数据。无论采用哪种方式，都会返回一个<strong>列表</strong>。统计数据以纳秒为单位报告。如果一台主机有四个 CPU，cpu_stats 列表中就会有四个条目。</p><p><strong>getCPUStats(True)</strong> 汇集主机上所有 CPU 的统计数据：</p><h3 id="例-4-43-获取-CPU-综合统计数据-1"><a href="#例-4-43-获取-CPU-综合统计数据-1" class="headerlink" title="例 4.43. 获取 CPU 综合统计数据"></a>例 4.43. 获取 CPU 综合统计数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-34.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">domName = <span class="string">&#x27;Fedora22-x86_64-1&#x27;</span></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dom = conn.lookupByID(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span> dom == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to find the domain &#x27;</span> + domName, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">stats = dom.getCPUStats(<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;cpu_time: &#x27;</span> + <span class="built_in">str</span>(stats[<span class="number">0</span>][<span class="string">&#x27;cpu_time&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;system_time: &#x27;</span> + <span class="built_in">str</span>(stats[<span class="number">0</span>][<span class="string">&#x27;system_time&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;user_time: &#x27;</span> + <span class="built_in">str</span>(stats[<span class="number">0</span>][<span class="string">&#x27;user_time&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="内存统计-1"><a href="#内存统计-1" class="headerlink" title="内存统计"></a>内存统计</h2><p>要获取域当前使用的内存量，可以使用 <strong>memoryStats</strong> 方法。</p><h3 id="例-4-44-获取内存统计信息-1"><a href="#例-4-44-获取内存统计信息-1" class="headerlink" title="例 4.44. 获取内存统计信息"></a>例 4.44. 获取内存统计信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-35.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">domName = <span class="string">&#x27;Fedora22-x86_64-1&#x27;</span></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dom = conn.lookupByID(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span> dom == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to find the domain &#x27;</span> + domName, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">stats = dom.memoryStats()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;memory used:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> stats:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span> + <span class="built_in">str</span>(stats[name]) + <span class="string">&#x27; (&#x27;</span> + name + <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>请注意，<strong>memoryStats</strong> 返回的是一个字典对象。根据管理程序和客户域的功能，该对象将包含数量不等的条目。</p><h2 id="网络-I-O-统计数据-1"><a href="#网络-I-O-统计数据-1" class="headerlink" title="网络 I&#x2F;O 统计数据"></a>网络 I&#x2F;O 统计数据</h2><p>要获取网络统计信息，需要域所连接主机接口的名称（通常为 vnetX）。要找到它，请检索域 XML 描述（libvirt 会在运行时修改它）。然后，查找 <code>devices/interface/target[@dev]</code> 元素：</p><h3 id="例-4-45-获取网络-I-O-统计信息-1"><a href="#例-4-45-获取网络-I-O-统计信息-1" class="headerlink" title="例 4.45. 获取网络 I&#x2F;O 统计信息"></a>例 4.45. 获取网络 I&#x2F;O 统计信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-32.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"><span class="keyword">from</span> xml.etree <span class="keyword">import</span> ElementTree</span><br></pre></td></tr></table></figure><h1 id="PCI-设备直通"><a href="#PCI-设备直通" class="headerlink" title="PCI 设备直通"></a>PCI 设备直通</h1><p>PCI 设备直通功能可将主机中的物理 PCI 设备直接分配给客户机，客户机操作系统驱动程序可直接使用设备硬件，而无需依赖主机操作系统的任何驱动程序功能。</p><p>使用 PCI 设备直通时有一些注意事项。当 PCI 设备直接分配给客户机时，如果不先将设备从客户机热拔插，就无法进行迁移。此外，libvirt 并不保证直接分配设备是安全的，因此安全策略决定与底层虚拟化技术有关。安全 PCI 设备直通通常需要特殊的硬件功能，如英特尔芯片组的 VT-d 功能或 AMD 芯片组的 IOMMU。</p><p>连接 PCI 设备有两种模式：”托管” 或 “非托管” 模式，但在撰写本文时，只有 KVM 支持 “托管” 模式连接。在托管模式下，当客户机启动时，配置的设备将自动从主机操作系统驱动程序中分离，然后在客户机关闭时重新连接。在非托管模式下，必须在启动客户机之前明确分离设备。如果设备仍连接到主机操作系统，客户机将拒绝启动。libvirt 的 “节点设备” API 提供了从主机驱动程序分离&#x2F;重新连接 PCI 设备的方法。另外，也可以配置主机操作系统，将用于客户机的 PCI 设备列入黑名单，使其永远不会连接到主机操作系统驱动程序。</p><p>在这两种模式下，虚拟化技术始终会在启动客户机之前和客户机关闭之后对设备执行重置。这对于确保主机和客户操作系统之间的隔离至关重要。</p><p>复位 PCI 设备有多种方式。一些重置技术的范围仅限于单个设备&#x2F;功能，而另一些则可能同时影响多个设备。在后一种情况下，有必要将所有受影响的设备共同分配给同一客户，否则重置将不可能安全完成。节点设备 API 可用于确定设备是否需要共同分配，方法是手动分离设备，然后尝试执行重置操作。如果成功，就可以将设备单独分配给访客。如果失败，则需要将设备与同一 PCI 总线上的其他设备共同分配。</p><p>PCI 设备使用 “hostdevice” 元素连接到客户机。”模式” 属性应始终设置为 “子系统”，”类型” 属性应始终设置为 “pci”。”managed” 属性可根据应用需要设置为 “yes” 或 “no”。在 “hostdevice” 元素中有一个 “source” 元素，其中的 “address” 元素用于指定要连接的 PCI 设备。地址元素需要 “域”、”总线”、”插槽” 和 “功能” 属性。通过一个简短的示例最容易理解：</p><h3 id="例-4-52-获取域的输入设备信息"><a href="#例-4-52-获取域的输入设备信息" class="headerlink" title="例 4.52. 获取域的输入设备信息"></a>例 4.52. 获取域的输入设备信息</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hostdev</span> <span class="attr">mode</span>=<span class="string">&#x27;subsystem&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;pci&#x27;</span> <span class="attr">managed</span>=<span class="string">&#x27;yes&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">address</span> <span class="attr">domain</span>=<span class="string">&#x27;0x0000&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0x06&#x27;</span> <span class="attr">slot</span>=<span class="string">&#x27;0x12&#x27;</span> <span class="attr">function</span>=<span class="string">&#x27;0x5&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hostdev</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="实时配置更改"><a href="#实时配置更改" class="headerlink" title="实时配置更改"></a>实时配置更改</h1><h2 id="区块设备工作"><a href="#区块设备工作" class="headerlink" title="区块设备工作"></a>区块设备工作</h2><p>Libvirt 提供了通用的块任务方法，可用于启动和管理对属于域的磁盘的操作。通过调用与所需的操作（如 <strong>blockPull</strong>）。一旦启动，所有区块任务都以相同的方式进行管理。它们可以被中止、节流和查询。完成后，会发出一个异步事件来指示最终状态。</p><p>可以启动以下程序块任务：</p><ul><li><strong>blockPull()</strong> 启动指定磁盘的块拉动操作。<strong>blockPull</strong> 会从磁盘的后备映像中提取数据填充磁盘映像。一旦从其后备映像中提取了所有数据，磁盘就不再依赖于后备映像。</li><li>可以使用 <strong>blockJobInfo</strong> 查询磁盘上的活动分块任务。如果找到，作业信息将以结构形式报告，其中包含：作业类型、带宽节流设置和进度信息。</li><li><strong>virDomainBlockJobAbort()</strong> 可用于取消指定磁盘上的活动块任务。使用 <strong>blockJobSetSpeed()</strong> 可以限制块任务可能消耗的带宽。</li></ul><p>带宽以 MB&#x2F;秒为单位指定。</p><h3 id="例-4-53-获取域的输入设备信息"><a href="#例-4-53-获取域的输入设备信息" class="headerlink" title="例 4.53. 获取域的输入设备信息"></a>例 4.53. 获取域的输入设备信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-40.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">domxml = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;domain type=&#x27;kvm&#x27;&gt;</span></span><br><span class="line"><span class="string">    &lt;name&gt;示例&lt;/name&gt;</span></span><br><span class="line"><span class="string">    &lt;memory&gt;131072&lt;/memory&gt;</span></span><br><span class="line"><span class="string">    &lt;vcpu&gt;1&lt;/vcpu&gt;</span></span><br><span class="line"><span class="string">    &lt;os&gt;</span></span><br><span class="line"><span class="string">        &lt;type arch=&#x27;x86_64&#x27; machine=&#x27;pc-0.13&#x27;&gt;hvm&lt;/type&gt;</span></span><br><span class="line"><span class="string">    &lt;/os&gt;</span></span><br><span class="line"><span class="string">    &lt;devices&gt;</span></span><br><span class="line"><span class="string">        &lt;disk type=&#x27;file&#x27; device=&#x27;disk&#x27;&gt;</span></span><br><span class="line"><span class="string">            &lt;driver name=&#x27;qemu&#x27; type=&#x27;qed&#x27;/&gt;</span></span><br><span class="line"><span class="string">            &lt;source file=&#x27;/var/lib/libvirt/images/example.qed&#x27;/&gt;</span></span><br><span class="line"><span class="string">            &lt;target dev=&#x27;vda&#x27; bus=&#x27;virtio&#x27;/&gt;</span></span><br><span class="line"><span class="string">        &lt;/disk&gt;</span></span><br><span class="line"><span class="string">    &lt;/devices&gt;</span></span><br><span class="line"><span class="string">&lt;/domain&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_cmd</span>(<span class="params">cmdline</span>):</span><br><span class="line">    status = os.system(cmdline)</span><br><span class="line">    <span class="keyword">if</span> status &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> WEXITSTATUS(status)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_domain</span>(<span class="params">conn</span>):</span><br><span class="line">    do_cmd(<span class="string">&quot;qemu-img create -f raw /var/lib/libvirt/images/backing.qed 100M&quot;</span>)</span><br><span class="line">    do_cmd(<span class="string">&quot;qemu-img create -f qed -b /var/lib/libvirt/images/backing.qed &quot;</span> +</span><br><span class="line">           <span class="string">&quot;/var/lib/libvirt/images/example.qed&quot;</span>)</span><br><span class="line">    dom = conn.createXML(domxml, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> dom</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line">dom = <span class="literal">None</span></span><br><span class="line">disk = <span class="string">&quot;/var/lib/libvirt/images/example.qed&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dom = make_domain(conn)</span><br><span class="line"><span class="keyword">if</span> dom == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Failed to create domain&quot;</span>, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> dom.blockPull(disk, <span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Failed to start block pull&quot;</span>, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>):</span><br><span class="line">    info = dom.blockJobInfo(disk, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> info != <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;BlockPull progress: %0.0f %%&quot;</span> % <span class="built_in">float</span>(<span class="number">100</span> * info.cur / info.end))</span><br><span class="line">    <span class="keyword">elif</span> info.cur == info.end:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;BlockPull complete&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Failed to query block jobs&quot;</span>, file=os.stderr)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">os.unlink(<span class="string">&quot;/var/lib/libvirt/images/backing.qed&quot;</span>)</span><br><span class="line">os.unlink(<span class="string">&quot;/var/lib/libvirt/images/example.qed&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> dom != <span class="literal">None</span>:</span><br><span class="line">    conn.destroy(dom)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;4-1-Domain-概述&quot;&gt;&lt;a href=&quot;#4-1-Domain-概述&quot; class=&quot;headerlink&quot; title=&quot;4.1 Domain 概述&quot;&gt;&lt;/a&gt;4.1 Domain 概述&lt;/h1&gt;&lt;p&gt;域是运行在虚拟化机器上的操作系统实例。一个客域可以指</summary>
      
    
    
    
    <category term="云计算" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="libvirt" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/libvirt/"/>
    
    
    <category term="云计算" scheme="https://watsonlu6.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="libvirt" scheme="https://watsonlu6.github.io/tags/libvirt/"/>
    
  </entry>
  
  <entry>
    <title>3 libvirt连接</title>
    <link href="https://watsonlu6.github.io/libvirt%E6%96%87%E6%A1%A3/3-libvirt%E8%BF%9E%E6%8E%A5/"/>
    <id>https://watsonlu6.github.io/libvirt%E6%96%87%E6%A1%A3/3-libvirt%E8%BF%9E%E6%8E%A5/</id>
    <published>2024-03-03T07:50:26.000Z</published>
    <updated>2025-03-15T08:00:25.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-连接"><a href="#3-连接" class="headerlink" title="3 连接"></a>3 连接</h1><p>在libvirt中，连接是系统中每个操作和对象的基础。任何希望与libvirt交互的实体，无论是virsh、virt-manager，还是使用libvirt库的程序，都需要首先获得与目标主机上libvirt守护进程的连接。连接不仅描述了代理希望交互的虚拟化技术类型（如qemu、xen、uml等），还描述了连接到该资源所需的任何认证方法。</p><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p>libvirt 代理必须做的第一件事就是调用 <strong>virInitialize</strong> 函数或 Python libvirt 连接函数之一来获取 <strong>virConnect</strong> 类的实例。该实例将在后续操作中使用。Python libvirt 模块为连接到资源提供了 3 个不同的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conn = libvirt.<span class="built_in">open</span>(name)</span><br><span class="line">conn = libvirt.openAuth(uri, auth, flags)</span><br><span class="line">conn = libvirt.openReadOnly(name)</span><br></pre></td></tr></table></figure><p>在这三种情况下，都有一个名为 <code>name</code> 的参数，实际上指的是要连接的 hypervisor 的 URI。前面的 <em>第 2.2 节 “驱动程序模型 “</em> 和 <em>第 3.2.2 节 “远程 URI “</em> 详细介绍了可接受的各种 URI 格式。如果 URI 为 <code>None</code>，那么 libvirt 将应用一些启发式算法并探测适合的 hypervisor 驱动程序。虽然这对于开发人员进行临时测试可能很方便，但强烈建议应用程序不要依赖探测逻辑，因为它可能随时更改。应用程序应始终通过提供 URI 显式请求所需的 hypervisor 连接。</p><p>上述三种方法的区别在于它们进行身份验证的方式及其提供的授权级别。</p><h3 id="3-1-1-Open-函数"><a href="#3-1-1-Open-函数" class="headerlink" title="3.1.1 Open 函数"></a>3.1.1 Open 函数</h3><p><strong>open</strong> 函数将尝试为完全读写访问打开一个连接。该函数不允许提供身份验证回调，因此只有在可以根据应用程序的凭证进行身份验证的连接上才会成功。</p><p><strong>例 3.1. 使用 open</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-1.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>上述示例打开了与系统 qemu 管理程序驱动程序的读写连接，检查是否成功，如果成功则关闭连接。有关 libvirt URI 的更多信息，请参阅 *第 3.2 节 “URl 格式”*。</p><h3 id="3-1-2-openReadOnly"><a href="#3-1-2-openReadOnly" class="headerlink" title="3.1.2 openReadOnly"></a>3.1.2 openReadOnly</h3><p><strong>openReadOnly</strong> 函数将尝试为只读访问打开一个连接。这种连接只允许调用一组受限制的方法，通常用于监控不允许更改的应用程序。与 <strong>open</strong> 方法一样，该方法不支持身份验证回调，因此需要依赖凭证。</p><p><strong>例 3.2. 使用 openReadOnly</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-2.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.openReadOnly(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>上述示例打开了与系统 qemu 管理程序驱动程序的只读连接，检查是否成功，如果成功则关闭连接。有关 libvirt URI 的更多信息，请参阅 *第 3.2 节 “URl 格式”*。</p><h3 id="3-1-3-openAuth"><a href="#3-1-3-openAuth" class="headerlink" title="3.1.3 openAuth"></a>3.1.3 openAuth</h3><p><strong>openAuth</strong> 函数是最灵活的函数，实际上取代了前两个函数。它需要一个额外的参数，提供一个 Python <strong>列表</strong>，其中包含客户端应用程序的身份验证凭据。如果需要，flags 参数允许应用程序使用 <em>VIR_cONNEcT_RO</em> 标志请求只读连接。下面是一个使用 <strong>openAuth</strong> 和用户名与密码凭据的简单 Python 程序示例。与 <strong>open 方法</strong>一样，该方法没有身份验证回调范围，因此依赖于凭据。</p><p><strong>例 3.3. 使用 openAuth</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-3.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">SASL_USER = <span class="string">&quot;my-super-user&quot;</span></span><br><span class="line">SASL_PASS = <span class="string">&quot;my-super-user&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">request_cred</span>(<span class="params">credentials, user_data</span>):</span><br><span class="line">    <span class="keyword">for</span> credential <span class="keyword">in</span> credentials:</span><br><span class="line">        <span class="keyword">if</span> credential[<span class="number">0</span>] == libvirt.VIR_CRED_AUTHNAME:</span><br><span class="line">            credential[<span class="number">4</span>] = SASL_USER</span><br><span class="line">        <span class="keyword">elif</span> credential[<span class="number">0</span>] == libvirt.VIR_CRED_PASSPHRASE:</span><br><span class="line">            credential[<span class="number">4</span>] = SASL_PASS</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">auth = [[libvirt.VIR_CRED_AUTHNAME, libvirt.VIR_CRED_PASSPHRASE], request_cred, <span class="literal">None</span>]</span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.openAuth(<span class="string">&#x27;qemu+tcp://localhost/system&#x27;</span>, auth, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>要测试上述程序，必须具备以下配置：</p><ol><li><strong>&#x2F;etc&#x2F;libvirt&#x2F;libvirtd.conf</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">listen_tls = 0</span><br><span class="line">listen_tcp = 1</span><br><span class="line">auth_tcp = &quot;sasl&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>&#x2F;etc&#x2F;sasl2&#x2F;libvirt.conf</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mech_list: digest-md5</span><br></pre></td></tr></table></figure><ol start="3"><li>SASL 数据库中已添加 virt 用户：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ saslpasswd2 -a libvirt virt</span><br><span class="line">Password:</span><br><span class="line">Again (<span class="keyword">for</span> verification):</span><br></pre></td></tr></table></figure><ol start="4"><li>libvirtd 已使用 <em>–listen</em> 启动</li></ol><p>配置完成后，<em>例 3.3 “使用 openAuth “</em> 就可以使用配置的用户名和密码，并允许对 libvirtd 进行读写访问。</p><p>与 libvirt C 接口不同，Python 不提供用于收集凭证的自定义回调。</p><h3 id="3-1-4-Close"><a href="#3-1-4-Close" class="headerlink" title="3.1.4 Close"></a>3.1.4 Close</h3><p>不再需要连接时，必须调用 <strong>virConnection</strong> 类的 <strong>close</strong> 方法来释放连接。连接是有引用计数的对象，因此每次 <strong>open</strong> 函数调用都应相应地调用 <strong>close</strong> 方法。</p><p>连接是有引用计数的；初始化（<strong>open</strong>、<strong>openAuth</strong> 等）会明确增加引用计数；其他依赖于连接存活的方法也会临时增加引用计数。<strong>open</strong> 函数调用应具有匹配的 <strong>close</strong>，所有其他引用将在相应操作完成后释放。</p><p>在 Python 中，当类实例离开作用域或程序结束时，引用计数会自动减少。</p><p><strong>例 3.4. 使用带有附加引用的 close</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-5.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn1 = libvirt.<span class="built_in">open</span>(<span class="string">&#x27;qemu:///system&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> conn1 == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to open connection to qemu:///system&#x27;</span>, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">conn2 = libvirt.<span class="built_in">open</span>(<span class="string">&#x27;qemu:///system&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> conn2 == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to open connection to qemu:///system&#x27;</span>, file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">conn1.close()</span><br><span class="line">conn2.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>还要注意的是，与连接（virDomain、virNetwork 等）相关的每个其他类实例也将持有连接的引用。</p><h2 id="3-2-URI-格式"><a href="#3-2-URI-格式" class="headerlink" title="3.2 URI 格式"></a>3.2 URI 格式</h2><p>Libvirt 使用统一资源标识符 (URI) 来标识管理程序连接。libvirt 使用 URI 对本地和远程管理程序进行寻址。URI 方案和路径定义了要连接的管理程序，而 URI 的主机部分则决定了管理程序的位置。</p><h3 id="3-2-1-本地-URI"><a href="#3-2-1-本地-URI" class="headerlink" title="3.2.1 本地 URI"></a>3.2.1 本地 URI</h3><p>Libvirt 本地 URI 有以下几种形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">driver:///system</span><br><span class="line">driver:///session</span><br><span class="line">driver+unix:///system</span><br><span class="line">driver+unix:///session</span><br></pre></td></tr></table></figure><p>libvirt URI 的所有其他用途都被视为远程，即使连接到 localhost 也是如此。有关远程 URI 的详细信息，请参见 *第 3.2.2 节 “远程 URI”*。</p><p>目前支持以下驱动程序：</p><table><thead><tr><th><strong>驱动</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>qemu</td><td>用于管理 qemu 和 KVM 客户端</td></tr><tr><td>xen</td><td>用于管理旧式（Xen 3.1 及更旧版本）Xen 客户端</td></tr><tr><td>xenapi</td><td>用于管理新式 Xen 客户端</td></tr><tr><td>uml</td><td>用于管理 UML 来宾</td></tr><tr><td>lxc</td><td>用于管理 Linux 容器</td></tr><tr><td>vbox</td><td>用于管理 VirtualBox 客户端</td></tr><tr><td>openvz</td><td>用于管理 OpenVZ 容器</td></tr><tr><td>esx</td><td>用于管理 VMware ESX 客户端</td></tr><tr><td>gsx</td><td>用于管理 VMware GSX 客户端</td></tr><tr><td>vpx</td><td>用于管理 VMware VPX 客户端</td></tr><tr><td>hyperv</td><td>用于管理 Microsoft Hyper-V 客户端</td></tr></tbody></table><p>下面的示例展示了如何使用本地 URI 连接到本地 QEMU 虚拟机管理程序。</p><p><strong>例 3.5. 连接本地 QEMU 虚拟机管理程序</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-6.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>请注意，并非所有列出的驱动程序都可以这样使用。两个明显的例外是 LXC 驱动程序和仅客户端驱动程序。与 LXC 驱动程序建立连接的方法见下例。</p><p><strong>例 3.6. 连接本地 LXC 虚拟机管理程序</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-32.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&#x27;lxc://&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>客户端专用驱动程序包括 ESX、VPX、GPX 和 Hyper-V。与其他驱动程序相比，这些驱动程序不能与远程传输机制一起使用。这意味着以下 URI 无效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esx+ssh://example.com</span><br></pre></td></tr></table></figure><p>下面举例说明如何正确使用这些驱动程序。</p><p><strong>例 3.7. 连接到客户端驱动程序</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-33.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line"><span class="comment"># use VPX over HTTPS, select ESX server &#x27;srv1&#x27; in datacenter &#x27;dc1&#x27;</span></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&#x27;vpx://example-vcenter.com/dc1/srv1&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="3-2-2-远程-URI"><a href="#3-2-2-远程-URI" class="headerlink" title="3.2.2 远程 URI"></a>3.2.2 远程 URI</h3><p>远程 URI 采用一般形式（”[…]“ 表示可选部分）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver[+transport]://[username@][hostname][:port]/[path][?extraparameters]</span><br></pre></td></tr></table></figure><p>下表介绍了 URI 的各个组成部分。</p><table><thead><tr><th><strong>组件</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>driver</td><td>要连接到的 libvirt hypervisor 驱动程序的名称。这与本地 URI 中使用的名称相同。一些示例包括 xen、qemu、lxc、openvz 和 test。作为特殊情况，可以使用伪驱动程序名称 remote，这将导致远程守护进程探测活动的 hypervisor，并选择一个来使用。作为一般规则，如果应用程序知道它需要哪种 hypervisor，应始终明确指定驱动程序名称，而不依赖于自动探测。</td></tr><tr><td>transport</td><td>数据传输之一的名称。可能的值包括 <strong>tls</strong>、<strong>tcp</strong>、<strong>unix</strong>、<strong>ssh</strong> 和 <strong>ext</strong>。如果省略，则在提供主机名的情况下默认为 <strong>tls</strong>，在未提供主机名的情况下默认为 <strong>unix</strong>。</td></tr><tr><td>username</td><td>使用 SSH 数据传输时，可以选择与客户端当前登录名不同的用户名。</td></tr><tr><td>hostname</td><td>远程计算机的全限定主机名。如果使用带有 x509 证书的 TLS 或带有 GSSAPI&#x2F;Keberos 插件的 SASL，该主机名必须与服务器 x509 证书&#x2F;Kerberos 原理中使用的主机名一致。不匹配的主机名将导致验证失败。</td></tr><tr><td>port</td><td>很少需要，除非 SSH 或 libvirtd 已配置为在非标准 TCP 端口上运行。SSH 数据传输默认端口为 <strong>22</strong>，<strong>16509</strong> 用于 TCP 数据传输，<strong>16514</strong> 用于 TLS 数据传输。</td></tr><tr><td>path</td><td>路径应与管理程序驱动程序的本地 URI 所用路径相同。对于 Xen，路径始终是 **&#x2F;**，而对于 QEMU，路径则是 <strong>&#x2F;system</strong>。</td></tr><tr><td>extraparameters</td><td>URI 查询参数可以对远程连接的某些方面进行微调，下一节将对此进行深入讨论。</td></tr></tbody></table><p>根据此处描述的信息，并参考本文件前面提到的管理程序专用 URI，现在可以举例说明一些远程访问 URI。</p><p>使用 ssh 隧道数据传输和 ssh 用户名 <em>root</em> 连接到主机 <em>node.example.com</em> 上的远程 Xen 虚拟机管理程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xen+ssh://root@node.example.com/</span><br></pre></td></tr></table></figure><p>使用 TLS 和 x509 证书连接到主机 <em>node.example.com</em> 上的远程 QEMU 虚拟机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu://node.example.com/system</span><br></pre></td></tr></table></figure><p>使用 TLS 连接到主机 <em>node.example.com</em> 上的远程 Xen 虚拟机，跳过对服务器 x509 证书的验证（注意：这会危及你的安全）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xen://node.example.com/?no_verify=1</span><br></pre></td></tr></table></figure><p>通过非标准 Unix 套接字连接本地 QEMU 实例（在这种情况下要明确提供 Unix 套接字的完整路径）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu+unix:///system?socket=/opt/libvirt/run/libvirt/libvirt-sock</span><br></pre></td></tr></table></figure><p>连接到 libvirtd 守护进程，在另一个 TCP 端口 5000 上提供未加密的 TCP&#x2F;IP 连接，并使用默认配置的测试驱动程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test+tcp://node.example.com:5000/default</span><br></pre></td></tr></table></figure><h3 id="Extra-parameters"><a href="#Extra-parameters" class="headerlink" title="Extra parameters"></a>Extra parameters</h3><p>远程 URI 可以在查询字符串（”?” 后面的部分）中添加额外参数。远程 URI 可以理解以下所示的额外参数。任何其他参数都将不加修改地传递到后端。请注意，参数值必须使用 URI 转义。更多信息请参阅 <em><a href="http://xmlsoft.org/">http://xmlsoft.org/</a> html&#x2F;libxml-uri.html#xmlURlEscapeStr。</em></p><table><thead><tr><th><strong>名称</strong></th><th><strong>运输</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>name</td><td><em>任何运输</em></td><td>传递给远程 virConnectOpen 函数的本地管理程序 URI。该 URI 通常是通过删除远程 URI 中的传输、主机名、端口号、用户名和额外参数形成的，但在某些非常复杂的情况下，可能需要明确提供名称。例如：<strong>name&#x3D;qemu:&#x2F;&#x2F;&#x2F;system</strong></td></tr><tr><td>command</td><td>ssh、ext</td><td>外部命令。对于 ext 传输，这是必需的。对于 ssh，默认为 ssh。搜索 PATH 以查找命令。例如：<strong>command&#x3D;&#x2F;opt&#x2F;openssh&#x2F;bin&#x2F;ssh</strong></td></tr><tr><td>socket</td><td>unix, ssh</td><td>外部命令。对于 ext 传输，这是必需的。对于 ssh，默认为 <strong>ssh</strong>。会在 PATH 中搜索命令。示例：<strong>socket&#x3D;&#x2F;opt&#x2F;libvirt&#x2F;run&#x2F;libvirt&#x2F;libvirt-sock</strong></td></tr><tr><td>netcat</td><td>ssh</td><td>远程计算机上 netcat 命令的名称。默认为 nc。对于 ssh 传输，libvirt 构建的 ssh 命令类似于 <code>command -p port [-l username] hostname netcat -U socket</code>，其中端口、用户名、主机名可作为远程 URI 的一部分指定，而命令、netcat 和 socket 则来自额外参数（或合理的默认值）。例如：<strong>netcat&#x3D;&#x2F;opt&#x2F;netcat&#x2F;bin&#x2F;nc</strong></td></tr><tr><td>no_verify</td><td>tls</td><td>如果设置的值不为零，则会禁用客户端对服务器证书的检查。请注意，要禁用服务器对客户端的检查，您必须更改 libvirtd 配置。示例：<strong>no_verify&#x3D;1</strong></td></tr><tr><td>no_tty</td><td>ssh</td><td>如果设置为非零，当 ssh 无法自动登录远程机器时（例如，使用 ssh-agent 时），该值将阻止 ssh 询问密码。在无法访问终端时使用此功能，例如在使用 libvirt 的图形程序中。例如 <strong>no_tty&#x3D;1</strong></td></tr></tbody></table><h2 id="3-3-Capability-Information-Methods"><a href="#3-3-Capability-Information-Methods" class="headerlink" title="3.3 Capability Information Methods"></a>3.3 Capability Information Methods</h2><p>下面的示例展示了如何使用远程 URI 连接 QEMU 虚拟机管理程序。</p><p><strong>例 3.8. 连接远程 QEMU 虚拟机管理程序</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-7.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&#x27;qemu+tls://host2/system&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><strong>getCapabilities</strong> 方法调用可用于获取有关虚拟化主机功能的信息。如果调用成功，它将返回一个包含 capabilities XML 的 Python 字符串（如下所述）。如果发生错误，则返回 <strong>None</strong>。以下代码演示了 <strong>getCapabilities</strong> 方法的使用：</p><p><strong>例 3.9. 使用 getCapabilities</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-8.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">caps = conn.getCapabilities()  <span class="comment"># caps 将是一个 XML 字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Capabilities:\n&#x27;</span> + caps)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>capabilities XML 格式提供了主机虚拟化技术的相关信息。特别是，它描述了虚拟化主机的功能、虚拟化驱动程序以及虚拟化技术可启动的客户类型。请注意，根据使用的 libvirt 驱动程序，能力 XML 可能（也确实）有所不同。能力 XML 示例如下：</p><p><strong>例 3.10. QEMU 驱动程序功能示例</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">capabilities</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">host</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpu</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arch</span>&gt;</span>x86_64<span class="tag">&lt;/<span class="name">arch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cpu</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">migration_features</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">live</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">uri_transports</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">uri_transport</span>&gt;</span>tcp<span class="tag">&lt;/<span class="name">uri_transport</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">uri_transports</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">migration_features</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">topology</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">cells</span> <span class="attr">num</span>=<span class="string">&#x27;1&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">cell</span> <span class="attr">id</span>=<span class="string">&#x27;0&#x27;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">cpus</span> <span class="attr">num</span>=<span class="string">&#x27;2&#x27;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">cpu</span> <span class="attr">id</span>=<span class="string">&#x27;0&#x27;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">cpu</span> <span class="attr">id</span>=<span class="string">&#x27;1&#x27;</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">cpus</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">cell</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">cells</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">topology</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">guest</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">os_type</span>&gt;</span>hvm<span class="tag">&lt;/<span class="name">os_type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arch</span> <span class="attr">name</span>=<span class="string">&#x27;i686&#x27;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">wordsize</span>&gt;</span>32<span class="tag">&lt;/<span class="name">wordsize</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">emulator</span>&gt;</span>/usr/bin/qemu<span class="tag">&lt;/<span class="name">emulator</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">machine</span>&gt;</span>pc<span class="tag">&lt;/<span class="name">machine</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">machine</span>&gt;</span>isapc<span class="tag">&lt;/<span class="name">machine</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">domain</span> <span class="attr">type</span>=<span class="string">&#x27;qemu&#x27;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">domain</span> <span class="attr">type</span>=<span class="string">&#x27;kvm&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">emulator</span>&gt;</span>/usr/bin/qemu-kvm<span class="tag">&lt;/<span class="name">emulator</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">arch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">features</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pae</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">nonpae</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">acpi</span> <span class="attr">default</span>=<span class="string">&#x27;on&#x27;</span> <span class="attr">toggle</span>=<span class="string">&#x27;yes&#x27;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">apic</span> <span class="attr">default</span>=<span class="string">&#x27;on&#x27;</span> <span class="attr">toggle</span>=<span class="string">&#x27;no&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">features</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">guest</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">guest</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">os_type</span>&gt;</span>hvm<span class="tag">&lt;/<span class="name">os_type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arch</span> <span class="attr">name</span>=<span class="string">&#x27;x86_64&#x27;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">wordsize</span>&gt;</span>64<span class="tag">&lt;/<span class="name">wordsize</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">emulator</span>&gt;</span>/usr/bin/qemu-system-x86_64<span class="tag">&lt;/<span class="name">emulator</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">machine</span>&gt;</span>pc<span class="tag">&lt;/<span class="name">machine</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">machine</span>&gt;</span>isapc<span class="tag">&lt;/<span class="name">machine</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">domain</span> <span class="attr">type</span>=<span class="string">&#x27;qemu&#x27;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">domain</span> <span class="attr">type</span>=<span class="string">&#x27;kvm&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">emulator</span>&gt;</span>/usr/bin/qemu-kvm<span class="tag">&lt;/<span class="name">emulator</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">arch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">features</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">acpi</span> <span class="attr">default</span>=<span class="string">&#x27;on&#x27;</span> <span class="attr">toggle</span>=<span class="string">&#x27;yes&#x27;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">apic</span> <span class="attr">default</span>=<span class="string">&#x27;on&#x27;</span> <span class="attr">toggle</span>=<span class="string">&#x27;no&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">features</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">guest</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">capabilities</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 capabilities XML 中，总有一个 <strong>&#x2F;host</strong> 子文档，以及零个或多个 <strong>&#x2F;guest</strong> 子文档（虽然允许零个 guest 子文档，但这意味着该特定驱动程序的任何 guest 都不能在该特定主机上启动）。</p><p><strong>&#x2F;host</strong> 子文档描述主机的功能。</p><p><strong>&#x2F;host&#x2F;uuid</strong> 显示主机的 UUID。如果 SMBIOS UUID 可用且有效，则从 SMBIOS UUID 派生，或者在 libvirtd.conf 中用自定义值覆盖。如果以上两项都未正确设置，则每次重启 libvirtd 时都会生成一个临时 UUID。</p><p><strong>&#x2F;host&#x2F;cpu</strong> 子文档描述了主机 CPU 的能力。libvirt 在决定是否能在这台特定机器上正确启动客户机时会用到它，在实时迁移过程中也会参考它，以确定目标机器是否提供继续运行客户机所需的标志。</p><p><strong>&#x2F;host&#x2F;cpu&#x2F;arch</strong> 是描述底层主机 CPU 架构的必要 XML 节点。截至本文撰写时，所有 libvirt 驱动程序都会根据 uname(2) 的输出将其初始化。</p><p><strong>&#x2F;host&#x2F;cpu&#x2F;features</strong> 是一个可选的子文档，用于描述主机上存在的其他 CPU 功能。目前，xen 驱动程序仅使用它来报告是否存在 svm 或 vmx 标志，以及是否存在 pae 标志。</p><p><strong>&#x2F;host&#x2F;cpu&#x2F;model</strong> 是一个可选元素，用于描述与主机 CPU 最相似的 CPU 型号。libvirt 当前了解的 CPU 型号列表位于 cpu_map.xml 文件中。</p><p><strong>&#x2F;host&#x2F;cpu&#x2F;feature</strong> 是零个或多个元素，用于描述主机 CPU 所具有的其他 CPU 特性，这些特性不在 <strong>&#x2F;host&#x2F;cpu&#x2F;model</strong> 中涵盖。</p><p><strong>&#x2F;host&#x2F;migration_features</strong> 是一个可选的子文档，用于描述该驱动程序在该主机上支持的迁移功能（如果有）。如果该子文档不存在，则不支持迁移。目前，xen、qemu 和 esx 驱动程序支持迁移。</p><p>如果驱动程序支持实时迁移，则存在 <strong>&#x2F;host&#x2F;migration_features&#x2F;live</strong> XML 节点。</p><p><strong>&#x2F;host&#x2F;migration_features&#x2F;uri_transports</strong> 是一个可选的子文档，描述了备用的迁移连接机制。这些备用连接机制在多主机虚拟化系统中非常有用。例如，virsh migrate 命令可以通过 10.0.0.1 连接到迁移源，通过 10.0.0.2 连接到迁移目标。但是，由于安全策略的原因，迁移源可能只能通过 192.168.0.0&#x2F;24 直接与迁移目标通信。在这种情况下，使用备用迁移连接机制将使迁移成功。截至本文撰写之时，xen 驱动程序支持备用迁移机制 “xenmigr”，而 qemu 驱动程序则支持备用迁移机制 “tcp”。更多信息，请参阅迁移文档。</p><p><strong>&#x2F;host&#x2F;topology</strong> 子文档描述主机的 NUMA 拓扑；每个 NUMA 节点由一个 <strong>&#x2F;host&#x2F;topology&#x2F;cells&#x2F;cell</strong> 表示，并描述该 NUMA 节点中的 CPU。如果主机是 UMA（非 NUMA）机器，则只有一个单元，所有 CPU 都在该单元中。这与硬件的具体情况密切相关，因此在不同的机器上必然会有所不同。</p><p><strong>&#x2F;host&#x2F;secmodel</strong> 是一个可选的子文档，用于描述主机上使用的安全模型。</p><p><strong>&#x2F;host&#x2F;secmodel&#x2F;model</strong> 显示安全模型的名称，而 <strong>&#x2F;host&#x2F;secmodel&#x2F;doi</strong> 则显示解释域。有关安全的更多信息，请参阅安全部分。</p><p>每个 <strong>&#x2F;guest</strong> 子文档都描述了该主机驱动程序可以启动的一种客户机。该描述包括客户机的架构（即 i686）以及提供给客户机的 ABI（即 hvm、xen 或 uml）。</p><p><strong>&#x2F;guest&#x2F;os_type</strong> 是描述来宾类型的必填元素。</p><table><thead><tr><th><strong>驱动</strong></th><th><strong>客人类型</strong></th></tr></thead><tbody><tr><td>qemu</td><td>总是 “hvm”</td></tr><tr><td>xen</td><td>准虚拟化客户机可以使用 “xen”，完全虚拟化客户机可以使用 “hvm”。</td></tr><tr><td>uml</td><td>总是 “uml”</td></tr><tr><td>lxc</td><td>始终为 “exe”</td></tr><tr><td>vbox</td><td>总是 “hvm”</td></tr><tr><td>openvz</td><td>始终为 “exe”</td></tr><tr><td>one</td><td>总是 “hvm”</td></tr><tr><td>ex</td><td>暂不支持</td></tr></tbody></table><p><strong>&#x2F;guest&#x2F;arch</strong> 是描述该客户机类型各种虚拟硬件的 XML 子文档的根。它有一个名为 “name” 的属性，可用于回溯该子文档。</p><p><strong>&#x2F;guest&#x2F;arch&#x2F;wordsize</strong> 是一个必填元素，用于描述该客户机类型每个字使用的位数。通常为 32 或 64。</p><p><strong>&#x2F;guest&#x2F;arch&#x2F;emulator</strong> 是一个可选元素，用于描述该客户机类型模拟器的默认路径。请注意，对于需要备用二进制文件的客户机类型，仿真器可以被 <strong>&#x2F;guest&#x2F;arch&#x2F;domain&#x2F;emulator</strong> 元素（如下所述）覆盖。</p><p><strong>&#x2F;guest&#x2F;arch&#x2F;loader</strong> 是一个可选元素，用于描述该客户机类型固件加载器的默认路径。请注意，对于使用备用加载器的客户机类型，默认加载器路径可被 <strong>&#x2F;guest&#x2F;arch&#x2F;domain&#x2F;loader</strong> 元素（如下所述）覆盖。目前，只有用于 HVM 客户机的 xen 驱动程序使用了这一功能。</p><p>可以有零个或多个 <strong>&#x2F;guest&#x2F;arch&#x2F;machine</strong> 元素来描述该客户机模拟器可以模拟的默认机器类型。这些 “机器” 通常代表 guest 可以启动的 ABI 或硬件接口。请注意，对于提供其他机器类型的虚拟化技术，这些机器类型可以被 <strong>&#x2F;guest&#x2F;arch&#x2F;domain&#x2F;machine</strong> 元素（如下所述）覆盖。其典型值为 “pc” 和 “isapc”，分别表示基于 PCI 的普通 PC 和基于 ISA 的旧 PC。</p><p>可以有零个或多个 <strong>&#x2F;guest&#x2F;arch&#x2F;domain</strong> XML 子树（但如果 &#x2F;guest&#x2F;arch&#x2F;domain XML 子树为零，则无法启动该驱动程序的任何客户）。每个 <strong>&#x2F;guest&#x2F;arch&#x2F;domain</strong> XML 子树都有可选的 <code>&lt;emulator&gt;</code>、<code>&lt;loader&gt;</code> 和 <code>&lt;machine&gt;</code> 元素，这些元素会覆盖上文指定的默认值。对于缺失的元素，将使用默认值。</p><p><strong>&#x2F;guest&#x2F;features</strong> 可选子文档描述了可启用或禁用的各种附加访客功能，以及它们的默认状态和是否可以打开或关闭。</p><h2 id="3-4-主机信息"><a href="#3-4-主机信息" class="headerlink" title="3.4 主机信息"></a>3.4 主机信息</h2><p>有多种 Python <strong>virConnection</strong> 方法可用于获取虚拟化主机的信息，包括主机名、最大支持客户 CPU 等。</p><h3 id="获取主机名"><a href="#获取主机名" class="headerlink" title="获取主机名"></a>获取主机名</h3><p><strong>getHostname</strong> 方法可用于获取 <strong>gethostname()</strong> 返回的虚拟化主机的主机名。该方法通过 virConnectioninstance 调用，如果成功，将返回一个包含主机名的字符串，该主机名可能扩展为全称域名。如果发生错误，则返回 NULL。以下代码演示了如何使用 <strong>getHostname</strong>：</p><p><strong>例 3.11. 使用 getHostname</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-9.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">host = conn.getHostname()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hostname:&#x27;</span> + host)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="getMaxVcpus"><a href="#getMaxVcpus" class="headerlink" title="getMaxVcpus"></a>getMaxVcpus</h3><p><strong>getMaxVcpus</strong> 方法可用于获取底层虚拟化技术所支持的每个虚拟机的最大虚拟 CPU 数量。该方法将虚拟化 “类型” 作为输入（可以是 <strong>None</strong>），如果成功，则返回所支持的虚拟 CPU 数量。如果出错，则返回 -1。以下代码演示了 <strong>getMaxVcpus</strong> 的使用：</p><p><strong>例 3.12. 使用 getMaxVcpus</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-10.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">vcpus = conn.getMaxVcpus(<span class="literal">None</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Maximum support virtual CPUs:&#x27;</span> + <span class="built_in">str</span>(vcpus))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="getInfo"><a href="#getInfo" class="headerlink" title="getInfo"></a>getInfo</h3><p><strong>getInfo</strong> 方法可用于获取虚拟化主机的各种信息。该方法如果成功则返回一个 Python <strong>列表</strong>，如果出错则返回 <strong>None</strong>。Python <strong>列表</strong> 包含以下成员：</p><table><thead><tr><th><strong>成员</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>list[0]</td><td>表示 CPU 型号的字符串</td></tr><tr><td>list[1]</td><td>内存大小（兆字节）</td></tr><tr><td>list[2]</td><td>运行中的 CPU 数量</td></tr><tr><td>list[3]</td><td>预期 CPU 频率（兆赫）</td></tr><tr><td>list[4]</td><td>NUMA 节点的数量，1 表示统一内存访问</td></tr><tr><td>list[5]</td><td>每个节点的 CPU 插座数量</td></tr><tr><td>list[6]</td><td>每个插座的内核数</td></tr><tr><td>list[7]</td><td>每个核心的线程数</td></tr></tbody></table><p>以下代码演示了 <strong>virNodeGetInfo</strong> 的使用：</p><p><strong>例 3.13. 使用 getInfo</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-12.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">nodeinfo = conn.getInfo()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Model:&#x27;</span> + <span class="built_in">str</span>(nodeinfo[<span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Memory size: &#x27;</span> + <span class="built_in">str</span>(nodeinfo[<span class="number">1</span>]) + <span class="string">&#x27;MB&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Number of CPUs:&#x27;</span> + <span class="built_in">str</span>(nodeinfo[<span class="number">2</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;CPU 的主频:&#x27;</span> + <span class="built_in">str</span>(nodeinfo[<span class="number">3</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;NUMA 节点数:&#x27;</span> + <span class="built_in">str</span>(nodeinfo[<span class="number">4</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;CPU 插座数:&#x27;</span> + <span class="built_in">str</span>(nodeinfo[<span class="number">5</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Number of CPU cores per socket:&#x27;</span> + <span class="built_in">str</span>(nodeinfo[<span class="number">6</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;每个内核的 CPU 线程数:&#x27;</span> + <span class="built_in">str</span>(nodeinfo[<span class="number">7</span>]))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="getCellsFreeMemory"><a href="#getCellsFreeMemory" class="headerlink" title="getCellsFreeMemory"></a>getCellsFreeMemory</h3><p><strong>getCellsFreeMemory</strong> 方法可用于获取系统中部分或全部 NUMA 节点的可用内存量（以千字节为单位）。该方法需要输入起始单元和要检索数据的最大单元数。如果成功，<strong>将</strong>返回 Python <strong>列表</strong>，其中包含每个节点的可用内存量。如果失败，<strong>则</strong>返回 “<strong>none</strong>“。以下代码演示了 <strong>getCellsFreeMemory</strong> 的使用：</p><p><strong>例 3.14. 使用 getCellsFreeMemory</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-13.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">nodeinfo = conn.getInfo()</span><br><span class="line">numnodes = nodeinfo[<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">memlist = conn.getCellsFreeMemory(<span class="number">0</span>, numnodes)</span><br><span class="line">cell = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> cellfreemem <span class="keyword">in</span> memlist:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Node &#x27;</span> + <span class="built_in">str</span>(cell) + <span class="string">&#x27;: &#x27;</span> + <span class="built_in">str</span>(cellfreemem) + <span class="string">&#x27; bytes free memory&#x27;</span>)</span><br><span class="line">    cell += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="getType"><a href="#getType" class="headerlink" title="getType"></a>getType</h3><p><strong>getType</strong> 方法可用于获取此连接上使用的虚拟化类型。如果成功，它将返回一个字符串，表示正在使用的虚拟化类型。如果发生错误，则返回 <strong>None</strong>。以下代码演示了 <strong>getType</strong> 的使用：</p><p><strong>例 3.15. 使用 virConnectGetType</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-14.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Virtualization type: &#x27;</span> + conn.getType())</span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="获取库和驱动程序版本"><a href="#获取库和驱动程序版本" class="headerlink" title="获取库和驱动程序版本"></a>获取库和驱动程序版本</h3><p>libvirt 库具有软件包和库本身的版本信息。如下所示，可以打印这些信息。</p><p><strong>例 3.16. 使用 virConnectGetVersion</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-34.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Package Version: &quot;</span> + libvirt.sys.version)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Library Version:&quot;</span> + <span class="built_in">str</span>(libvirt.sys.version_info))</span><br><span class="line"></span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>程序库支持的每个驱动程序都有自己的版本。版本号为整数：1000000<em>主版本 + 1000</em> 次版本 + 发行版本。下面的示例演示了如何打印驱动程序的版本号。</p><p><strong>例 3.17. 使用 virConnectGetVersion</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-15.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">ver = conn.getVersion()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Version: &#x27;</span> + <span class="built_in">str</span>(ver))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="getURI"><a href="#getURI" class="headerlink" title="getURI"></a>getURI</h3><p><strong>getURI</strong> 方法可用于获取当前连接的 URI。虽然这通常与传入 <strong>打开</strong> 调用的字符串相同，但底层驱动程序有时会将字符串规范化。此方法将返回规范版本。如果成功，它将返回一个 URI 字符串。如果发生错误，则返回 <strong>None</strong>。以下代码演示了如何使用 <strong>getURI</strong>：</p><p><strong>例 3.18. 使用 virConnectGetURI</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-17.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">uri = conn.getURI()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Canonical URI: &#x27;</span> + uri)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="isEncrypted"><a href="#isEncrypted" class="headerlink" title="isEncrypted"></a>isEncrypted</h3><p><strong>isEncrypted</strong> 方法可用于查找给定连接是否已加密。如果成功，加密连接将返回 1，未加密连接将返回 0。如果发生错误，则返回 -1。下面的代码演示了 <strong>isEncrypted</strong> 的使用：</p><p><strong>例 3.19. 使用 virConnectIsEncrypted</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-15.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Connection is encrypted:&#x27;</span> + <span class="built_in">str</span>(conn.isEncrypted()))</span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="isSecure"><a href="#isSecure" class="headerlink" title="isSecure"></a>isSecure</h3><p><strong>isSecure</strong> 方法可用于查找给定连接是否安全。如果一个连接是加密的，或者是在一个不会受到以下攻击的信道上运行，那么它就会被归类为安全连接：</p><p>窃听（如 UNIX 域套接字）。如果连接成功，则返回 1 表示连接安全，返回 0 表示连接不安全。如果发生错误，则返回 -1。以下代码演示了 <strong>isSecure</strong> 的使用：</p><p><strong>例 3.20. 使用 virConnectIsSecure</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-19.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Connection is secure:&#x27;</span> + <span class="built_in">str</span>(conn.isSecure()))</span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="isAlive"><a href="#isAlive" class="headerlink" title="isAlive"></a>isAlive</h3><p>该方法可确定与管理程序的连接是否仍然有效。如果连接是本地连接，或通过未关闭的通道（TCP 或 UNIX 套接字）运行，则该连接将被归类为 “存活” 连接。</p><p><strong>例 3.21. 使用 isAlive</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-21.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">alive = conn.isAlive()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Connection is alive = &quot;</span> + <span class="built_in">str</span>(alive))</span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="compareCPU"><a href="#compareCPU" class="headerlink" title="compareCPU"></a>compareCPU</h3><p>该方法将给定的 CPU 描述与主机 CPU 进行比较。该 XML 描述参数与用于域描述的 XML 描述参数相同。</p><p><strong>例 3.22. 使用 compareCPU</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-22.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">xml = <span class="string">&#x27;&lt;cpu mode=&quot;custom&quot; match=&quot;exact&quot;&gt;&#x27;</span> +\</span><br><span class="line">      <span class="string">&#x27;&lt;model fallback=&quot;forbid&quot;&gt;kvm64&lt;/model&gt;&#x27;</span> +\</span><br><span class="line">      <span class="string">&#x27;&lt;/cpu&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line">retc = conn.compareCPU(xml)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> retc == libvirt.VIR_CPU_COMPARE_ERROR:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;CPU 不一致或出错&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> retc == libvirt.VIR_CPU_COMPARE_INCOMPATIBLE:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;CPU 不兼容&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> retc == libvirt.VIR_CPU_COMPARE_IDENTICAL:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;CPU 完全相同&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> retc == libvirt.VIR_CPU_COMPARE_SUPERSET:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The host CPU is better than the one specified.&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;An Unknown return code was emitted.&quot;</span>)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="getFreeMemory"><a href="#getFreeMemory" class="headerlink" title="getFreeMemory"></a>getFreeMemory</h3><p>getFreeMemory 方法可用于查找主机节点上的可用内存量。注意：大多数 libvirt API 以千字节为单位提供内存大小，但在此函数中，返回值以字节为单位。必要时除以 1024。</p><p><strong>例 3.23. 使用 getFreeMemory</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-23.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">mem = conn.getFreeMemory()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Free memory on the node (host) is &quot;</span> + <span class="built_in">str</span>(mem) + <span class="string">&quot; bytes.&quot;</span>)</span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="getFreePages"><a href="#getFreePages" class="headerlink" title="getFreePages"></a>getFreePages</h3><p>该方法用于查询主机系统中指定大小的空闲页面。对于输入，<strong>pages</strong> 参数是调用者感兴趣的页面大小的 Python 列表（大小单位是千字节，例如传递 2048 表示 2MB），<strong>start</strong> 参数指的是应该收集信息的第一个 NUMA 节点，<strong>cellcount</strong> 参数告诉应该查询多少个连续节点。函数会返回一个 Python 列表，其中包含是否有指定输入大小的页面的指示符。</p><p>如果主机系统不支持所请求大小的内存页，则会出现错误。</p><p><strong>例 3.24. 使用 getFreePages</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-24.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">pages = [<span class="number">2048</span>]</span><br><span class="line">start = <span class="number">0</span></span><br><span class="line">cellcount = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">buf = conn.getFreePages(pages, start, cellcount)</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> page <span class="keyword">in</span> buf:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Page Size: &quot;</span> + <span class="built_in">str</span>(pages[i]) + <span class="string">&quot; Available pages:&quot;</span> + <span class="built_in">str</span>(page))</span><br><span class="line">    ++i</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="获取内存参数"><a href="#获取内存参数" class="headerlink" title="获取内存参数"></a>获取内存参数</h3><p>该方法以字符串形式返回所有可用的内存参数。</p><p><strong>例 3.25. 使用 getFreePages</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-25.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">buf = conn.getMemoryParameters()</span><br><span class="line"><span class="keyword">for</span> parm <span class="keyword">in</span> buf:</span><br><span class="line">    <span class="built_in">print</span>(parm)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="getMemoryStats"><a href="#getMemoryStats" class="headerlink" title="getMemoryStats"></a>getMemoryStats</h3><p>此方法返回单个或所有单个节点（主机）的内存统计信息。它返回一个 Python 字符串列表。</p><p><strong>例 3.26. 使用 getMemoryStats</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-26.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">buf = conn.getMemoryStats(libvirt.VIR_NODE_MEMORY_STATS_ALL_CELLS)</span><br><span class="line"><span class="keyword">for</span> parm <span class="keyword">in</span> buf:</span><br><span class="line">    <span class="built_in">print</span>(parm)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="获取安全模型"><a href="#获取安全模型" class="headerlink" title="获取安全模型"></a>获取安全模型</h3><p>此方法返回当前使用的安全模型（列表）（如果有）。</p><p><strong>例 3.27. 使用 getSecurityModel</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-27.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">model = conn.getSecurityModel()</span><br><span class="line"><span class="built_in">print</span>(model[<span class="number">0</span>] + <span class="string">&quot; &quot;</span> + model[<span class="number">1</span>])</span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="获取系统信息"><a href="#获取系统信息" class="headerlink" title="获取系统信息"></a>获取系统信息</h3><p>该方法以 XML 定义的形式返回系统信息。格式与域 XML 定义相同。</p><p><strong>例 3.28. 使用 getSysinfo</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-28.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">xmlInfo = conn.getSysinfo()</span><br><span class="line"><span class="built_in">print</span>(xmlInfo)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="getCPUMap"><a href="#getCPUMap" class="headerlink" title="getCPUMap"></a>getCPUMap</h3><p>获取主机节点 CPU 的 CPU 映射。</p><p><strong>例 3.29. 使用 getCPUMap</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-29.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span> = conn.getCPUMap()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;CPUs:&quot;</span> + <span class="built_in">str</span>(<span class="built_in">map</span>[<span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Available:&quot;</span> + <span class="built_in">str</span>(<span class="built_in">map</span>[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="getCPUStats"><a href="#getCPUStats" class="headerlink" title="getCPUStats"></a>getCPUStats</h3><p>获取单个或所有 CPU 的统计数据。该方法需要一个代表 CPU 编号的参数，以获取单个 CPU 的统计数据；或使用 <strong>VIR_NODE_CPU_STATS_ALL_CPUS</strong> 值，以获取所有 CPU 的 Python 统计数据列表。</p><p><strong>例 3.30. 使用 getCPUStats</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-30.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">stats = conn.getCPUStats(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;kernel:&quot;</span> + <span class="built_in">str</span>(stats[<span class="string">&#x27;kernel&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;idle: &quot;</span> + <span class="built_in">str</span>(stats[<span class="string">&#x27;idle&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;user: &quot;</span> + <span class="built_in">str</span>(stats[<span class="string">&#x27;user&#x27;</span>]) + <span class="built_in">str</span>(stats[<span class="string">&#x27;user&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;iowait: &quot;</span> + <span class="built_in">str</span>(stats[<span class="string">&#x27;iowait&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="getCPUModelNames"><a href="#getCPUModelNames" class="headerlink" title="getCPUModelNames"></a>getCPUModelNames</h3><p>获取与架构类型匹配的 CPU 名称列表。</p><p><strong>例 3.31. 使用 getCPUModelNames</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example-31.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> libvirt</span><br><span class="line"></span><br><span class="line">conn = <span class="literal">None</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = libvirt.<span class="built_in">open</span>(<span class="string">&quot;qemu:///system&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> libvirt.libvirtError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(e), file=sys.stderr)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">models = conn.getCPUModelNames(<span class="string">&#x27;x86_64&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> model <span class="keyword">in</span> models:</span><br><span class="line">    <span class="built_in">print</span>(model)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><pre><code></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3-连接&quot;&gt;&lt;a href=&quot;#3-连接&quot; class=&quot;headerlink&quot; title=&quot;3 连接&quot;&gt;&lt;/a&gt;3 连接&lt;/h1&gt;&lt;p&gt;在libvirt中，连接是系统中每个操作和对象的基础。任何希望与libvirt交互的实体，无论是virsh、virt-man</summary>
      
    
    
    
    <category term="云计算" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="libvirt" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/libvirt/"/>
    
    
    <category term="云计算" scheme="https://watsonlu6.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="libvirt" scheme="https://watsonlu6.github.io/tags/libvirt/"/>
    
  </entry>
  
  <entry>
    <title>2 libvirt对象模型</title>
    <link href="https://watsonlu6.github.io/libvirt%E6%96%87%E6%A1%A3/2-libvirt%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>https://watsonlu6.github.io/libvirt%E6%96%87%E6%A1%A3/2-libvirt%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</id>
    <published>2024-03-02T07:50:26.000Z</published>
    <updated>2025-03-15T08:00:21.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Libvirt-对象模型"><a href="#Libvirt-对象模型" class="headerlink" title="Libvirt 对象模型"></a>Libvirt 对象模型</h1><p>本章介绍了 libvirt API 和 Python libvirt 模块定义背后的主要原理和架构选择。</p><h2 id="虚拟机连接"><a href="#虚拟机连接" class="headerlink" title="虚拟机连接"></a>虚拟机连接</h2><p>连接是 libvirt API 和 Python libvirt 模块中的主要或顶级对象。在尝试使用几乎所有类或方法之前，需要此对象的一个实例。连接与特定的 hypervisor 相关联，该 hypervisor 可以在与 libvirt 客户端应用程序相同的本地计算机上运行，也可以在网络上的远程计算机上运行。在所有情况下，连接由 <code>virConnect</code> 类的一个实例表示，并由一个 URI 标识。URI 的方案和路径定义了要连接的 hypervisor，而 URI 的主机部分则确定了其所在位置。有关有效 URI 的完整说明，请参阅*第 3.2 节 “URI 格式”*。</p><p>应用程序允许同时打开多个连接，即使在单台机器上使用多种类型的 hypervisor。例如，主机可以提供 KVM 完整机虚拟化和 LXC 容器虚拟化。连接对象可以跨多个线程同时使用。一旦建立了连接，就可以获取到其他受管理的对象的句柄或创建新的受管理对象，第 <em>2.1.2 节 “客户域 “</em> 中对此进行了讨论。</p><h2 id="访客域名"><a href="#访客域名" class="headerlink" title="访客域名"></a>访客域名</h2><p>客户域可以指正在运行的虚拟机或可用于启动虚拟机的配置。连接对象提供方法来枚举客户域、创建新的客户域和管理现有的域。客户域由 <code>virDomain</code> 类的一个实例表示，并具有多个唯一标识符。</p><p><strong>唯一标识符</strong></p><ul><li><strong>ID</strong>：正整数，在一台主机上运行的客户域中唯一，非活动域没有 ID。</li><li><strong>name</strong>：短字符串，在一台主机上的所有客户域（包括运行中和非活动域）中都是唯一的。为确保管理程序之间的最大可移植性，建议名称只包含字母数字（<code>a</code> - <code>Z</code>，<code>0</code> - <code>9</code>）、连字符 (<code>-</code>) 和下划线 (<code>_</code>) 字符。</li><li><strong>UUID</strong>：16 个无符号字节，保证在任何主机上的所有客户域中都是唯一的。RFC 4122 定义了 UUID 的格式，并提供了一个保证唯一性的推荐算法用于生成 UUID。</li></ul><p>客户域可以是瞬态的或持久的。瞬态客户域只能在主机上运行时进行管理。一旦它被关闭电源，所有与其相关的痕迹都将消失。持久客户域的配置由 hypervisor 在主机上的数据存储中维护，以实现定义的格式。因此，当持久客户域关闭电源时，仍然可以管理其非活动配置。可以在运行时将瞬态客户域转换为持久客户域，方法是为其定义一个配置。有关使用客户域对象的更多信息，请参阅第 <em>4 章，客户域</em>。</p><h2 id="虚拟网络"><a href="#虚拟网络" class="headerlink" title="虚拟网络"></a>虚拟网络</h2><p>虚拟网络提供了一种连接单个主机内一个或多个客户域的网络设备的方法。虚拟网络可以是：</p><ul><li>与宿主保持隔离</li><li>允许通过主机操作系统的活动网络接口将流量路由至节点外。这包括对 IPv4 流量应用 NAT 的选项。</li></ul><p>虚拟网络由 <code>virNetwork</code> 类的一个实例表示，有两个唯一标识符：</p><p><strong>唯一标识符</strong></p><ul><li><strong>name</strong>：短字符串，在一台主机上的所有虚拟网络（包括运行中和未激活的）中都是唯一的。为了在不同管理程序之间实现最大的可移植性，应用程序只能在名称中使用 <code>a-Z</code>、<code>0-9</code>、<code>-</code>、<code>_</code> 字符。</li><li><strong>UUID</strong>：16 个无符号字节，保证在任何主机上的所有虚拟网络中都是唯一的。RFC 4122 定义了 UUID 的格式，并提供了生成具有唯一性的 UUID 的推荐算法。</li></ul><p>虚拟网络可以是瞬态的或持久的。瞬态虚拟网络只能在主机上运行时进行管理。一旦将其停止，所有与其相关的痕迹都将消失。持久虚拟网络的配置由 hypervisor 在主机上的数据存储中维护，以实现定义的格式。因此，当持久网络被停止时，仍然可以管理其非活动配置。可以通过为其定义配置来将瞬态网络实时转换为持久网络。</p><p>在安装 libvirt 后，每个主机都将获得一个名为 “default” 的虚拟网络实例，该实例为客户提供 DHCP 服务，并允许 NAT 转换的 IP 连接到主机的接口。这项服务对于具有间歇性网络连接的主机特别有用，例如使用无线网络的笔记本电脑。</p><p>有关使用虚拟网络对象的详细信息，请参阅<em>第 6 章虚拟网络</em>。</p><h2 id="存储池"><a href="#存储池" class="headerlink" title="存储池"></a>存储池</h2><p>存储池对象提供了一种管理主机上所有类型存储的机制，如本地磁盘、逻辑卷组、iSCSI 目标器、光纤通道 HBA 和本地&#x2F;网络文件系统。存储池指的是可分配形成单个卷的存储量。存储池由 <code>virStoragePool</code> 类的一个实例表示，并有一对唯一标识符。</p><p><strong>唯一标识符</strong></p><ul><li><strong>name</strong>：短字符串，在一台主机上的所有存储池（包括运行中和未激活的）中都是唯一的。为了在不同管理程序之间实现最大的可移植性，应用程序只能在名称中使用 <code>a-Z</code>、<code>0-9</code>、<code>-</code>、<code>_</code> 字符。</li><li><strong>UUID</strong>：16 个无符号字节，保证在任何主机上的所有存储池中都是唯一的。RFC 4122 定义了 UUID 的格式，并提供了生成具有唯一性的 UUID 的推荐算法。</li></ul><p>存储池可以是瞬时的，也可以是持久的。瞬时存储池只能在主机上运行时进行管理，一旦关闭电源，所有痕迹都将消失（当然，底层物理存储仍然存在！）。持久存储池的配置由管理程序以实施定义的格式保存在主机上的数据存储中。因此，当持久性存储池停用时，仍然可以管理其未激活的配置。通过为临时存储池定义配置，可将其快速转变为持久存储池。</p><p>有关使用存储池对象的详细信息，请参阅*第 5 章 “存储池”*。</p><h2 id="存储容量"><a href="#存储容量" class="headerlink" title="存储容量"></a>存储容量</h2><p>存储卷对象提供对池中已分配存储块的管理，无论是磁盘分区、逻辑卷、SCSI&#x2F;iSCSI LUN 还是本地&#x2F;网络文件系统中的文件。</p><p>卷分配后，可用于为一个（或多个）虚拟域提供磁盘。卷由 <code>virStorageVol</code> 类的一个实例表示，有三个标识符：</p><p><strong>唯一标识符</strong></p><ul><li><strong>name</strong>：短字符串，在存储池中的所有存储卷中唯一。为了在不同实现之间实现最大的可移植性，应用程序只能在名称中使用 <code>a-Z</code>、<code>0-9</code>、<code>-</code>、<code>_</code> 字符。即使存储池在主机间共享，也不能保证名称在重启或主机间保持稳定。</li><li><strong>密钥</strong>：由任意可打印字符组成的不透明字符串，用于唯一标识池中的加密卷。该密钥在重启时和主机间保持稳定。</li><li><strong>路径</strong>：指向卷的文件系统路径。该路径在一台主机上的所有存储卷中都是唯一的。如果存储池配置了合适的目标路径，卷路径在重启时和主机间都会保持稳定。</li></ul><p>有关使用存储卷对象的更多信息，请参阅*第 5.7 节 “存储卷概述”*。</p><h2 id="主机设备"><a href="#主机设备" class="headerlink" title="主机设备"></a>主机设备</h2><p>主机设备提供主机上可用硬件设备的视图。这既包括物理 USB 或 PCI 设备，也包括这些设备提供的逻辑设备，如网卡、磁盘、磁盘控制器、声卡等。设备可以排列成树形结构，以便识别它们之间的关系。主机设备由 <code>virNodeDev</code> 类的一个实例表示，有一个通用标识符，但特定设备类型可能有自己的唯一标识符。</p><p><strong>唯一标识符</strong></p><ul><li><strong>name</strong>：短字符串，在主机上的所有设备中唯一。命名方案由主机操作系统决定。该名称不能保证在重启时保持稳定。</li></ul><p>物理设备可以从主机操作系统驱动程序中分离出来，这意味着删除所有相关的逻辑设备，然后分配给访客域。物理设备信息在使用存储和网络 API 确定哪些资源可供配置时也很有用。</p><h1 id="驱动模式"><a href="#驱动模式" class="headerlink" title="驱动模式"></a>驱动模式</h1><p>libvirt 库提供了一个稳定的 API 和 ABI，与任何特定的虚拟化技术解耦。此外，许多 API 都有关联的 XML 模式，被视为稳定 ABI 保证的一部分。在内部，有多个公共 ABI 的实现，每个针对不同的虚拟化技术。每个实现称为一个驱动程序（driver）。当获取 <code>virConnect</code> 类的实例时，应用程序开发者可以提供一个 URI 来确定哪个 hypervisor 驱动程序被激活。</p><p>没有两种虚拟化技术具有完全相同的功能。libvirt 的目标不是将应用程序限制在最低公共分母上，因为这将导致 API 功能过于受限。相反，libvirt 试图定义一个与 hypervisor 无关的概念和配置表示，并且可适应未来的扩展。因此，如果两个 hypervisor 实现了类似的功能，libvirt 会为该功能提供统一的控制机制或配置格式。</p><p>如果一个 libvirt 驱动程序没有实现特定的 API，那么它将返回一个 <code>VIR_ERR_NO_SUPPORT</code> 错误代码，以便应用程序可以检测到这一情况。还有一个 API 允许应用程序查询 hypervisor 的某些能力，比如支持的客户 ABIs 的类型。</p><p>在内部，一个 libvirt 驱动程序会尝试利用针对特定虚拟化技术可用的任何管理通道。对于某些驱动程序，这可能要求 libvirt 直接在被管理的主机上运行，并与本地的 hypervisor 进行通信，而其他驱动程序可能能够通过远程 RPC 服务进行通信。对于没有本地远程通信能力的驱动程序，libvirt 提供了一个通用的安全 RPC 服务。这些内容将在本章后面详细讨论。</p><p><strong>Hypervisor 驱动程序</strong></p><ul><li><strong>Xen:</strong> 开源的 Xen hypervisor，提供半虚拟化和完全虚拟化的机器。一个系统驱动程序运行在 Dom0 主机中，直接与 hypervisor、xenstored 和 xend 通信。示例本地 URI 方案为 <code>xen:///</code>。</li><li><strong>QEMU:</strong> 基于任何开源 QEMU 的虚拟化技术，包括 KVM。一个特权系统驱动程序运行在主机中管理 QEMU 进程。每个非特权用户帐户也有一个私有的驱动程序实例。示例特权 URI 方案为 <code>qemu:///system</code>，示例非特权 URI 方案为 <code>qemu:///session</code>。</li><li><strong>UML (User Mode Linux):</strong> 纯粹的半虚拟化技术。一个特权系统驱动程序运行在主机中管理 UML 进程。每个非特权用户帐户也有一个私有的驱动程序实例。示例特权 URI 方案为 <code>uml:///system</code>，示例非特权 URI 方案为 <code>uml:///session</code>。</li><li><strong>OpenVZ:</strong> 基于容器的虚拟化技术，使用修改后的 Linux 主机内核。一个特权系统驱动程序运行在主机中与 OpenVZ 工具通信。示例特权 URI 方案为 <code>openvz:///system</code>。</li><li><strong>LXC:</strong> 原生的基于容器的 Linux 虚拟化技术，自 Linux 内核 2.6.25 版本以来可用。一个特权系统驱动程序运行在主机中与内核通信。示例特权 URI 方案为 <code>lxc:///</code>。</li><li><strong>Remote:</strong> 通用的安全 RPC 服务，与 libvirtd 守护进程通信。使用 TLS、x509 证书、SASL (GSSAPI&#x2F;Kerberos) 和 SSH 隧道进行加密和认证。URI 遵循所需驱动程序的方案，但带有主机名，并在 URI 方案中附加数据传输名称。示例 URI，通过 TLS 通道与 Xen 通信为 <code>xen+tls://somehostname/</code>。通过 SASL 通道与 QEMU 通信为 <code>qemu+tcp:///somehost/system</code>。</li><li><strong>Test:</strong> 一个模拟驱动程序，提供覆盖所有 libvirt API 的虚拟内存 hypervisor。通过允许运行自动化测试来测试使用 libvirt 的应用程序，而不需要处理实际的 hypervisor。示例默认 URI 方案为 <code>test:///default</code>，示例自定义 URI 方案为 <code>test:///path/to/driver/config.xml</code>。</li></ul><h3 id="图-2-1-libvirt-驱动程序架构"><a href="#图-2-1-libvirt-驱动程序架构" class="headerlink" title="图 2.1. libvirt 驱动程序架构"></a>图 2.1. libvirt 驱动程序架构</h3><h1 id="远程管理"><a href="#远程管理" class="headerlink" title="远程管理"></a>远程管理</h1><p>虽然许多虚拟化技术提供远程管理能力，但 libvirt 并不假定这一点，并提供了一个专用驱动程序，允许远程管理任何 libvirt hypervisor 驱动程序。该驱动程序具有多种数据传输方式，为数据通信提供了相当的安全性。设计该驱动程序的目的是确保无论是本地与 libvirt 驱动程序通信还是通过 RPC 服务通信，都具有 100% 的功能等效性。</p><p>除了 libvirt 包含的本地 RPC 服务外，还有一些用于远程管理的替代方案，这些方案在本文档中不会讨论。libvirt-qpid 项目为 QPid 消息服务提供了一个代理，通过消息总线公开所有 libvirt 管理的对象和操作，这与 libvirt 中的 C API 保持了相当接近的 1 对 1 映射。libvirt-CIM 项目提供了一个 CIM 代理，将 libvirt 对象模型映射到 DMTF 虚拟化架构。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>RPC 服务的服务器端由 libvirtd 守护进程提供，必须在被管理的主机上运行。在默认部署中，该守护进程只会监听本地 UNIX 域套接字上的连接，这仅允许 libvirt 客户端使用 SSH 隧道数据传输。通过配置合适的 x509 证书或 SASL 凭据，可以让 libvirtd 守护进程监听 TCP 套接字，接受直接的、非隧道的客户端连接。</p><p>从之前的 libvirt 驱动程序 URI 示例可以看出，对于本地 libvirt 连接，URI 中的主机名字段总是留空。要使用 libvirt RPC 驱动程序，本地 URI 只需进行两处更改。至少需要指定一个主机名，此时 libvirt 将尝试使用直接的 TLS 数据传输。可以通过在 URI 方案中附加数据传输名称来请求替代的数据传输方式。本文档<em>第 3.2.2 节 “远程 URI “</em> 将详细介绍 URI 格式。</p><h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><p>为了应对各种各样的部署环境，libvirt RPC 服务支持多种数据传输，所有这些传输都可以配置符合行业标准的加密和身份验证功能。</p><p><strong>表 2.1. 传输</strong></p><table><thead><tr><th><strong>传输</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>tls</strong></td><td>通过 TLS 协议运行的 TCP 套接字。这是默认的数据传输方式，如果没有明确请求其他方式，将使用端口 16514 上的 TCP 连接。至少需要为服务器配置一个 x509 证书颁发机构并颁发服务器证书。libvirtd 服务器可以选择配置为要求客户端出示 x509 证书作为认证手段。</td></tr><tr><td><strong>tcp</strong></td><td>通过不使用 TLS 协议的 TCP 套接字进行数据传输。除非启用了 SASL 认证服务并配置了提供加密的插件，否则不应在不受信任的网络上使用此数据传输方式。TCP 连接使用端口 16509。</td></tr><tr><td><strong>unix</strong></td><td>仅限本地数据传输，允许用户连接到以不同用户账户运行的 <code>libvirtd</code> 守护进程。由于只能在本地计算机上访问，因此未加密。标准套接字名称为 <code>/var/run/libvirt/libvirt-sock</code>，用于完全管理功能；<code>/var/run/libvirt/libvirt-sock-ro</code>，用于仅限于只读操作的套接字。</td></tr><tr><td><strong>ssh</strong></td><td>RPC 数据通过 SSH 连接隧道传输到远程机器。这要求远程机器上安装了 Netcat (nc)，并且 libvirtd 运行时启用了 UNIX 域套接字。建议将 SSH 配置为不需要客户端应用程序输入密码。例如，如果使用 SSH 公钥认证，建议运行 ssh-agent 来缓存密钥凭据。GSSAPI 是 SSH 传输的另一种有用的认证模式，允许使用预初始化的 Kerberos 凭证缓存。</td></tr><tr><td><strong>ext</strong></td><td>任何能够通过 libvirt 范围之外的方式与远程机器建立连接的外部程序。如果内置的数据传输方式都不令人满意，这允许应用程序提供一个辅助程序，通过自定义通道代理 RPC 数据。</td></tr></tbody></table><h2 id="认证方案"><a href="#认证方案" class="headerlink" title="认证方案"></a>认证方案</h2><p>为了应对各种各样的部署环境，libvirt RPC 服务在其数据传输上支持多种身份验证方案，并具有符合行业标准的加密和身份验证功能。身份验证方案的选择由管理员在 <code>/etc/libvirt/libvirtd.conf</code> 文件中配置。</p><p><strong>表 2.2. 计划</strong></p><table><thead><tr><th><strong>计划</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>sasl</strong></td><td>SASL 是一个行业标准，用于可插拔的认证机制。每个插件具有多种功能，其优劣讨论超出了本文档的范围。对于 TLS 数据传输，有多种插件可供选择，因为 TLS 为网络通道提供数据加密。对于 TCP 数据传输，libvirt 会拒绝使用任何不支持数据加密的插件，这实际上将选择限制为 GSSAPI&#x2F;Kerberos。如果需要对本地用户进行强认证，也可以选择在 UNIX 域套接字数据传输上启用 SASL。</td></tr><tr><td><strong>polkit</strong></td><td>PolicyKit 是一种适用于本地桌面虚拟化部署的认证方案，仅用于 UNIX 域套接字数据传输。它使 libvirtd 守护进程能够验证客户端应用程序是否在本地 X 桌面会话中运行。可以配置为自动允许已登录用户访问，或提示他们输入自己的密码，或超级用户（root）的密码。</td></tr><tr><td><strong>x509</strong></td><td>TLS 数据传输虽然不是严格意义上的身份验证方案，但可以配置为强制使用客户端 x509 证书。然后，服务器可将客户端区分名称列入白名单，以控制访问。</td></tr></tbody></table><h1 id="生成-TLS-证书"><a href="#生成-TLS-证书" class="headerlink" title="生成 TLS 证书"></a>生成 TLS 证书</h1><p>Libvirt 支持用于验证服务器和客户端身份的 TLS 证书。其中涉及两种不同的检查：</p><ol><li>客户端通过匹配服务器发送的证书和服务器的主机名来检查是否连接到正确的服务器。可以通过添加 <code>?no_verify=1</code> 来禁用这种检查。详情请参阅*表 3.3 “远程 URI 的附加参数”*。</li><li>服务器会进行检查，确保只有允许的客户端才能连接。这可以通过：<ul><li>客户的 IP 地址。</li><li>客户 IP 地址和客户证书。</li></ul></li></ol><p>可使用 <code>libvirtd.conf</code> 文件启用或禁用服务器检查。<br>要进行全面的证书检查，您需要为服务器和所有客户端配备由公认的证书颁发机构（CA）签发的证书。为了避免从商业 CA 获取证书的费用，可以选择建立自己的 CA，并告知服务器和客户端信任由自己的 CA 签发的证书。为此，请按照下一节中的说明进行操作。</p><p>请注意，<code>libvirtd.conf</code> 的默认配置允许任何客户端进行连接，只要它们拥有 CA 为其 IP 地址签发的有效证书。根据您的要求，这一设置可能需要更多或更少的许可。</p><h2 id="公钥基础设施的设置"><a href="#公钥基础设施的设置" class="headerlink" title="公钥基础设施的设置"></a>公钥基础设施的设置</h2><p><strong>表 2.3. 公钥设置</strong></p><table><thead><tr><th><strong>地点</strong></th><th><strong>机器</strong></th><th><strong>说明</strong></th><th><strong>必填字段</strong></th></tr></thead><tbody><tr><td><strong>&#x2F;etc&#x2F;pki&#x2F;CA&#x2F;cacert.pem</strong></td><td><strong>已在服务器上安装</strong></td><td><strong>服务器私钥</strong></td><td><strong>不适用</strong></td></tr><tr><td><strong>&#x2F;etc&#x2F;pki&#x2F;libvirt&#x2F;servercert.pem</strong></td><td><strong>已在服务器上安装</strong></td><td><strong>由 CA 签发的服务器证书</strong></td><td><strong>通用名 (CN) 必须是客户端看到的服务器主机名</strong></td></tr><tr><td><strong>&#x2F;etc&#x2F;pki&#x2F;libvirt&#x2F;private&#x2F;clientkey.pem</strong></td><td><strong>安装在客户端</strong></td><td><strong>客户的私人密钥</strong></td><td><strong>不适用</strong></td></tr><tr><td><strong>&#x2F;etc&#x2F;pki&#x2F;CA&#x2F;cacert.pem</strong></td><td><strong>安装在客户端</strong></td><td><strong>由 CA 签发的客户证书</strong></td><td><strong>可根据访问控制列表检查区分名称 (DN)（tls_allowed_dn_list）</strong></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Libvirt-对象模型&quot;&gt;&lt;a href=&quot;#Libvirt-对象模型&quot; class=&quot;headerlink&quot; title=&quot;Libvirt 对象模型&quot;&gt;&lt;/a&gt;Libvirt 对象模型&lt;/h1&gt;&lt;p&gt;本章介绍了 libvirt API 和 Python lib</summary>
      
    
    
    
    <category term="云计算" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="libvirt" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/libvirt/"/>
    
    
    <category term="云计算" scheme="https://watsonlu6.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="libvirt" scheme="https://watsonlu6.github.io/tags/libvirt/"/>
    
  </entry>
  
  <entry>
    <title>1 libvirt概述</title>
    <link href="https://watsonlu6.github.io/libvirt%E6%96%87%E6%A1%A3/1-libvirt%E6%A6%82%E8%BF%B0/"/>
    <id>https://watsonlu6.github.io/libvirt%E6%96%87%E6%A1%A3/1-libvirt%E6%A6%82%E8%BF%B0/</id>
    <published>2024-03-01T07:50:26.000Z</published>
    <updated>2025-03-15T08:00:16.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Libvirt-概述"><a href="#Libvirt-概述" class="headerlink" title="Libvirt 概述"></a>Libvirt 概述</h1><p>Libvirt 是一个独立于管理程序的虚拟化 API 和工具包，能够与一系列操作系统的虚拟化功能进行交互。它是 GNU 宽通用公共许可证下的自由软件。<br>本章介绍 libvirt 并定义本指南中的常用术语。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Libvirt 提供了一个通用、通用和稳定的层，用于安全地管理节点上的域。由于节点可能位于远程位置，libvirt 在管理程序支持这些操作的范围内，提供了配置、创建、修改、监控、控制、迁移和停止域所需的所有方法。<br>虽然 libvirt 可以同时访问多个节点，但其方法仅限于单节点操作。Libvirt 设计用于在多个虚拟化环境中运行，这意味着更多的通用功能将作为方法和函数提供。因此，可能无法提供某些特定功能。例如，它不提供高级虚拟化策略或多节点管理功能，如负载平衡。但是，方法的稳定性确保了这些功能可以在 libvirt 上实现。为了保持这种稳定性，libvirt 试图将应用程序与虚拟化框架底层的频繁变更隔离开来。<br>Libvirt 旨在作为更高级管理工具和应用程序的构建模块，侧重于单个节点的虚拟化，唯一的例外是多节点功能之间的域迁移。它提供了枚举、监控和使用受管节点上可用资源的方法，包括 CPU、内存、存储、网络和非统一内存访问（NUMA）分区。虽然管理节点可以与管理程序位于不同的物理机上，但这只能通过安全协议来实现。<br>本指南无意作为整个 Python libvirt 接口的完整参考。本指南中涉及的函数、类和方法列表只是部分内容，远远不够完整。在安装了 libvirt-python 模块的任何主机（大多数主机）上都可以找到完整的参考资料。在任何命令行终端运行 <code>pydoc libvirt</code> 命令即可获得。</p><h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><p>为避免对本指南中使用的术语和概念产生歧义，请参阅下表了解其定义。</p><h3 id="表-1-1-术语"><a href="#表-1-1-术语" class="headerlink" title="表 1.1. 术语"></a>表 1.1. 术语</h3><table><thead><tr><th><strong>术语</strong></th><th><strong>定义</strong></th></tr></thead><tbody><tr><td><strong>Domain</strong></td><td>在管理程序提供的虚拟机上运行的操作系统（或容器虚拟化情况下的子系统）实例。</td></tr><tr><td><strong>Hypervisor</strong></td><td>允许在一组虚拟机中虚拟化节点的软件层，这些虚拟机的配置可能与节点本身不同。</td></tr><tr><td><strong>Node</strong></td><td>单个物理服务器。节点可以是多种不同类型中的任何一种，通常按其主要用途来称呼。例如，存储节点、集群节点和数据库节点。</td></tr><tr><td><strong>Storage Pool</strong></td><td>存储介质（如物理硬盘驱动器）的集合。存储池被细分为更小的容器，称为卷，然后可分配给一个或多个域。</td></tr><tr><td><strong>Volume</strong></td><td>从存储池中分配的存储空间。卷可分配给一个或多个域使用，通常在域内用作虚拟硬盘驱动器。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Libvirt-概述&quot;&gt;&lt;a href=&quot;#Libvirt-概述&quot; class=&quot;headerlink&quot; title=&quot;Libvirt 概述&quot;&gt;&lt;/a&gt;Libvirt 概述&lt;/h1&gt;&lt;p&gt;Libvirt 是一个独立于管理程序的虚拟化 API 和工具包，能够与一系列</summary>
      
    
    
    
    <category term="云计算" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="libvirt" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/libvirt/"/>
    
    
    <category term="云计算" scheme="https://watsonlu6.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="libvirt" scheme="https://watsonlu6.github.io/tags/libvirt/"/>
    
  </entry>
  
  <entry>
    <title>Cpeh PG常见故障处理</title>
    <link href="https://watsonlu6.github.io/Storage/Ceph/Ceph-PG%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/"/>
    <id>https://watsonlu6.github.io/Storage/Ceph/Ceph-PG%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/</id>
    <published>2022-10-08T06:53:31.000Z</published>
    <updated>2024-09-08T09:47:49.358Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PG故障排除"><a href="#PG故障排除" class="headerlink" title="PG故障排除"></a>PG故障排除</h2><h4 id="PG-永远无法变干净"><a href="#PG-永远无法变干净" class="headerlink" title="PG 永远无法变干净"></a>PG 永远无法变干净</h4><p>如果在创建集群后，任何 PG 保持在 active 状态、active+remapped 状态或 active+degraded 状态，并且永远无法达到 active+clean 状态，那么可能是配置出现了问题。在这种情况下，可能需要查看 Pool、PG 和 CRUSH 配置参考的设置，并进行适当调整。一般来说，运行集群时应使用多个 OSD，并且池的大小应大于两个对象副本。</p><ol><li><p><strong>单节点集群</strong><br>  Ceph 不再提供单节点操作的文档。按定义，分布式计算系统不应在单节点上运行。在包含 Ceph 守护进程的单节点上安装客户端内核模块可能会由于 Linux 内核本身的问题而导致死锁（除非使用虚拟机作为客户端）。尽管有上述限制，您仍可以在单节点配置中实验 Ceph。<br>  要在单节点上创建集群，必须在创建监视器和 OSD 之前，将 Ceph 配置文件中的 <code>osd_crush_chooseleaf_type</code> 设置从默认的 1（表示主机或节点）更改为 0（表示 OSD）。这告诉 Ceph 允许在同一主机上放置另一个 OSD。如果您尝试设置单节点集群，并且 <code>osd_crush_chooseleaf_type</code> 大于 0，Ceph 将尝试将一个 OSD 的 PG 与另一个 OSD 的 PG 放置在另一个节点、机箱、机架、行或数据中心中，具体取决于设置。<br>  <strong>提示</strong><br>  不要将内核客户端直接安装在与 Ceph 存储集群相同的节点上。这样可能会产生内核冲突。然而，您可以在单节点上通过虚拟机 (VMs) 安装内核客户端。<br>  如果您使用单个磁盘创建 OSD，则必须先手动创建数据目录。</p></li><li><p><strong>OSDs 少于副本</strong><br>  如果两个 OSD 处于 up 和 in 状态，但 PG 并未处于 active + clean 状态，可能是 <code>osd_pool_default_size</code> 设置大于 2。<br>  解决这种情况有几种方法。如果您想以 active + degraded 状态运行集群并保持两个副本，您可以将 <code>osd_pool_default_min_size</code> 设置为 2，这样可以在 active + degraded 状态下写入对象。您也可以将 <code>osd_pool_default_size</code> 设置为 2，这样只会有两个存储副本（原始副本和一个副本）。在这种情况下，集群应达到 active + clean 状态。<br>  <strong>注意</strong><br>  您可以在集群运行时进行更改。如果您在 Ceph 配置文件中进行更改，可能需要重新启动集群。</p></li><li><p><strong>POOL SIZE &#x3D; 1</strong><br>  如果将 <code>osd_pool_default_size</code> 设置为 1，则对象只有一个副本。OSDs 依赖其他 OSDs 来告诉它们应该拥有哪些对象。如果一个 OSD 有一个对象副本而没有第二个副本，那么就没有第二个 OSD 来告诉第一个 OSD 它应该拥有这个副本。对于映射到第一个 OSD 的每个 PG（请参见 <code>ceph pg dump</code>），您可以通过运行以下命令来强制第一个 OSD 注意它需要的 PG：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd force-create-pg &lt;pgid&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>CRUSH MAP 错误</strong><br>  如果集群中的任何 PG 不干净，则可能是 CRUSH 映射中存在错误。</p></li></ol><h4 id="PG卡住"><a href="#PG卡住" class="headerlink" title="PG卡住"></a>PG卡住</h4><p>PG 进入“degraded”或“peering”状态在组件故障后是正常的。这些状态通常反映了故障恢复过程中的预期进展。然而，若一个 PG 长时间停留在这些状态中，可能是更大问题的迹象。因此，Ceph 监视器会在 PG “卡住”在非最佳状态时发出警告。具体检查的状态包括：</p><ul><li><p><strong>inactive</strong> - PG 长时间未处于活跃状态（即无法处理读写请求）。</p></li><li><p><strong>unclean</strong> - PG 长时间未处于干净状态（即无法完全从先前的故障中恢复）。</p></li><li><p><strong>stale</strong> - PG 状态未被 ceph-osd 更新。这表明存储该 PG 的所有节点可能都已宕机。<br>通过运行以下命令来列出卡住的PG：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ceph pg dump_stuck stale</span><br><span class="line">ceph pg dump_stuck inactive</span><br><span class="line">ceph pg dump_stuck unclean</span><br></pre></td></tr></table></figure></li><li><p><strong>卡住的 stale PG</strong> 通常表明关键的 ceph-osd 守护进程未运行。</p></li><li><p><strong>卡住的 inactive PG</strong> 通常表明存在 peering 问题（见 PG Down - Peering Failure）。</p></li><li><p><strong>卡住的 unclean PG</strong> 通常表明某些因素阻止了恢复完成，可能是未找到的对象（见 Unfound Objects）。</p></li></ul><h4 id="PG-下线-对等连接失败"><a href="#PG-下线-对等连接失败" class="headerlink" title="PG 下线 - 对等连接失败"></a>PG 下线 - 对等连接失败</h4><p>在某些情况下，ceph-osd peering 过程可能会遇到问题，导致 PG 无法变为活跃和可用。在这种情况下，运行 <code>ceph health detail</code> 命令会报告类似以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ceph health detail</span><br><span class="line">HEALTH_ERR 7 pgs degraded; 12 pgs down; 12 pgs peering; 1 pgs recovering; 6 pgs stuck unclean; 114/3300 degraded (3.455%); 1/3 <span class="keyword">in</span> osds are down</span><br><span class="line">...</span><br><span class="line">pg 0.5 is down+peering</span><br><span class="line">pg 1.4 is down+peering</span><br><span class="line">...</span><br><span class="line">osd.1 is down since epoch 69, last address 192.168.106.220:6801/8651</span><br></pre></td></tr></table></figure><p>查询集群以确定为什么 PG 被标记为 down，可以运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ceph pg 0.5 query</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;state&quot;</span>: <span class="string">&quot;down+peering&quot;</span>,</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">&quot;recovery_state&quot;</span>: [</span><br><span class="line">       &#123; <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Started\/Primary\/Peering\/GetInfo&quot;</span>,</span><br><span class="line">         <span class="string">&quot;enter_time&quot;</span>: <span class="string">&quot;2012-03-06 14:40:16.169679&quot;</span>,</span><br><span class="line">         <span class="string">&quot;requested_info_from&quot;</span>: []&#125;,</span><br><span class="line">       &#123; <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Started\/Primary\/Peering&quot;</span>,</span><br><span class="line">         <span class="string">&quot;enter_time&quot;</span>: <span class="string">&quot;2012-03-06 14:40:16.169659&quot;</span>,</span><br><span class="line">         <span class="string">&quot;probing_osds&quot;</span>: [</span><br><span class="line">               0,</span><br><span class="line">               1],</span><br><span class="line">         <span class="string">&quot;blocked&quot;</span>: <span class="string">&quot;peering is blocked due to down osds&quot;</span>,</span><br><span class="line">         <span class="string">&quot;down_osds_we_would_probe&quot;</span>: [</span><br><span class="line">               1],</span><br><span class="line">         <span class="string">&quot;peering_blocked_by&quot;</span>: [</span><br><span class="line">               &#123; <span class="string">&quot;osd&quot;</span>: 1,</span><br><span class="line">                 <span class="string">&quot;current_lost_at&quot;</span>: 0,</span><br><span class="line">                 <span class="string">&quot;comment&quot;</span>: <span class="string">&quot;starting or marking this osd lost may let us proceed&quot;</span>&#125;]&#125;,</span><br><span class="line">       &#123; <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Started&quot;</span>,</span><br><span class="line">         <span class="string">&quot;enter_time&quot;</span>: <span class="string">&quot;2012-03-06 14:40:16.169513&quot;</span>&#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>recovery_state</code> 部分告诉我们 peering 被阻止是由于 ceph-osd 守护进程宕机，具体是 osd.1。在这种情况下，我们可以启动该 ceph-osd，恢复将继续进行。或者，如果 osd.1 发生灾难性故障（例如磁盘故障），可以告知集群该 OSD 已丢失，并指示集群尽可能应对。</p><p><strong>重要</strong><br>告知集群一个 OSD 已丢失是危险的，因为集群不能保证其他副本的数据是一致和最新的。<br>要报告 OSD 丢失并指示 Ceph 继续尝试恢复，可以运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd lost 1</span><br></pre></td></tr></table></figure><p>恢复将继续进行。</p><h4 id="未找到的对象"><a href="#未找到的对象" class="headerlink" title="未找到的对象"></a>未找到的对象</h4><p>在某些故障组合下，Ceph 可能会报告未找到的对象，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ceph health detail</span><br><span class="line">HEALTH_WARN 1 pgs degraded; 78/3778 unfound (2.065%)</span><br><span class="line">pg 2.4 is active+degraded, 78 unfound</span><br></pre></td></tr></table></figure><p>这意味着存储集群知道一些对象（或现有对象的新副本）存在，但没有找到它们的副本。以下是这种情况可能发生的示例：一个 PG 的数据在两个 OSD 上，我们称它们为“1”和“2”：</p><ol><li>OSD 1 发生故障。</li><li>OSD 2 单独处理一些写操作。</li><li>OSD 1 重新上线。</li><li>OSD 1 和 OSD 2 重新进行 peering，O<strong>SD 1 上缺失的对象被排队等待恢复。</strong></li><li>在新的对象被复制之前，OSD 2 发生故障。<br>此时，OSD 1 知道这些对象存在，但没有活跃的 ceph-osd 拥有这些对象的副本。在这种情况下，对这些对象的 IO 请求将被阻塞，集群希望故障节点尽快恢复。这被认为比直接返回 IO 错误给用户更可取。</li></ol><p><strong>注意</strong><br>上述情况是将 <code>size=2</code> 设置在复制池和 <code>m=1</code> 设置在纠删码池时可能导致数据丢失的原因之一。</p><p>通过运行以下命令来识别哪些对象未找到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ceph pg 2.4 list_unfound [starting offset, <span class="keyword">in</span> json]</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;num_missing&quot;</span>: 1,</span><br><span class="line">  <span class="string">&quot;num_unfound&quot;</span>: 1,</span><br><span class="line">  <span class="string">&quot;objects&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="string">&quot;oid&quot;</span>: &#123;</span><br><span class="line">              <span class="string">&quot;oid&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">              <span class="string">&quot;key&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">              <span class="string">&quot;snapid&quot;</span>: -2,</span><br><span class="line">              <span class="string">&quot;hash&quot;</span>: 2249616407,</span><br><span class="line">              <span class="string">&quot;max&quot;</span>: 0,</span><br><span class="line">              <span class="string">&quot;pool&quot;</span>: 2,</span><br><span class="line">              <span class="string">&quot;namespace&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&quot;need&quot;</span>: <span class="string">&quot;43&#x27;251&quot;</span>,</span><br><span class="line">          <span class="string">&quot;have&quot;</span>: <span class="string">&quot;0&#x27;0&quot;</span>,</span><br><span class="line">          <span class="string">&quot;flags&quot;</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line">          <span class="string">&quot;clean_regions&quot;</span>: <span class="string">&quot;clean_offsets: [], clean_omap: 0, new_object: 1&quot;</span>,</span><br><span class="line">          <span class="string">&quot;locations&quot;</span>: [</span><br><span class="line">              <span class="string">&quot;0(3)&quot;</span>,</span><br><span class="line">              <span class="string">&quot;4(2)&quot;</span></span><br><span class="line">          ]</span><br><span class="line">      &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;state&quot;</span>: <span class="string">&quot;NotRecovering&quot;</span>,</span><br><span class="line">  <span class="string">&quot;available_might_have_unfound&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;might_have_unfound&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="string">&quot;osd&quot;</span>: <span class="string">&quot;2(4)&quot;</span>,</span><br><span class="line">          <span class="string">&quot;status&quot;</span>: <span class="string">&quot;osd is down&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;more&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果单次结果中列出的对象过多，<code>more</code> 字段将为 <code>true</code>，你可以查询更多信息。（最终命令行工具将会隐藏这一点，但现在还没有。）<br>接下来，你可以识别哪些 OSD 已被探测或可能包含数据。<br>在列表的末尾（在 <code>more: false</code> 之前），<code>might_have_unfound</code> 是在 <code>available_might_have_unfound</code> 为 <code>true</code> 时提供的。这相当于 <code>ceph pg #.# query</code> 的输出。它可以避免直接使用 <code>query</code>。提供的 <code>might_have_unfound</code> 信息与 <code>query</code> 的输出方式相同，仅不同的是，状态为“已探测”的 OSD 会被忽略。<br><strong>查询的使用：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ceph pg 2.4 query</span><br><span class="line"><span class="string">&quot;recovery_state&quot;</span>: [</span><br><span class="line">     &#123; <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Started\/Primary\/Active&quot;</span>,</span><br><span class="line">       <span class="string">&quot;enter_time&quot;</span>: <span class="string">&quot;2012-03-06 15:15:46.713212&quot;</span>,</span><br><span class="line">       <span class="string">&quot;might_have_unfound&quot;</span>: [</span><br><span class="line">             &#123; <span class="string">&quot;osd&quot;</span>: 1,</span><br><span class="line">               <span class="string">&quot;status&quot;</span>: <span class="string">&quot;osd is down&quot;</span>&#125;]&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，集群知道 osd.1 可能有数据，但它已宕机。以下是可能的状态范围：</p><ul><li>已探测</li><li>正在查询</li><li>OSD 已宕机</li><li>尚未查询</li></ul><p>有时集群需要一些时间来查询可能的位置。可能还有其他未列出的对象可能存在的位置。例如：如果一个 OSD 停止并从集群中移除，然后集群完全恢复，然后通过随后的故障集群最终出现未找到的对象，集群将忽略已移除的 OSD。（然而，这种情况不太可能发生。）</p><p>如果所有可能的位置都已被查询，且对象仍然丢失，你可能需要放弃这些丢失的对象。这仅在发生了不寻常的故障组合，导致集群在写入之前了解了写入操作的情况时才可能发生。要将“未找到”的对象标记为“丢失”，运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph pg 2.5 mark_unfound_lost revert|delete</span><br></pre></td></tr></table></figure><p>这里的最后一个参数（<code>revert|delete</code>）指定了集群应如何处理丢失的对象。</p><ul><li><code>delete</code> 选项将使集群完全忘记这些对象。</li><li><code>revert</code> 选项（对于纠删码池不可用）将回滚到对象的先前版本，或（如果它是新对象）完全忘记该对象。使用 <code>revert</code> 时请小心，因为它可能会混淆期望对象存在的应用程序。</li></ul><h4 id="无家-PG"><a href="#无家-PG" class="headerlink" title="无家 PG"></a>无家 PG</h4><p>如果所有具有特定 PG 副本的 OSD 都发生故障，那么包含这些 PG 的对象存储子集将变得不可用，监视器将无法接收到这些 PG 的状态更新。监视器会将主 OSD 已故障的任何 PG 标记为 stale。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceph health</span><br><span class="line">HEALTH_WARN 24 pgs stale; 3/300 <span class="keyword">in</span> osds are down</span><br></pre></td></tr></table></figure><p>通过运行以下命令来识别哪些 PG 是 stale 的，以及最后一个存储这些 stale PG 的 OSD 是哪些：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ceph health detail</span><br><span class="line">HEALTH_WARN 24 pgs stale; 3/300 <span class="keyword">in</span> osds are down</span><br><span class="line">...</span><br><span class="line">pg 2.5 is stuck stale+active+remapped, last acting [2,0]</span><br><span class="line">...</span><br><span class="line">osd.10 is down since epoch 23, last address 192.168.106.220:6800/11080</span><br><span class="line">osd.11 is down since epoch 13, last address 192.168.106.220:6803/11539</span><br><span class="line">osd.12 is down since epoch 24, last address 192.168.106.220:6806/11861</span><br></pre></td></tr></table></figure><p>此输出表明 PG 2.5（pg 2.5）最后由 osd.0 和 osd.2 管理。重启这些 OSD 以允许集群恢复该 PG。</p><h4 id="只有少数-OSD-接收数据"><a href="#只有少数-OSD-接收数据" class="headerlink" title="只有少数 OSD 接收数据"></a>只有少数 OSD 接收数据</h4><p>如果集群中的只有少数节点在接收数据，请检查池中的 PG 数量，如 PG 文档中所述。由于 PG 会在涉及将集群中的 PG 数量除以集群中 OSD 数量的操作中映射到 OSD，因此在这种操作中，少量的 PG（余数）有时不会在集群中分布。在这种情况下，创建一个 PG 数量是 OSD 数量倍数的池。有关详细信息，请参见 PG。有关如何更改用于确定每个池分配多少 PG 的默认值的说明，请参见 Pool、PG 和 CRUSH 配置参考。</p><h4 id="无法写入数据"><a href="#无法写入数据" class="headerlink" title="无法写入数据"></a>无法写入数据</h4><p>如果集群正常运行，但一些 OSD 已经关闭且无法写入数据，请确保在池中运行了最小数量的 OSD。如果池中没有运行最小数量的 OSD，Ceph 不会允许你向其写入数据，因为无法保证 Ceph 可以复制你的数据。有关详细信息，请参见 Pool、PG 和 CRUSH 配置参考中的 <code>osd_pool_default_min_size</code>。</p><h3 id="PG-状态不一致"><a href="#PG-状态不一致" class="headerlink" title="PG 状态不一致"></a>PG 状态不一致</h3><p>如果命令 <code>ceph health detail</code> 返回 active + clean + inconsistent 状态，这可能表示在清理过程中发生了错误。通过运行以下命令来识别不一致的 PG：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ceph health detail</span><br><span class="line">HEALTH_ERR 1 pgs inconsistent; 2 scrub errors</span><br><span class="line">pg 0.6 is active+clean+inconsistent, acting [0,1,2]</span><br><span class="line">2 scrub errors</span><br></pre></td></tr></table></figure><p>或者，如果你希望以编程方式检查输出，可以运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rados list-inconsistent-pg rbd</span><br><span class="line">[<span class="string">&quot;0.6&quot;</span>]</span><br></pre></td></tr></table></figure><p>在最坏的情况下，我们可能会在多个对象中发现不同的不一致。如果 PG 0.6 中名为 foo 的对象被截断，<code>rados list-inconsistent-pg rbd</code> 的输出可能类似于：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">rados list-inconsistent-obj <span class="number">0.6</span> --format=json-pretty</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;epoch&quot;</span><span class="punctuation">:</span> <span class="number">14</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;inconsistents&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;foo&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;nspace&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;locator&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;snap&quot;</span><span class="punctuation">:</span> <span class="string">&quot;head&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;errors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;data_digest_mismatch&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;size_mismatch&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;union_shard_errors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;data_digest_mismatch_info&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;size_mismatch_info&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;selected_object_info&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0:602f83fe:::foo:head(16&#x27;1 client.4110.0:1 dirty|data_digest|omap_digest s 968 uv 1 dd e978e67f od ffffffff alloc_hint [0 0 0])&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;shards&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;osd&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;errors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">968</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;omap_digest&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0xffffffff&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;data_digest&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0xe978e67f&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;osd&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;errors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">968</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;omap_digest&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0xffffffff&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;data_digest&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0xe978e67f&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;osd&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;errors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="string">&quot;data_digest_mismatch_info&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;size_mismatch_info&quot;</span></span><br><span class="line">                    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;omap_digest&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0xffffffff&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;data_digest&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0xffffffff&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在这种情况下，输出表示以下内容：</p><ul><li>唯一的不一致对象名为 foo，其头部存在不一致。</li><li>不一致分为两类：<ul><li><code>errors</code>：这些错误表示分片之间的不一致，没有指示哪些分片有问题。检查 <code>shards</code> 数组中的错误，以确定问题所在。<ul><li><code>data_digest_mismatch</code>：从 OSD.2 读取的副本摘要与从 OSD.0 和 OSD.1 读取的副本摘要不同。</li><li><code>size_mismatch</code>：从 OSD.2 读取的副本大小为 0，但 OSD.0 和 OSD.1 报告的大小为 968。</li></ul></li><li><code>union_shard_errors</code>：分片数组中所有特定分片错误的联合。这些错误包括 <code>read_error</code> 和其他类似错误。以 <code>oi</code> 结尾的错误表示与 <code>selected_object_info</code> 进行比较。检查 <code>shards</code> 数组以确定哪些分片存在哪些错误。<ul><li><code>data_digest_mismatch_info</code>：对象信息中存储的摘要不是 <code>0xffffffff</code>，这是从 OSD.2 读取的分片计算出的。</li><li><code>size_mismatch_info</code>：对象信息中存储的大小与从 OSD.2 读取的大小不同，后者为 0。</li></ul></li></ul></li></ul><p><strong>警告</strong>：如果 <code>read_error</code> 列在分片的错误属性中，可能是由于物理存储错误导致的不一致。在这种情况下，请检查该 OSD 使用的存储。</p><p>在尝试修复驱动器之前，请检查 dmesg 和 smartctl 的输出。</p><p>要修复不一致的 PG，运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph pg repair &#123;placement-group-ID&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph pg repair 1.4</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：PG ID 形式为 N.xxxxx，其中 N 是包含 PG 的池的编号。命令 <code>ceph osd listpools</code> 和 <code>ceph osd dump | grep pool</code> 返回池编号的列表。</p><p>如果由于时钟偏差而定期收到 active + clean + inconsistent 状态，请考虑配置监视主机上的 NTP 守护进程以充当对等体。有关更多信息，请参见《网络时间协议和 Ceph 时钟设置》。</p><h4 id="关于-PG-修复的更多信息"><a href="#关于-PG-修复的更多信息" class="headerlink" title="关于 PG 修复的更多信息"></a>关于 PG 修复的更多信息</h4><p>Ceph 存储并更新集群中存储对象的校验和。当在 PG 上执行清理时，主 OSD 尝试从其副本中选择一个权威副本。只有一个可能的情况是一致的。执行深度清理后，Ceph 计算从磁盘读取的每个对象的校验和，并将其与先前记录的校验和进行比较。如果当前校验和与先前记录的校验和不匹配，则该不匹配被视为不一致。在复制池的情况下，任何副本的校验和与权威副本的校验和之间的任何不匹配都意味着存在不一致。发现这些不一致会导致 PG 状态被设置为不一致。</p><p><code>pg repair</code> 命令尝试修复各种类型的不一致。当 <code>pg repair</code> 发现不一致的 PG 时，它尝试用权威副本的摘要覆盖不一致副本的摘要。当 <code>pg repair</code> 在复制池中发现不一致副本时，它将不一致副本标记为丢失。在复制池的情况下，恢复超出了 <code>pg repair</code> 的范围。</p><p>对于编码和 BlueStore 池，Ceph 会自动执行修复，如果 <code>osd_scrub_auto_repair</code>（默认值为 false）设置为 true 并且发现的错误不超过 <code>osd_scrub_auto_repair_num_errors</code>（默认值为 5）。</p><p><code>pg repair</code> 命令不会解决所有问题。Ceph 不会自动修复发现有不一致的 PG。</p><p>RADOS 对象或 omap 的校验和并不总是可用。校验和是逐步计算的。如果一个复制对象非顺序更新，涉及的写入操作会更改对象并使其校验和无效。在重新计算校验和时不会读取整个对象。即使校验和不可用，<code>pg repair</code> 命令也能够进行修复，如 Filestore 中的情况。使用复制 Filestore 池的用户可能会更倾向于手动修复，而不是使用 <code>ceph pg repair</code>。</p><p>该材料适用于 Filestore，但不适用于 BlueStore，后者具有自己的内部校验和。匹配记录的校验和和计算的校验和不能证明任何特定副本实际上是权威的。如果没有校验和可用，<code>pg repair</code> 倾向于主数据，但这可能不是未损坏的副本。因此，在发现不一致时需要人工干预。这种干预有时涉及使用 <code>ceph-objectstore-tool</code>。</p><h4 id="编码池-PG-不是-active-clean"><a href="#编码池-PG-不是-active-clean" class="headerlink" title="编码池 PG 不是 active+clean"></a>编码池 PG 不是 active+clean</h4><p>如果 CRUSH 无法找到足够的 OSD 映射到 PG，它将显示为 2147483647，这是 ITEM_NONE 或未找到 OSD。例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2,1,6,0,5,8,2147483647,7,4]</span><br></pre></td></tr></table></figure><p>OSD 数量不足</p><p>如果 Ceph 集群只有八个 OSD，而一个编码池需要九个 OSD，则集群会显示“OSD 不足”。在这种情况下，你可以创建</p><p>另一个需要更少 OSD 的编码池，运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceph osd erasure-code-profile <span class="built_in">set</span> myprofile k=5 m=3</span><br><span class="line">ceph osd pool create erasurepool erasure myprofile</span><br></pre></td></tr></table></figure><p>或者添加新的 OSD，PG 将自动使用它们。</p><h3 id="CRUSH-约束无法满足"><a href="#CRUSH-约束无法满足" class="headerlink" title="CRUSH 约束无法满足"></a>CRUSH 约束无法满足</h3><p>如果集群中有足够的 OSD，可能是 CRUSH 规则施加了无法满足的约束。如果两个主机上有十个 OSD，而 CRUSH 规则要求同一主机上的两个 OSD 不得在同一 PG 中使用，则映射可能失败，因为只会找到两个 OSD。通过显示（“转储”）规则来检查约束，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ceph osd crush rule <span class="built_in">ls</span></span><br><span class="line">[</span><br><span class="line">    <span class="string">&quot;replicated_rule&quot;</span>,</span><br><span class="line">    <span class="string">&quot;erasurepool&quot;</span>]</span><br><span class="line">$ ceph osd crush rule dump erasurepool</span><br><span class="line">&#123; <span class="string">&quot;rule_id&quot;</span>: 1,</span><br><span class="line">  <span class="string">&quot;rule_name&quot;</span>: <span class="string">&quot;erasurepool&quot;</span>,</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: 3,</span><br><span class="line">  <span class="string">&quot;steps&quot;</span>: [</span><br><span class="line">        &#123; <span class="string">&quot;op&quot;</span>: <span class="string">&quot;take&quot;</span>,</span><br><span class="line">          <span class="string">&quot;item&quot;</span>: -1,</span><br><span class="line">          <span class="string">&quot;item_name&quot;</span>: <span class="string">&quot;default&quot;</span>&#125;,</span><br><span class="line">        &#123; <span class="string">&quot;op&quot;</span>: <span class="string">&quot;chooseleaf_indep&quot;</span>,</span><br><span class="line">          <span class="string">&quot;num&quot;</span>: 0,</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;host&quot;</span>&#125;,</span><br><span class="line">        &#123; <span class="string">&quot;op&quot;</span>: <span class="string">&quot;emit&quot;</span>&#125;]&#125;</span><br></pre></td></tr></table></figure><p>通过运行以下命令解决此问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceph osd erasure-code-profile <span class="built_in">set</span> myprofile crush-failure-domain=osd</span><br><span class="line">ceph osd pool create erasurepool erasure myprofile</span><br></pre></td></tr></table></figure><h3 id="CRUSH-过早放弃"><a href="#CRUSH-过早放弃" class="headerlink" title="CRUSH 过早放弃"></a>CRUSH 过早放弃</h3><p>如果 Ceph 集群只有足够的 OSD 来映射 PG（例如，总共九个 OSD 的集群和每个 PG 需要九个 OSD 的编码池），则可能 CRUSH 在找到映射之前就放弃了。可以通过以下方式解决此问题：</p><ul><li>降低编码池的要求，以使用更少的 OSD（这需要创建另一个池，因为编码配置文件不能动态修改）。</li><li>向集群中添加更多 OSD（这不需要修改编码池，因为它会自动变干净）。</li><li>使用手动创建的 CRUSH 规则，尝试更多次找到合适的映射。可以通过设置 <code>set_choose_tries</code> 为大于默认值的值来修改现有的 CRUSH 规则。</li></ul><p>首先，通过在从集群中提取 crushmap 后使用 <code>crushtool</code> 验证问题。这可以确保你的实验不会修改 Ceph 集群，只在本地文件上操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ceph osd crush rule dump erasurepool</span><br><span class="line">&#123; <span class="string">&quot;rule_id&quot;</span>: 1,</span><br><span class="line">  <span class="string">&quot;rule_name&quot;</span>: <span class="string">&quot;erasurepool&quot;</span>,</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: 3,</span><br><span class="line">  <span class="string">&quot;steps&quot;</span>: [</span><br><span class="line">        &#123; <span class="string">&quot;op&quot;</span>: <span class="string">&quot;take&quot;</span>,</span><br><span class="line">          <span class="string">&quot;item&quot;</span>: -1,</span><br><span class="line">          <span class="string">&quot;item_name&quot;</span>: <span class="string">&quot;default&quot;</span>&#125;,</span><br><span class="line">        &#123; <span class="string">&quot;op&quot;</span>: <span class="string">&quot;chooseleaf_indep&quot;</span>,</span><br><span class="line">          <span class="string">&quot;num&quot;</span>: 0,</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;host&quot;</span>&#125;,</span><br><span class="line">        &#123; <span class="string">&quot;op&quot;</span>: <span class="string">&quot;emit&quot;</span>&#125;]&#125;</span><br><span class="line">$ ceph osd getcrushmap &gt; crush.map</span><br><span class="line">got crush map from osdmap epoch 13</span><br><span class="line">$ crushtool -i crush.map --<span class="built_in">test</span> --show-bad-mappings \</span><br><span class="line">   --rule 1 \</span><br><span class="line">   --num-rep 9 \</span><br><span class="line">   --min-x 1 --max-x $((<span class="number">1024</span> * <span class="number">1024</span>))</span><br><span class="line">bad mapping rule 8 x 43 num_rep 9 result [3,2,7,1,2147483647,8,5,6,0]</span><br><span class="line">bad mapping rule 8 x 79 num_rep 9 result [6,0,2,1,4,7,2147483647,5,8]</span><br><span class="line">bad mapping rule 8 x 173 num_rep 9 result [0,4,6,8,2,1,3,7,2147483647]</span><br></pre></td></tr></table></figure><p>在这里，<code>--num-rep</code> 是编码规则需要的 OSD 数量，<code>--rule</code> 是 <code>ceph osd crush rule dump</code> 显示的 <code>rule_id</code> 值。此测试将尝试映射一百万个值（在此示例中，范围定义为 [–min-x,–max-x]），并且必须显示至少一个错误映射。如果此测试没有输出任何内容，则表示所有映射都成功，你可以确定集群中的问题不是由于坏映射造成的。</p><h3 id="更改-set-choose-tries-的值"><a href="#更改-set-choose-tries-的值" class="headerlink" title="更改 set_choose_tries 的值"></a>更改 <code>set_choose_tries</code> 的值</h3><p>将 CRUSH 映射解压以编辑 CRUSH 规则，运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crushtool --decompile crush.map &gt; crush.txt</span><br></pre></td></tr></table></figure><p>在规则中添加以下行：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">step set_choose_tries 100</span><br></pre></td></tr></table></figure><p><code>crush.txt</code> 文件的相关部分将类似于：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rule erasurepool &#123;</span><br><span class="line">        id 1</span><br><span class="line">        type erasure</span><br><span class="line">        step set_chooseleaf_tries 5</span><br><span class="line">        step set_choose_tries 100</span><br><span class="line">        step take default</span><br><span class="line">        step chooseleaf indep 0 type host</span><br><span class="line">        step emit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新编译并重新测试 CRUSH 规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crushtool --compile crush.txt -o better-crush.map</span><br></pre></td></tr></table></figure><p>当所有映射成功时，通过使用 <code>crushtool</code> 命令的 <code>--show-choose-tries</code> 选项显示找到所有映射所需的尝试次数的直方图，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">crushtool -i better-crush.map --<span class="built_in">test</span> --show-bad-mappings \</span><br><span class="line">   --show-choose-tries \</span><br><span class="line">   --rule 1 \</span><br><span class="line">   --num-rep 9 \</span><br><span class="line">   --min-x 1 --max-x $((<span class="number">1024</span> * <span class="number">1024</span>))</span><br><span class="line">  ...</span><br><span class="line">  11:        42</span><br><span class="line">  12:        44</span><br><span class="line">  13:        54</span><br><span class="line">  14:        45</span><br><span class="line">  15:        35</span><br><span class="line">  16:        34</span><br><span class="line">  17:        30</span><br><span class="line">  18:        25</span><br><span class="line">  19:        19</span><br><span class="line">  20:        22</span><br><span class="line">  21:        20</span><br><span class="line">  22:        17</span><br><span class="line">  23:        13</span><br><span class="line">  24:        16</span><br><span class="line">  25:        13</span><br><span class="line">  26:        11</span><br><span class="line">  27:        11</span><br><span class="line">  28:        13</span><br><span class="line">  29:        11</span><br><span class="line">  30:        10</span><br><span class="line">  31:         6</span><br><span class="line">  32:         5</span><br><span class="line">  33:        10</span><br><span class="line">  34:         3</span><br><span class="line">  35:         7</span><br><span class="line">  36:         5</span><br><span class="line">  37:         2</span><br><span class="line">  38:         5</span><br><span class="line">  39:         5</span><br><span class="line">  40:         2</span><br><span class="line">  41:         5</span><br><span class="line">  42:         4</span><br><span class="line">  43:         1</span><br><span class="line">  44:         2</span><br><span class="line">  45:         2</span><br><span class="line">  46:         3</span><br><span class="line">  47:         1</span><br><span class="line">  48:         0</span><br><span class="line">  ...</span><br><span class="line">  102:         0</span><br><span class="line">  103:         1</span><br><span class="line">  104:         0</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>这个输出表示映射 42 个 PG 需要 11 次尝试，映射 44 个 PG 需要 12 次尝试等。最大尝试次数是防止坏映射的 <code>set_choose_tries</code> 的最小值（例如，上述输出中的 103，因为没有超过 103 次尝试的 PG 被映射）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;PG故障排除&quot;&gt;&lt;a href=&quot;#PG故障排除&quot; class=&quot;headerlink&quot; title=&quot;PG故障排除&quot;&gt;&lt;/a&gt;PG故障排除&lt;/h2&gt;&lt;h4 id=&quot;PG-永远无法变干净&quot;&gt;&lt;a href=&quot;#PG-永远无法变干净&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="云存储" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E5%AD%98%E5%82%A8/"/>
    
    <category term="Ceph" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E5%AD%98%E5%82%A8/Ceph/"/>
    
    
    <category term="云存储" scheme="https://watsonlu6.github.io/tags/%E4%BA%91%E5%AD%98%E5%82%A8/"/>
    
    <category term="Ceph" scheme="https://watsonlu6.github.io/tags/Ceph/"/>
    
  </entry>
  
  <entry>
    <title>Cpeh OSD常见故障处理</title>
    <link href="https://watsonlu6.github.io/Storage/Ceph/Ceph-OSD%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/"/>
    <id>https://watsonlu6.github.io/Storage/Ceph/Ceph-OSD%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/</id>
    <published>2022-10-07T06:53:31.000Z</published>
    <updated>2024-09-08T14:58:28.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OSD故障排除"><a href="#OSD故障排除" class="headerlink" title="OSD故障排除"></a>OSD故障排除</h2><p>在故障排除集群的 OSD 之前，请先检查监视器和网络。<br>首先，确定监视器是否有法定人数。运行 <code>ceph health</code> 命令或 <code>ceph -s</code> 命令，如果 Ceph 显示 <code>HEALTH_OK</code>，则表示有监视器法定人数。如果监视器没有法定人数或监视器状态出现错误，请在继续之前处理监视器问题。接下来，检查网络以确保其正常运行。网络对 OSD 的操作和性能有显著影响。检查主机端是否有丢包，并检查交换机端是否有 CRC 错误。</p><h4 id="获取-OSD-数据"><a href="#获取-OSD-数据" class="headerlink" title="获取 OSD 数据"></a>获取 OSD 数据</h4><p>在故障排除 OSD 时，收集关于 OSD 的不同信息非常有用。一些信息来自于对 OSD 的监控（例如，运行 <code>ceph osd tree</code> 命令）。额外的信息涉及到集群的拓扑结构，以下部分将讨论这些内容。</p><ol><li><p><strong>Ceph 日志</strong><br>  Ceph 的日志文件存储在 <code>/var/log/ceph</code> 下。除非路径已被更改（或者您在存储日志位置不同的容器化环境中），否则可以通过以下命令列出日志文件：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /var/log/ceph</span><br></pre></td></tr></table></figure><p>  如果日志详情不够，请调整日志级别。要确保 Ceph 在高日志量下表现良好，请参阅“日志记录和调试”。</p></li><li><p><strong>管理员套接字</strong><br>使用管理员套接字工具来检索运行时信息。首先，列出 Ceph 守护进程的套接字，通过以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /var/run/ceph</span><br></pre></td></tr></table></figure><p>接下来，运行如下命令（将 <code>&#123;daemon-name&#125;</code> 替换为特定守护进程的名称，例如 <code>osd.0</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph daemon &#123;daemon-name&#125; <span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>或者，指定 <code>&#123;socket-file&#125;</code>（“套接字文件”是 <code>/var/run/ceph</code> 中的特定文件）运行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph daemon &#123;socket-file&#125; <span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>管理员套接字可以完成许多任务，包括：</p></li></ol><ul><li>列出 Ceph 配置运行时</li><li>转储历史操作</li><li>转储操作优先级队列状态</li><li>转储正在进行的操作</li><li>转储性能计数器</li></ul><ol start="3"><li><p><strong>显示空闲空间</strong><br>可能会出现文件系统问题。要显示文件系统的空闲空间，请运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure><p>要查看此命令支持的语法和选项，请运行 <code>df --help</code>。</p></li><li><p><strong>I&#x2F;O 统计</strong><br><code>iostat</code> 工具可用于识别 I&#x2F;O 相关的问题。运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -x</span><br></pre></td></tr></table></figure></li><li><p><strong>诊断信息</strong><br>要从内核中检索诊断信息，请运行 <code>dmesg</code> 命令，并使用 <code>less</code>、<code>more</code>、<code>grep</code> 或 <code>tail</code> 进行指定输出。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep scsi</span><br></pre></td></tr></table></figure></li></ol><h4 id="停止而不重新平衡"><a href="#停止而不重新平衡" class="headerlink" title="停止而不重新平衡"></a>停止而不重新平衡</h4><p>有时可能需要对集群的子集进行维护或解决影响故障域（例如机架）的问题。然而，当停止 OSD 进行维护时，可能希望防止 CRUSH 自动重新平衡集群。为避免这种重新平衡行为，可以通过运行以下命令将集群设置为 <code>noout</code> 状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd <span class="built_in">set</span> noout</span><br></pre></td></tr></table></figure><p><strong>警告</strong><br>这更多是一个思考练习，用于让读者理解故障域和 CRUSH 行为，而不是建议在 Luminous 版本后的环境中运行 <code>ceph osd set noout</code>。当 OSD 返回到正常状态时，重新平衡将恢复，<code>ceph osd set noout</code> 命令引入的更改将被撤销。</p><p>然而，在 Luminous 及后续版本中，更安全的做法是只标记受影响的 OSD。要添加或删除特定 OSD 的 <code>noout</code> 标志，可以运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceph osd add-noout osd.0</span><br><span class="line">ceph osd rm-noout osd.0</span><br></pre></td></tr></table></figure><p>也可以标记整个 CRUSH 组。例如，如果计划停用 <code>prod-ceph-data1701</code> 以增加 RAM，可以运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd set-group noout prod-ceph-data1701</span><br></pre></td></tr></table></figure><p>设置标志后，停止 OSD 和需要维护的故障域内的其他 Ceph 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop ceph\*.service ceph\*.target</span><br></pre></td></tr></table></figure><p><strong>注意</strong><br>当 OSD 被停止时，该 OSD 内的任何放置组将被标记为降级。<br>维护完成后，需重新启动 OSD 和其他停止的守护进程。然而，如果主机在维护过程中重启，则不需要重新启动，系统会自动恢复。要重新启动 OSD 或其他守护进程，使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start ceph.target</span><br></pre></td></tr></table></figure><p>最后，根据需要取消 <code>noout</code> 标志，可以运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceph osd <span class="built_in">unset</span> noout</span><br><span class="line">ceph osd unset-group noout prod-ceph-data1701</span><br></pre></td></tr></table></figure><p>许多现代 Linux 发行版使用 systemd 进行服务管理。然而，对于某些操作系统（尤其是旧版本），可能需要发出等效的服务或启动&#x2F;停止命令。</p><h4 id="OSD-未运行"><a href="#OSD-未运行" class="headerlink" title="OSD 未运行"></a>OSD 未运行</h4><p>在正常情况下，重新启动 ceph-osd 守护进程将允许它重新加入集群并恢复。</p><p><strong>OSD 无法启动</strong><br>如果集群已启动，但某个 OSD 无法启动，请检查以下内容：</p><ul><li><strong>配置文件</strong>：如果您在新的安装中无法启动 OSD，请检查配置文件以确保其符合标准（例如，确保使用的是 <code>host</code> 而不是 <code>hostname</code> 等）。</li><li><strong>检查路径</strong>：确保配置中指定的路径与实际存在的数据和元数据路径对应（例如，日志、WAL 和 DB 的路径）。将 OSD 数据与元数据分开，以查看配置文件和实际挂载是否存在错误。如果有，这些错误可能解释了为何 OSD 无法启动。要将元数据存储在单独的块设备上，可以对驱动器进行分区或使用 LVM，并为每个 OSD 分配一个分区。</li><li><strong>检查最大线程数</strong>：如果集群中有一个节点的 OSD 数量特别高，可能会达到默认的最大线程数（通常是 32,000）。这在恢复过程中尤其可能发生。将最大线程数增加到允许的最大线程数（4194303）可能有助于解决问题。要将线程数增加到最大值，请运行以下命令：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w kernel.pid_max=4194303</span><br></pre></td></tr></table></figure>如果增加线程数解决了问题，您必须通过在 <code>/etc/sysctl.d</code> 文件夹下的文件或在主 <code>/etc/sysctl.conf</code> 文件中包含 <code>kernel.pid_max</code> 设置来使更改永久生效。例如：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.pid_max = 4194303</span><br></pre></td></tr></table></figure></li><li>**检查 <code>nf_conntrack</code>**：这个连接跟踪和连接限制系统对许多生产 Ceph 集群造成问题。问题往往缓慢而微妙地出现。随着集群拓扑和客户端工作负载的增长，神秘和间歇性的连接失败和性能问题会越来越多，尤其是在一天中的某些时候。为开始评估问题，请检查 syslog 历史中的 “table full” 事件。解决这种问题的一种方法是：首先，使用 sysctl 实用程序将 <code>nf_conntrack_max</code> 设置为更高的值。接下来，将 <code>nf_conntrack_buckets</code> 的值提高到 <code>nf_conntrack_buckets × 8 = nf_conntrack_max</code>；这可能需要在 sysctl 之外运行命令（例如，<code>echo 131072 &gt; /sys/module/nf_conntrack/parameters/hashsize</code>）。另一种解决方法是将相关内核模块列入黑名单，从而完全禁用处理。这种方法强大但脆弱。模块及其列出顺序可能因内核版本而异。即使被列入黑名单，iptables 和 docker 有时仍会激活连接跟踪，因此我们建议对调优参数采用“设置并忘记”的策略。在现代系统中，这种方法不会消耗显著资源。</li><li><strong>内核版本</strong>：确定正在使用的内核版本和发行版。默认情况下，Ceph 使用的第三方工具可能存在缺陷或与某些发行版或内核版本冲突（例如，Google 的 gperftools 和 TCMalloc）。检查操作系统建议和每个 Ceph 版本的发行说明，以确保您已解决与内核相关的任何问题。</li><li><strong>段错误</strong>：如果出现段错误，请提高日志级别并重新启动有问题的守护进程。如果段错误重复发生，请在 Ceph bug 跟踪器（<a href="https://tracker.ceph.com/projects/ceph%EF%BC%89%E5%92%8C">https://tracker.ceph.com/projects/ceph）和</a> dev 及 ceph-users 邮件列表归档（<a href="https://ceph.io/resources%EF%BC%89%E4%B8%AD%E6%90%9C%E7%B4%A2%E6%98%AF%E5%90%A6%E6%9C%89%E5%85%B6%E4%BB%96%E4%BA%BA%E9%81%87%E5%88%B0%E5%B9%B6%E6%8A%A5%E5%91%8A%E4%BA%86%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98%E3%80%82%E5%A6%82%E6%9E%9C%E8%BF%99%E7%A1%AE%E5%AE%9E%E6%98%AF%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%92%8C%E7%8B%AC%E7%89%B9%E7%9A%84%E6%95%85%E9%9A%9C%EF%BC%8C%E8%AF%B7%E5%9C%A8">https://ceph.io/resources）中搜索是否有其他人遇到并报告了这些问题。如果这确实是一个新的和独特的故障，请在</a> dev 邮件列表中发布，并提供以下信息：正在运行的具体 Ceph 版本、ceph.conf（秘密已用 XXX 替换）、监视器状态输出和日志文件摘录。</li></ul><p><strong>OSD 失败</strong><br>当 OSD 失败时，表示 ceph-osd 进程无响应或已死亡，相应的 OSD 已被标记为下线。存活的 ceph-osd 守护进程将向监视器报告该 OSD 似乎已经下线，并且 <code>ceph health</code> 命令的输出中将显示新的状态，如下例所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceph health</span><br><span class="line">HEALTH_WARN 1/3 <span class="keyword">in</span> osds are down</span><br></pre></td></tr></table></figure><p>当有一个或多个 OSD 被标记为下线时，会引发此健康警报。要查看哪些 OSD 已下线，请为命令添加详细信息，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ceph health detail</span><br><span class="line">HEALTH_WARN 1/3 <span class="keyword">in</span> osds are down</span><br><span class="line">osd.0 is down since epoch 23, last address 192.168.106.220:6800/11080</span><br></pre></td></tr></table></figure><p>或者，运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd tree down</span><br></pre></td></tr></table></figure><p>如果由于驱动器故障或其他故障导致某个 ceph-osd 守护进程无法工作或重新启动，则其日志文件（位于 <code>/var/log/ceph</code> 下）中应存在错误消息。如果 ceph-osd 守护进程因心跳故障或自杀超时错误而停止，则底层驱动器或文件系统可能无响应。检查 dmesg 输出和 syslog 输出中的驱动器错误或内核错误。可能需要指定某些标志（例如，<code>dmesg -T</code> 以查看人类可读的时间戳）以避免将旧错误误认为新错误。</p><p>如果整个主机的 OSD 都下线，请检查是否存在网络错误或主机的硬件问题。如果 OSD 问题是软件错误（例如，断言失败或其他意外错误）的结果，请在 bug 跟踪器、dev 邮件列表归档和 ceph-users 邮件列表归档中搜索是否有问题报告。如果没有明确的修复或现有 bug，请向 ceph-devel 邮件列表报告问题。</p><p><strong>没有可用驱动器空间</strong><br>如果 OSD 已满，Ceph 会通过确保不会将新数据写入 OSD 来防止数据丢失。在正常运行的集群中，当集群的 OSD 和池接近某些“满”比率时，会引发健康检查。<code>mon_osd_full_ratio</code> 阈值默认为 0.95（即 95% 的容量）：这是防止客户端写入数据的点。<code>mon_osd_backfillfull_ratio</code> 阈值默认为 0.90（即 90% 的容量）：这是防止开始回填的点。<code>mon_osd_nearfull_ratio</code> 阈值默认为 0.85（即 85% 的容量）：这是引发 OSD_NEARFULL 健康检查的点。集群中的 OSD 在 Ceph 分配的数据量上会有所不同。要通过显示每个 OSD 的数据使用情况来检查“满”状态，请运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd <span class="built_in">df</span></span><br></pre></td></tr></table></figure><p>要通过显示集群的总体数据使用情况和池之间的数据分布来检查“满”状态，请运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph <span class="built_in">df</span></span><br></pre></td></tr></table></figure><p>在检查 <code>ceph df</code> 命令的输出时，请特别注意最满的 OSD，而不是原始空间使用的百分比。如果单个 OSD 变满，所有对该 OSD 池的写入可能会失败。当 <code>ceph df</code> 报告池的可用空间时，它会考虑相对于池中最满 OSD 的比率设置。为了平衡数据分布，可以采取两种方法：（1）使用 <code>reweight-by-utilization</code> 命令逐步将数据从过满的 OSD 移动到不足满的 OSD，或者（2）在 Luminous 的后续版本及以后的版本中，利用 ceph-mgr balancer 模块自动执行相同任务。要调整“满”比率，请运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ceph osd set-nearfull-ratio &lt;<span class="built_in">float</span>[0.0-1.0]&gt;</span><br><span class="line">ceph osd set-full-ratio &lt;<span class="built_in">float</span>[0.0-1.0]&gt;</span><br><span class="line">ceph osd set-backfillfull-ratio &lt;<span class="built_in">float</span>[0.0-1.0]&gt;</span><br></pre></td></tr></table></figure><p>有时，集群问题的原因是 OSD 失败。这可能发生在测试过程中，或者因为集群较小、非常满或不平衡。当 OSD 或节点占据集群数据的过高比例时，组件故障或自然增长可能导致接近满和满的比率被超过。在测试 Ceph 对 OSD 故障的恢复能力时，建议保留足够的空闲磁盘空间，并考虑暂时降低 OSD 的满比率、回填满比率和接近满比率。<br>OSD 的“满”状态在 <code>ceph health</code> 命令的输出中可见，如下例所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceph health</span><br><span class="line">HEALTH_WARN 1 nearfull osd(s)</span><br></pre></td></tr></table></figure><p>有关详细信息，请使用详细命令，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ceph health detail</span><br><span class="line">HEALTH_ERR 1 full osd(s);</span><br><span class="line"></span><br><span class="line"> 1 backfillfull osd(s); 1 nearfull osd(s)</span><br><span class="line">osd.3 is full at 97%</span><br><span class="line">osd.4 is backfill full at 91%</span><br><span class="line">osd.2 is near full at 87%</span><br></pre></td></tr></table></figure><p>为解决满集群问题，建议通过添加 OSD 来增加容量。添加新 OSD 允许集群将数据重新分配到新提供的存储空间。查找浪费空间的 rados bench 孤儿对象。</p><p>如果旧版 Filestore OSD 由于已满而无法启动，可以通过删除满 OSD 上的一小部分放置组目录来回收空间。</p><p><strong>重要</strong></p><p>如果您选择在满 OSD 上删除放置组目录，请勿在其他满 OSD 上删除相同的放置组目录。否则，您将丢失数据。您必须在至少一个 OSD 上保留数据的至少一个副本。删除放置组目录是一种罕见且极端的干预，不应轻易进行。</p><h4 id="OSD-运行缓慢-无响应"><a href="#OSD-运行缓慢-无响应" class="headerlink" title="OSD 运行缓慢&#x2F;无响应"></a>OSD 运行缓慢&#x2F;无响应</h4><p>OSD 有时会运行缓慢或无响应。在排查这个常见问题时，建议在调查 OSD 性能问题之前排除其他可能性。例如，确保网络正常工作，确认 OSD 正在运行，并检查 OSD 是否限制了恢复流量。<br><strong>提示</strong><br>在 Luminous 版本之前，某些 up 和 in 状态的 OSD 有时不可用或运行缓慢，因为恢复中的 OSD 消耗了系统资源。更新版本通过防止这种现象提供了更好的恢复处理。</p><ol><li><p><strong>网络问题</strong><br>  作为分布式存储系统，Ceph 依赖网络进行 OSD 对等和复制、故障恢复以及周期性心跳。网络问题可能导致 OSD 延迟和抖动的 OSD。更多信息请参见“抖动 OSD”。要确保 Ceph 进程和 Ceph 相关进程连接正常并在监听，请运行以下命令：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -a | grep ceph</span><br><span class="line">netstat -l | grep ceph</span><br><span class="line"><span class="built_in">sudo</span> netstat -p | grep ceph</span><br></pre></td></tr></table></figure><p>  要检查网络统计信息，请运行以下命令：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -s</span><br></pre></td></tr></table></figure></li><li><p><strong>驱动器配置</strong><br>  SAS 或 SATA 存储驱动器应仅容纳一个 OSD，但 NVMe 驱动器可以轻松容纳两个或更多。然而，如果其他进程共享驱动器，读写吞吐量可能会受到瓶颈。此类进程包括：日志&#x2F;元数据、操作系统、Ceph 监视器、syslog 日志、其他 OSD 和非 Ceph 进程。<br>  由于 Ceph 在日志记录后确认写入，快速 SSD 是加速响应时间的一个有吸引力的选项——特别是在使用 XFS 或 ext4 文件系统作为传统 FileStore OSD 时。相比之下，Btrfs 文件系统可以同时进行写入和日志记录。（然而，不推荐在生产环境中使用 Btrfs。）<br>  <strong>注意</strong><br>  对驱动器进行分区不会改变其总吞吐量或顺序读&#x2F;写限制。通过在单独的分区中运行日志，吞吐量可能会有所改善，但更好的做法是将日志运行在单独的物理驱动器中。<br>  <strong>警告</strong><br>  Reef 不支持 FileStore。Reef 之后的版本不再支持 FileStore。提到 FileStore 的信息仅适用于 Quincy 版本及 Quincy 之前的版本。</p></li><li><p><strong>坏扇区&#x2F;碎片化磁盘</strong><br>  检查驱动器是否存在坏块、碎片化和其他可能导致性能显著下降的错误。检查驱动器错误的有用工具包括 dmesg、syslog 日志和 smartctl（在 smartmontools 包中）。<br>  <strong>注意</strong><br>  smartmontools 7.0 及更高版本提供 NVMe 状态直通和 JSON 输出。</p></li><li><p><strong>共存的监视器&#x2F;OSD</strong><br>  尽管监视器是相对轻量的进程，但当监视器与 OSD 运行在同一主机上时，可能会出现性能问题。监视器发出许多 fsync() 调用，这可能干扰其他工作负载。当监视器与 OSD 共存在同一存储驱动器上时，性能问题尤其严重。此外，如果监视器运行的是较旧的内核（3.0 之前）或没有 syncfs(2) 系统调用的内核，那么同一主机上运行的多个 OSD 可能会进行太多提交，从而影响彼此的性能。这种问题有时会导致所谓的“突发写入”。</p></li><li><p><strong>共存进程</strong><br>  在与 OSD 运行在同一硬件上时，处理写入数据到 Ceph 的进程（例如基于云的解决方案和虚拟机）可能会导致显著的 OSD 延迟。因此，一般不推荐将这些进程与 OSD 共存在同一硬件上。推荐的做法是优化某些主机用于 Ceph，其他主机用于其他进程。这种将 Ceph 操作与其他应用程序分开的做法可能有助于提高性能，并简化故障排除和维护。在同一硬件上运行共存进程有时被称为“融合”。使用 Ceph 时，仅在具备专业知识和经过考虑后再进行融合。</p></li><li><p><strong>日志级别</strong><br>  高日志级别可能导致性能问题。操作人员有时会提高日志级别以跟踪问题，然后忘记在之后降低它们。在这种情况下，OSD 可能会消耗宝贵的系统资源，将不必要的详细日志写入磁盘。任何希望使用高日志级别的人都应考虑将驱动器挂载到日志的默认路径（例如，&#x2F;var&#x2F;log&#x2F;ceph&#x2F;$cluster-$name.log）。</p></li><li><p><strong>恢复限制</strong><br>  根据您的配置，Ceph 可能会减少恢复速率以保持客户端或 OSD 性能，或者可能会增加恢复速率到影响客户端或 OSD 性能的程度。检查客户端或 OSD 是否正在恢复。</p></li><li><p><strong>内核版本</strong><br>  检查您运行的内核版本。较旧的内核可能缺少改进 Ceph 性能的更新。</p></li><li><p><strong>内核 SyncFS 问题</strong><br>  如果您遇到 SyncFS 的内核问题，请尝试每个主机运行一个 OSD 以查看性能是否提高。旧的内核可能没有足够新的 glibc 版本来支持 syncfs(2)。</p></li><li><p><strong>文件系统问题</strong><br>  在 Luminous 版本之后，我们建议使用 BlueStore 后端部署集群。当运行 Luminous 版本之前的版本时，或者如果您有特别的理由使用旧的 Filestore 后端，我们建议使用 XFS。<br>  我们不推荐使用 Btrfs 或 ext4。Btrfs 文件系统有许多吸引人的特性，但可能会导致性能问题和虚假的 ENOSPC 错误。由于 xattr 限制破坏了对长对象名称的支持，我们不推荐在 Filestore OSD 中使用 ext4。</p></li><li><p><strong>内存不足</strong><br>  我们建议每个 OSD 守护进程至少配备 4GB 内存，并建议将其增加到 6GB 或 8GB。在正常操作期间，您可能会注意到 ceph-osd 进程只使用了其中的一小部分。您可能会被诱使将多余的内存用于共存应用程序，或减少每个节点的内存容量。然而，当 OSD 正在恢复时，其内存使用会急剧增加。如果在恢复过程中没有足够的内存，OSD 性能会显著下降，守护进程可能会崩溃或被 Linux OOM Killer 杀死。</p></li><li><p><strong>请求阻塞或请求缓慢</strong><br>  当 ceph-osd 守护进程对请求响应缓慢时，集群日志会收到报告操作处理时间过长的消息。警告阈值默认为 30 秒，可以通过 osd_op_complaint_time 设置进行配置。<br>  旧版 Ceph 报告旧请求：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osd.0 192.168.106.220:6800/18813 312 : [WRN] old request osd_op(client.5099.0:790 fatty_26485_object789 [write 0~4096] 2.5e54f643) v4 received at 2012-03-06 15:42:56.054801 currently waiting <span class="keyword">for</span> sub ops</span><br></pre></td></tr></table></figure><p>  新版 Ceph 报告慢请求：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="built_in">date</span>&#125; &#123;osd.num&#125; [WRN] 1 slow requests, 1 included below; oldest blocked <span class="keyword">for</span> &gt; 30.005692 secs</span><br><span class="line">&#123;<span class="built_in">date</span>&#125; &#123;osd.num&#125;  [WRN] slow request 30.005692 seconds old, received at &#123;date-time&#125;: osd_op(client.4240.0:8 benchmark_data_ceph-1_39426_object7 [write 0~4194304] 0.69848840) v4 currently waiting <span class="keyword">for</span> subops from [610]</span><br></pre></td></tr></table></figure><p>  可能的原因包括：</p></li></ol><ul><li>驱动器故障（检查 dmesg 输出）</li><li>内核文件系统中的错误（检查 dmesg 输出）</li><li>集群过载（检查系统负载、iostat 等）</li><li>ceph-osd 守护进程中的错误</li></ul><p>  可能的解决方案：</p><ul><li>从 Ceph 主机中移除虚拟机</li><li>升级内核</li><li>升级 Ceph</li><li>重启 OSD</li><li>更换故障或有问题的组件</li></ul><ol start="13"><li><strong>调试缓慢请求</strong><br>  如果您运行 <code>ceph daemon osd.&lt;id&gt; dump_historic_ops</code> 或 <code>ceph daemon osd.&lt;id&gt; dump_ops_in_flight</code>，您将看到一组操作和每个操作经历的事件列表。这些事件简要描述如下。<br>  来自 Messenger 层的事件：<ul><li><code>header_read</code>: Messenger 开始从网络读取消息的时间。</li><li><code>throttled</code>: Messenger 尝试获取内存节流空间以将消息读入内存的时间。</li><li><code>all_read</code>: Messenger 完成从网络读取消息的时间。</li><li><code>dispatched</code>: Messenger 将消息交给 OSD 的时间。</li><li><code>initiated</code>: 这与 <code>header_read</code> 相同。存在这两个事件是历史上的异常。</li></ul></li></ol><p>  来自 OSD 处理操作的事件:<br>    - <code>queued_for_pg</code>: 操作已被放入队列等待 PG 处理。<br>    - <code>reached_pg</code>: PG 开始执行操作。<br>    - <code>waiting for *</code>: 操作在等待其他工作完成后才能继续（例如，新 OSDMap；对象目标的检查；PG 的对等完成；这些都在消息中指定）。<br>    - <code>started</code>: 操作已被接受为 OSD 应执行的任务，并且正在执行中。<br>    - <code>waiting for subops from</code>: 操作已被发送到副本 OSD。</p><p>  来自 Filestore 的事件：<br>    - <code>commit_queued_for_journal_write</code>: 操作已交给 FileStore。<br>    - <code>write_thread_in_journal_buffer</code>: 操作在日志的缓冲区中，等待持久化（作为下一次磁盘写入）。<br>    - <code>journaled_completion_queued</code>: 操作已被写入日志，回调已排队等待调用。</p><p>  来自 OSD 在数据已交给底层存储后的事件：<br>    - <code>op_commit</code>: 操作已由主 OSD 提交（即，写入日志）。<br>    - <code>op_applied</code>: 操作已写入主 OSD 的后台文件系统（即，在内存中应用但未刷新到磁盘）。<br>    - <code>sub_op_applied</code>: 副本的 <code>op_applied</code>。<br>    - <code>sub_op_committed</code>: 副本的 <code>op_commit</code>（仅对 EC 池）。<br>    - <code>sub_op_commit_rec/sub_op_apply_rec from &lt;X&gt;</code>: 主 OSD 在听到上述消息后进行标记，但针对特定副本（即 <X>）。<br>    - <code>commit_sent</code>: 我们向客户端（或主 OSD，针对子操作）发送了回复。</p><p>虽然一些事件可能看起来冗余，但它们跨越了内部代码中的重要边界（例如，跨锁将数据传递到新线程中）。</p><h4 id="OSD抖动"><a href="#OSD抖动" class="headerlink" title="OSD抖动"></a>OSD抖动</h4><p>“抖动”是指 OSD 被快速重复标记为上线然后下线的现象。本节解释如何识别抖动以及如何减轻它。</p><p>当 OSD 进行对等和检查心跳时，它们使用集群（后端）网络。如果您的 OSD 节点有两个网络端口，将一个端口专用于公共网络，另一个端口专用于私有网络，可以避免网络维护和网络故障对集群或客户端造成的重大影响。在这种情况下，可以考虑将两个链接仅用于公共网络：使用绑定（LACP）或等成本路由（例如 FRR），可以获得更高的吞吐量容差、容错能力和减少 OSD 抖动。</p><p>当私有网络（甚至单个主机链接）故障或降级时，而公共网络正常运行，OSD 可能无法很好地处理这种情况。在这种情况下，OSD 使用公共网络向监视器报告彼此故障，同时将自己标记为上线。然后，监视器再次通过公共网络发送更新的集群地图，将受影响的 OSD 标记为下线。这些 OSD 向监视器回复“我还没死！”，然后循环重复。我们称这种情况为“抖动”，它可能很难隔离和修复。没有私有网络时，这种恼人的动态被避免了：OSD 通常要么上线要么下线，没有抖动。</p><p>如果某些原因导致 OSD “抖动”（被反复标记为下线然后再上线），您可以通过暂时冻结其状态来强制监视器停止抖动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceph osd <span class="built_in">set</span> noup      <span class="comment"># 防止 OSD 被标记为上线</span></span><br><span class="line">ceph osd <span class="built_in">set</span> nodown    <span class="comment"># 防止 OSD 被标记为下线</span></span><br></pre></td></tr></table></figure><p>这些标志记录在 osdmap 中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceph osd dump | grep flags</span><br><span class="line">flags no-up,no-down</span><br></pre></td></tr></table></figure><p>您可以使用以下命令清除这些标志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceph osd <span class="built_in">unset</span> noup</span><br><span class="line">ceph osd <span class="built_in">unset</span> nodown</span><br></pre></td></tr></table></figure><p>还有两个其他标志 <code>noin</code> 和 <code>noout</code>，它们分别防止启动的 OSD 被标记为分配数据（in）或保护 OSD 被标记为最终移除（out），无论 <code>mon_osd_down_out_interval</code> 的当前值如何。</p><p><strong>注意</strong></p><p><code>noup</code>、<code>noout</code> 和 <code>nodown</code> 是临时性的，因为清除标志后，它们阻止的操作应该很快能够恢复。但是 <code>noin</code> 标志防止 OSD 在启动时被标记为在线，任何在标志设置期间启动的守护进程将保持这种状态。</p><p><strong>注意</strong></p><p>通过仔细调整 <code>mon_osd_down_out_subtree_limit</code>、<code>mon_osd_reporter_subtree_level</code> 和 <code>mon_osd_min_down_reporters</code> 可以在一定程度上缓解抖动的原因和效果。最佳设置的推导取决于集群大小、拓扑结构和使用的 Ceph 版本。这些因素的交互很微妙，超出了本文档的范围。</p><p>由 Ceph 基金会提供</p><p>Ceph 文档是由非营利组织 Ceph 基金会资助和托管的社区资源。如果您想支持我们以及其他努力，请考虑立即加入。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;OSD故障排除&quot;&gt;&lt;a href=&quot;#OSD故障排除&quot; class=&quot;headerlink&quot; title=&quot;OSD故障排除&quot;&gt;&lt;/a&gt;OSD故障排除&lt;/h2&gt;&lt;p&gt;在故障排除集群的 OSD 之前，请先检查监视器和网络。&lt;br&gt;首先，确定监视器是否有法定人数。运行 </summary>
      
    
    
    
    <category term="云存储" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E5%AD%98%E5%82%A8/"/>
    
    <category term="Ceph" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E5%AD%98%E5%82%A8/Ceph/"/>
    
    
    <category term="云存储" scheme="https://watsonlu6.github.io/tags/%E4%BA%91%E5%AD%98%E5%82%A8/"/>
    
    <category term="Ceph" scheme="https://watsonlu6.github.io/tags/Ceph/"/>
    
  </entry>
  
  <entry>
    <title>Cpeh Mon常见故障处理</title>
    <link href="https://watsonlu6.github.io/Storage/Ceph/Ceph-Mon%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/"/>
    <id>https://watsonlu6.github.io/Storage/Ceph/Ceph-Mon%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/</id>
    <published>2022-10-06T06:53:31.000Z</published>
    <updated>2024-09-08T09:47:41.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="监视器故障排查"><a href="#监视器故障排查" class="headerlink" title="监视器故障排查"></a>监视器故障排查</h2><p>即使集群出现与监视器相关的问题，集群也不一定会面临宕机的风险。即使集群丢失了多个监视器，只要还有足够的监视器存活并能够形成法定人数（quorum），集群就能继续运行。<br>如果集群遇到了监视器相关的问题，可以参考以下的故障排查信息。</p><h4 id="初步故障排查"><a href="#初步故障排查" class="headerlink" title="初步故障排查"></a>初步故障排查</h4><p>Ceph 监视器故障排查的第一步是确保监视器正在运行，并且它们能够与网络进行通信。按照本节的步骤操作，以排除监视器故障的最简单原因。</p><ol><li><p><strong>确保监视器正在运行</strong><br>确保监视器守护进程（ceph-mon）正在运行。可能是由于升级后监视器没有重新启动。检查这个简单的疏忽可以节省大量的故障排查时间。同时，也要确保管理守护进程（ceph-mgr）正在运行。记住，典型的集群配置中，每个监视器（ceph-mon）都有一个相应的管理器（ceph-mgr）。<br><strong>注意：</strong> 在 v1.12.5 之前的版本中，Rook 不会运行超过两个管理器。</p></li><li><p><strong>确保可以访问监视器节点</strong><br>在某些罕见情况下，iptables 规则可能会阻止访问监视器节点或 TCP 端口。这些规则可能是以前压力测试或规则开发时遗留下来的。要检查是否存在这样的规则，可以通过 SSH 登录每个监视器节点，并使用 telnet、nc 或类似工具尝试连接到其他监视器节点的 tcp&#x2F;3300 和 tcp&#x2F;6789 端口。</p></li><li><p><strong>确保“ceph status”命令能够运行并从集群接收回复</strong><br>如果 ceph status 命令从集群接收到回复，说明集群正在运行。监视器只有在形成法定人数时才会响应状态请求。确认是否有一个或多个管理器（mgr）守护进程正在运行。在没有任何问题的集群中，ceph status 将报告所有管理器守护进程都在运行。如果 ceph status 命令未能从集群接收到回复，那么很可能是由于没有足够的监视器来形成法定人数。如果运行 ceph -s 命令时未指定进一步的选项，它会连接到任意选择的一个监视器。然而，在某些情况下，添加 -m 标志来连接特定的监视器（或按顺序连接几个特定的监视器）可能更有帮助，例如：ceph status -m mymon1。</p></li></ol><p>如果以上解决方案未能解决问题，可能需要逐一检查每个监视器。即使没有形成法定人数，仍然可以单独联系每个监视器，并使用 ceph tell mon.ID mon_status 命令请求其状态（此处 ID 是监视器的标识符）。对集群中的每个监视器运行 ceph tell mon.ID mon_status 命令。关于此命令的输出。还有另一种联系各个监视器的方法：通过 SSH 登录每个监视器节点并查询守护进程的管理套接字。</p><h4 id="使用监视器的管理套接字"><a href="#使用监视器的管理套接字" class="headerlink" title="使用监视器的管理套接字"></a>使用监视器的管理套接字</h4><p>监视器的管理套接字允许通过 Unix 套接字文件直接与特定的守护进程交互。此套接字文件位于监视器的运行目录中。管理套接字的默认目录是 <code>/var/run/ceph/ceph-mon.ID.asok</code>。可以覆盖管理套接字的默认位置。如果默认位置被覆盖，那么管理套接字会出现在其他位置。这种情况通常发生在集群的守护进程部署在容器中时。<br>要查找管理套接字的目录，请检查<code>ceph.conf</code> 文件以获取备用路径，或运行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-conf --name mon.ID --show-config-value admin_socket</span><br></pre></td></tr></table></figure><p>管理套接字只有在监视器守护进程运行时可用。每次监视器正常关闭时，管理套接字都会被移除。如果监视器未运行但管理套接字仍存在，可能是由于监视器未正确关闭。如果监视器未运行，将无法使用管理套接字，并且 ceph 命令很可能返回错误 111：连接被拒绝。</p><p>要访问管理套接字，请运行以下形式的 ceph tell 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph tell mon.&lt;id&gt; mon_status</span><br></pre></td></tr></table></figure><p>此命令通过管理套接字将帮助命令传递给指定的运行中的监视器守护进程 <code>&lt;id&gt;</code>。如果知道管理套接字文件的完整路径，可以更直接地运行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph --admin-daemon &lt;full_path_to_asok_file&gt; &lt;command&gt;</span><br></pre></td></tr></table></figure><p>运行 <code>ceph help</code> 显示通过管理套接字可用的所有受支持的命令。特别参考 <code>config get</code>、<code>config show</code>、<code>mon stat</code> 和 <code>quorum_status</code>。</p><h4 id="理解-mon-status"><a href="#理解-mon-status" class="headerlink" title="理解 mon_status"></a>理解 mon_status</h4><p>监视器的状态（由 <code>ceph tell mon.X mon_status</code> 命令报告）可以通过管理套接字获得。<code>ceph tell mon.X mon_status</code> 命令输出关于监视器的大量信息（包括在 <code>quorum_status</code> 命令输出中找到的信息）。</p><p><strong>注意</strong><br>命令 <code>ceph tell mon.X mon_status</code> 不应被字面输入。运行命令时，mon.X 的 X 部分应替换为 Ceph 集群中的特定值。</p><p>为了理解此命令的输出，考虑以下例子，看到 <code>ceph tell mon.c mon_status</code> 的输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;rank&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;state&quot;</span><span class="punctuation">:</span> <span class="string">&quot;peon&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;election_epoch&quot;</span><span class="punctuation">:</span> <span class="number">38</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;quorum&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;outside_quorum&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;extra_probe_peers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sync_provider&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;monmap&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;epoch&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;fsid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5c4e9d53-e2e1-478a-8061-f543f8be4cf8&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;modified&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2013-10-30 04:12:01.945629&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2013-10-29 14:14:41.914786&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;mons&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span> <span class="attr">&quot;rank&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;a&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;addr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:6789/0&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#123;</span> <span class="attr">&quot;rank&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;b&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;addr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:6790/0&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#123;</span> <span class="attr">&quot;rank&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;addr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:6795/0&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>该输出报告 monmap 中有三个监视器（a, b, 和 c），法定人数由两个监视器组成，而 c 是 peon。</p><p><strong>哪个监视器不在法定人数中？</strong><br>答案是 a（即 mon.a）。mon.a 不在法定人数中。</p><p><strong>我们如何知道在此示例中 mon.a 不在法定人数中？</strong><br>我们知道 mon.a 不在法定人数中，因为它的 rank 是 0，而 rank 为 0 的监视器根据定义不在法定人数中。如果我们检查法定人数集，可以看到集合中明显有两个监视器：1 和 2。但这些不是监视器名称，而是当前 monmap 中确立的监视器 rank。法定人数集不包括 rank 为 0 的监视器，根据 monmap，该监视器是 mon.a。</p><p><strong>监视器的 rank 是如何确定的？</strong><br>每当监视器被添加或从集群中移除时，监视器的 rank 会被计算（或重新计算）。rank 的计算遵循一个简单的规则：IP:PORT 组合越大，rank 越低。在此情况下，因为 127.0.0.1:6789（mon.a）在数值上小于其他两个 IP:PORT 组合（即 “监视器 b”的 127.0.0.1:6790 和 “监视器 c”的 127.0.0.1:6795），mon.a 拥有最高的 rank，即 rank 0。</p><h4 id="最常见的监视器问题"><a href="#最常见的监视器问题" class="headerlink" title="最常见的监视器问题"></a>最常见的监视器问题</h4><p><strong>集群有法定人数但至少有一个监视器关闭</strong><br>当集群有法定人数但至少有一个监视器关闭时，<code>ceph health detail</code> 会返回类似以下的消息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ceph health detail</span><br><span class="line">[snip]</span><br><span class="line">mon.a (rank 0) addr 127.0.0.1:6789/0 is down (out of quorum)</span><br></pre></td></tr></table></figure><p><strong>如何排查 Ceph 集群有法定人数但至少有一个监视器关闭的问题？</strong><br>确保 mon.a 正在运行。确保可以从其他监视器节点连接到 mon.a 的节点。也检查 TCP 端口。检查所有节点上的 iptables 和 nf_conntrack，并确保未丢弃&#x2F;拒绝连接。</p><p>如果这些初步故障排查无法解决问题，那么需要进一步调查。</p><p>首先，通过管理套接字检查有问题的监视器的 mon_status，如“使用监视器的管理套接字”和“理解 mon_status”中所述。如果监视器不在法定人数中，则其状态将是以下之一：probing（探测）、electing（选举中）或 synchronizing（同步中）。如果监视器的状态是 leader（领导者）或 peon（跟随者），则监视器认为自己在法定人数中，但集群的其余部分认为它不在法定人数中。排查过程中，可能处于 probing、electing 或 synchronizing 状态的监视器已进入法定人数。再次检查 <code>ceph status</code> 以确定排查过程中监视器是否已进入法定人数。如果监视器仍未进入法定人数，则继续参考本文件中的相关调查。</p><p><strong>监视器状态为 probing 是什么意思？</strong><br>如果 <code>ceph health detail</code> 显示监视器的状态为 probing，则该监视器仍在寻找其他监视器。每个监视器启动时都会在这个状态停留一段时间。当监视器连接到 monmap 中指定的其他监视器时，它就不再处于 probing 状态。监视器处于 probing 状态的时间取决于其所在集群的参数。例如，当监视器是单监视器集群的一部分时（在生产环境中绝对不要这样做），监视器几乎是瞬间通过 probing 状态。在多监视器集群中，监视器保持在 probing 状态，直到找到足够的监视器形成法定人数——这意味着如果集群中的三个监视器中有两个关闭，则剩下的一个监视器将无限期地保持在 probing 状态，直到您启动其他监视器之一。</p><p>如果已建立法定人数，则只要守护进程能够被访问，监视器守护进程应能够快速找到其他监视器。如果监视器卡在 probing 状态，并且您已经完成了上面描述的监视器之间通信的故障排查，那么可能是有问题的监视器尝试以错误地址连接其他监视器。mon_status 会输出监视器已知的 monmap：确定 monmap 中指定的其他监视器的位置是否与网络中监视器的位置匹配。如果不匹配，请参阅“恢复监视器的损坏 monmap”。如果 monmap 中指定的监视器位置与网络中的监视器位置匹配，则持久的 probing 状态可能与监视器节点之间严重的时钟偏差有关。</p><h3 id="监视器的状态为“electing”时意味着什么？"><a href="#监视器的状态为“electing”时意味着什么？" class="headerlink" title="监视器的状态为“electing”时意味着什么？"></a>监视器的状态为“electing”时意味着什么？</h3><p>如果 <code>ceph health detail</code> 显示某个监视器的状态为“electing”，这表明该监视器正在进行选举。选举通常会很快完成，但有时监视器可能会陷入所谓的选举风暴。如果选举状态持续存在，可以将有问题的监视器置于停机状态以进行调查。这只有在集群中有足够的存活监视器以形成仲裁的情况下才可行。</p><h3 id="监视器的状态为“synchronizing”时意味着什么？"><a href="#监视器的状态为“synchronizing”时意味着什么？" class="headerlink" title="监视器的状态为“synchronizing”时意味着什么？"></a>监视器的状态为“synchronizing”时意味着什么？</h3><p>如果 <code>ceph health detail</code> 显示某个监视器的状态为“synchronizing”，这意味着该监视器正在与集群的其他部分同步，以便加入仲裁。监视器与仲裁的其余部分同步所需的时间取决于集群监视器存储的大小、集群的规模以及集群的状态。通常较大且已降级的集群会使监视器在“synchronizing”状态停留的时间比较小且新建的集群更长。<br>如果监视器的状态在“synchronizing”和“electing”之间来回切换，这表明可能存在问题：集群状态可能正在快速推进（即生成新映射），而同步过程无法跟上新映射的生成速度。这个问题在 Cuttlefish 版本之前更为常见，因为同步过程在较新的版本中已经被重构和增强，以避免这种情况。如果您在较新的版本中遇到此问题，请在 Ceph 错误追踪系统中报告问题。准备并提供日志以支持您报告的任何错误。有关日志准备的信息，请参阅《日志准备》。</p><h3 id="监视器的状态为“leader”或“peon”时意味着什么？"><a href="#监视器的状态为“leader”或“peon”时意味着什么？" class="headerlink" title="监视器的状态为“leader”或“peon”时意味着什么？"></a>监视器的状态为“leader”或“peon”时意味着什么？</h3><p>在 Ceph 正常运行期间，当集群处于 HEALTH_OK 状态时，Ceph 集群中的一个监视器处于“leader”状态，其余的监视器处于“peon”状态。可以通过查看命令 <code>ceph tell &lt;mon_name&gt; mon_status</code> 返回的 state 键的值来确定给定监视器的状态。<br>如果 <code>ceph health detail</code> 显示监视器处于“leader”状态或“peon”状态，很可能存在时钟偏移。请遵循《时钟偏移》中的说明。如果您已经按照这些说明进行操作，但 <code>ceph health detail</code> 仍然显示监视器处于“leader”状态或“peon”状态，请在 Ceph 错误追踪系统中报告问题。如果您提出问题，请提供日志以支持它。有关日志准备的信息，请参阅《日志准备》。</p><h3 id="修复监视器的损坏“monmap”"><a href="#修复监视器的损坏“monmap”" class="headerlink" title="修复监视器的损坏“monmap”"></a>修复监视器的损坏“monmap”</h3><p>可以使用类似 <code>ceph tell mon.c mon_status</code> 的命令来检索 monmap。<br>下面是一个 monmap 的示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">epoch 3</span><br><span class="line">fsid 5c4e9d53-e2e1-478a-8061-f543f8be4cf8</span><br><span class="line">last_changed 2013-10-30 04:12:01.945629</span><br><span class="line">created 2013-10-29 14:14:41.914786</span><br><span class="line">0: 127.0.0.1:6789/0 mon.a</span><br><span class="line">1: 127.0.0.1:6790/0 mon.b</span><br><span class="line">2: 127.0.0.1:6795/0 mon.c</span><br></pre></td></tr></table></figure><p>这个 monmap 是正常的，但您可能的 monmap 可能不正常。在某个节点上的 monmap 可能会因为节点长时间宕机，而期间集群的监视器发生了变化，从而变得过时。</p><p>更新监视器过时的 monmap 有两种方法：</p><ol><li><p><strong>报废并重新部署监视器</strong><br>仅在确保不会丢失所报废监视器中保留的信息时使用此方法。确保有其他状态良好的监视器，以便新监视器能够与存活的监视器同步。请记住，如果没有其他监视器内容的副本，销毁监视器可能会导致数据丢失。</p></li><li><p><strong>将 monmap 注入监视器</strong><br>可以通过从集群中存活的监视器中检索最新的 monmap 并将其注入到损坏或缺失 monmap 的监视器中来修复它。<br>实施此解决方案请执行以下步骤：</p><ul><li><p>按以下方式之一检索 monmap：<br> <strong>如果存在监视器仲裁：</strong><br>从仲裁中检索 monmap：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph mon getmap -o /tmp/monmap</span><br></pre></td></tr></table></figure><p> <strong>如果没有监视器仲裁：</strong><br> 直接从已停止的监视器中检索 monmap：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-mon -i ID-FOO --extract-monmap /tmp/monmap</span><br></pre></td></tr></table></figure><p> 在此示例中，已停止监视器的 ID 是 ID-FOO。</p></li><li><p>停止将注入 monmap 的监视器：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service ceph -a stop mon.&#123;mon-id&#125;</span><br></pre></td></tr></table></figure></li><li><p>将 monmap 注入已停止的监视器：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-mon -i ID --inject-monmap /tmp/monmap</span><br></pre></td></tr></table></figure></li><li><p>启动监视器。</p></li></ul></li></ol><p><strong>警告</strong><br>将 monmap 注入监视器可能会引起严重问题。注入 monmap 会覆盖监视器上存储的最新 monmap。请小心操作！</p><h4 id="时钟偏移"><a href="#时钟偏移" class="headerlink" title="时钟偏移"></a>时钟偏移</h4><p>Paxos 共识算法需要紧密的时间同步，这意味着仲裁中的监视器之间的时钟偏移会对监视器的操作产生严重影响，导致一些令人困惑的行为。为避免这种问题，应在监视器节点上运行时钟同步工具，例如 Chrony 或传统的 ntpd 工具。配置每个监视器节点时确保启用了 iburst 选项，并确保每个监视器有多个对等节点，包括以下内容：</p><ul><li>其他监视器</li><li>内部 NTP 服务器</li><li>多个外部公共池服务器</li></ul><p><strong>注意</strong><br>iburst 选项在初始同步时会发送八个数据包，而不是通常的一个。此外，建议将集群中的所有节点与内部和外部服务器同步，甚至与监视器同步。请在物理机上运行 NTP 服务器，因为虚拟机的虚拟化时钟不适合稳定的时间保持。</p><h4 id="时钟偏移问题及解答"><a href="#时钟偏移问题及解答" class="headerlink" title="时钟偏移问题及解答"></a>时钟偏移问题及解答</h4><p><strong>容忍的最大时钟偏移是多少？</strong><br>默认情况下，监视器允许时钟最大漂移 0.05 秒（50 毫秒）。</p><p><strong>我可以增加最大容忍的时钟偏移吗？</strong><br>可以，但我们强烈建议不要这样做。最大容忍的时钟偏移可通过 <code>mon-clock-drift-allowed</code> 选项进行配置，但更改此选项几乎肯定是一个糟糕的决定。设定的时钟偏移上限是因为时钟不同步的监视器不可靠。当前的默认值已证明其在监视器遇到严重问题之前提醒用户方面的有效性。更改此值可能会对监视器的稳定性和整体集群健康状况造成不可预见的影响。</p><p><strong>我如何知道是否存在时钟偏移？</strong><br>当存在时钟偏移时，监视器会通过集群状态 <code>HEALTH_WARN</code> 发出警告。执行 <code>ceph health detail</code> 和 <code>ceph status</code> 命令时，输出类似如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mon.c addr 10.10.0.1:6789/0 clock skew 0.08235s &gt; max 0.05s (latency 0.0045s)</span><br></pre></td></tr></table></figure><p>在此示例中，监视器 <code>mon.c</code> 被标记为存在时钟偏移。<br>在 Luminous 及更高版本中，可以通过运行 <code>ceph time-sync-status</code> 命令来检查时钟偏移。注意，主监视器通常具有数值最低的 IP 地址。它始终显示 0：其他监视器报告的偏移是相对于主监视器的，而不是任何外部参考源。</p><p><strong>如果存在时钟偏移，我该怎么办？</strong><br>同步时钟。使用 NTP 客户端可能会有所帮助。但是，如果已经在使用 NTP 客户端并且仍然遇到时钟偏移问题，请确定使用的 NTP 服务器是否位于网络之外，还是托管在网络中。托管自己的 NTP 服务器往往可以缓解时钟偏移问题。</p><p><strong>客户端无法连接或挂载</strong><br>如果客户端无法连接到集群或挂载，请检查您的 iptables。一些操作系统安装程序会向 iptables 添加一个 REJECT 规则。iptables 规则会拒绝所有尝试连接到主机的客户端（除了 ssh）。如果您的监视器主机的 iptables 具有 REJECT 规则，则从单独节点连接的客户端会失败，并引发超时错误。检查 iptables 规则，看看是否有任何拒绝尝试连接到 Ceph 守护进程的客户端。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REJECT all -- anywhere anywhere reject-with icmp-host-prohibited</span><br></pre></td></tr></table></figure><p>可能还需要在 Ceph 主机上的 iptables 添加规则，以确保客户端能够访问与 Ceph 监视器（默认：端口 6789）和 Ceph OSD（默认：6800 到 7568）关联的 TCP 端口。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -m multiport -p tcp -s &#123;ip-address&#125;/&#123;netmask&#125; --dports 6789,6800:7568 -j ACCEPT</span><br></pre></td></tr></table></figure><h4 id="监视器存储故障"><a href="#监视器存储故障" class="headerlink" title="监视器存储故障"></a>监视器存储故障</h4><p><strong>存储损坏的症状</strong><br>Ceph 监视器在键值存储中维护集群地图。如果键值存储损坏导致监视器失败，则监视器日志可能包含以下错误消息之一：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Corruption: error in middle of record</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Corruption: 1 missing files; e.g.: /var/lib/ceph/mon/mon.foo/store.db/1234567.ldb</span><br></pre></td></tr></table></figure><p><strong>使用健康的监视器恢复</strong><br>如果集群中有幸存的监视器，损坏的监视器可以用新的监视器替换。新监视器启动后，它会与健康的对等体同步。新监视器完全同步后，将能够为客户端提供服务。</p><p><strong>使用 OSDs 进行恢复</strong><br>即使所有监视器同时失效，也可以使用存储在 OSDs 中的信息恢复监视器存储。建议在 Ceph 集群中部署至少三个（最好是五个）监视器。在这种部署中，完全的监视器故障是不太可能的。然而，如果数据中心在磁盘设置或文件系统设置配置不当的情况下发生意外断电，可能会导致底层文件系统故障，这可能会导致所有监视器故障。在这种情况下，OSDs 中的数据可用于恢复监视器。以下是可以在这种情况下使用的脚本来恢复监视器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">ms=/root/mon-store</span><br><span class="line"><span class="built_in">mkdir</span> <span class="variable">$ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># collect the cluster map from stopped OSDs</span></span><br><span class="line"><span class="keyword">for</span> host <span class="keyword">in</span> <span class="variable">$hosts</span>; <span class="keyword">do</span></span><br><span class="line">  rsync -avz <span class="variable">$ms</span>/. user@<span class="variable">$host</span>:<span class="variable">$ms</span>.remote</span><br><span class="line">  <span class="built_in">rm</span> -rf <span class="variable">$ms</span></span><br><span class="line">  ssh user@<span class="variable">$host</span> &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">    for osd in /var/lib/ceph/osd/ceph-*; do</span></span><br><span class="line"><span class="string">      ceph-objectstore-tool --data-path \$osd --no-mon-config --op update-mon-db --mon-store-path $ms.remote</span></span><br><span class="line"><span class="string">    done</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">  rsync -avz user@<span class="variable">$host</span>:<span class="variable">$ms</span>.remote/. <span class="variable">$ms</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rebuild the monitor store from the collected map, if the cluster does not</span></span><br><span class="line"><span class="comment"># use cephx authentication, we can skip the following steps to update the</span></span><br><span class="line"><span class="comment"># keyring with the caps, and there is no need to pass the &quot;--keyring&quot; option.</span></span><br><span class="line"><span class="comment"># i.e. just use &quot;ceph-monstore-tool $ms rebuild&quot; instead</span></span><br><span class="line">ceph-authtool /path/to/admin.keyring -n mon. \</span><br><span class="line">  --<span class="built_in">cap</span> mon <span class="string">&#x27;allow *&#x27;</span></span><br><span class="line">ceph-authtool /path/to/admin.keyring -n client.admin \</span><br><span class="line">  --<span class="built_in">cap</span> mon <span class="string">&#x27;allow *&#x27;</span> --<span class="built_in">cap</span> osd <span class="string">&#x27;allow *&#x27;</span> --<span class="built_in">cap</span> mds <span class="string">&#x27;allow *&#x27;</span></span><br><span class="line"><span class="comment"># add one or more ceph-mgr&#x27;s key to the keyring. in this case, an encoded key</span></span><br><span class="line"><span class="comment"># for mgr.x is added, you can find the encoded key in</span></span><br><span class="line"><span class="comment"># /etc/ceph/$&#123;cluster&#125;.$&#123;mgr_name&#125;.keyring on the machine where ceph-mgr is</span></span><br><span class="line"><span class="comment"># deployed</span></span><br><span class="line">ceph-authtool /path/to/admin.keyring --add-key <span class="string">&#x27;AQDN8kBe9PLWARAAZwxXMr+n85SBYbSlLcZnMA==&#x27;</span> -n mgr.x \</span><br><span class="line">  --<span class="built_in">cap</span> mon <span class="string">&#x27;allow profile mgr&#x27;</span> --<span class="built_in">cap</span> osd <span class="string">&#x27;allow *&#x27;</span> --<span class="built_in">cap</span> mds <span class="string">&#x27;allow *&#x27;</span></span><br><span class="line"><span class="comment"># If your monitors&#x27; ids are not sorted by ip address, please specify them in order.</span></span><br><span class="line"><span class="comment"># For example. if mon &#x27;a&#x27; is 10.0.0.3, mon &#x27;b&#x27; is 10.0.0.2, and mon &#x27;c&#x27; is  10.0.0.4,</span></span><br><span class="line"><span class="comment"># please passing &quot;--mon-ids b a c&quot;.</span></span><br><span class="line"><span class="comment"># In addition, if your monitors&#x27; ids are not single characters like &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, please</span></span><br><span class="line"><span class="comment"># specify them in the command line by passing them as arguments of the &quot;--mon-ids&quot;</span></span><br><span class="line"><span class="comment"># option. if you are not sure, please check your ceph.conf to see if there is any</span></span><br><span class="line"><span class="comment"># sections named like &#x27;[mon.foo]&#x27;. don&#x27;t pass the &quot;--mon-ids&quot; option, if you are</span></span><br><span class="line"><span class="comment"># using DNS SRV for looking up monitors.</span></span><br><span class="line">ceph-monstore-tool <span class="variable">$ms</span> rebuild -- --keyring /path/to/admin.keyring --mon-ids alpha beta gamma</span><br><span class="line"></span><br><span class="line"><span class="comment"># make a backup of the corrupted store.db just in case!  repeat for</span></span><br><span class="line"><span class="comment"># all monitors.</span></span><br><span class="line"><span class="built_in">mv</span> /var/lib/ceph/mon/mon.foo/store.db /var/lib/ceph/mon/mon.foo/store.db.corrupted</span><br><span class="line"></span><br><span class="line"><span class="comment"># move rebuild store.db into place.  repeat for all monitors.</span></span><br><span class="line"><span class="built_in">mv</span> <span class="variable">$ms</span>/store.db /var/lib/ceph/mon/mon.foo/store.db</span><br><span class="line"><span class="built_in">chown</span> -R ceph:ceph /var/lib/ceph/mon/mon.foo/store.db</span><br></pre></td></tr></table></figure><p>该脚本执行以下步骤：</p><ul><li>从每个 OSD 主机收集地图。</li><li>重建存储。</li><li>用适当的权限填充 keyring 文件中的实体。</li><li>用恢复的副本替换 mon.foo 上的损坏存储。</li></ul><p><strong>已知限制</strong><br>上述恢复工具无法恢复以下信息：</p><ul><li><strong>某些添加的 keyring</strong>：所有使用 <code>ceph auth add</code> 命令添加的 OSD keyring 都会从 OSD 的副本中恢复，并且使用 <code>ceph-monstore-tool</code> 导入 client.admin keyring。但是，MDS keyring 和其他所有 keyring 都会在恢复的监视器存储中缺失，可能需要手动重新添加。</li><li><strong>创建池</strong>：如果任何 RADOS 池正在创建过程中，则该状态会丢失。恢复工具假设所有池都已创建。如果恢复后部分创建的池中有 PG 卡在未知状态，可以运行 <code>ceph osd force-create-pg</code> 命令强制创建空 PG。只有当你确定池是空的时才采取此操作。</li><li><strong>MDS 映射</strong>：MDS 映射会丢失。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;监视器故障排查&quot;&gt;&lt;a href=&quot;#监视器故障排查&quot; class=&quot;headerlink&quot; title=&quot;监视器故障排查&quot;&gt;&lt;/a&gt;监视器故障排查&lt;/h2&gt;&lt;p&gt;即使集群出现与监视器相关的问题，集群也不一定会面临宕机的风险。即使集群丢失了多个监视器，只要还有足够</summary>
      
    
    
    
    <category term="云存储" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E5%AD%98%E5%82%A8/"/>
    
    <category term="Ceph" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E5%AD%98%E5%82%A8/Ceph/"/>
    
    
    <category term="云存储" scheme="https://watsonlu6.github.io/tags/%E4%BA%91%E5%AD%98%E5%82%A8/"/>
    
    <category term="Ceph" scheme="https://watsonlu6.github.io/tags/Ceph/"/>
    
  </entry>
  
  <entry>
    <title>Ceph Cache Tier源码实现</title>
    <link href="https://watsonlu6.github.io/Storage/Ceph/Ceph-Cache-Tier%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <id>https://watsonlu6.github.io/Storage/Ceph/Ceph-Cache-Tier%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-09-28T12:45:54.000Z</published>
    <updated>2024-09-01T13:34:00.917Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Cache-Tier架构"><a href="#Cache-Tier架构" class="headerlink" title="Cache Tier架构"></a>Cache Tier架构</h2><p>Ceph存储集群如果采用廉价的PC和传统的机械硬盘进行搭建，磁盘的访问速度受到了一定的限制，无法达到理想的IOPS性能水平。为了优化系统的IO性能，可以考虑添加快速的存储设备作为缓存，以减少数据的访问延时。其中，Cache Tier分层存储机制是一种常见的解决方案，在Ceph服务端缓存中被广泛使用，可以有效提升后端存储层的I&#x2F;O性能。Cache Tier需要创建一个由高速且昂贵的存储设备（如SSD）组成的存储池作为缓存层，以及一个相对廉价的设备组成的后端存储池作为经济存储层。缓存层使用多副本模式，存储层可以使用多副本或纠删码模式。<br><img src="/images/%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80%E4%B8%8ECeph%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A8/Cache-Tier%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0.png" alt="Cache Tier"><br>Ceph的缓存分层理论基础是数据存在热点，数据访问不均匀。通常，80%的应用只访问20%的数据，这20%的数据被称为热点数据。为了减少响应时间，可以将热点数据保存到性能较高的存储设备（如固态硬盘）中。在Cache Tiering中，有一个分层代理，当保存在缓存层的数据变冷或不再活跃时，该代理会将这些数据刷到存储层，并将其从缓存层中移除。这种操作称为刷新或逐出。在客户端读写数据时，Ceph的对象处理器负责决定对象存储的位置，而Cache Tier则决定何时将缓存层中的对象刷回后端存储层。对于写操作，请求到达缓存层后，完成写操作后直接应答客户端，之后由缓存层的代理线程负责将数据写入存储层。对于读操作，如果命中缓存层，直接在缓存层读取，否则可以重定向到存储层访问。如果数据近期有访问过，说明比较热，可以提升到缓存层中。对于Ceph客户端来说，缓存层和后端存储层是完全透明的。所有Ceph客户端都可以使用缓存层，因此Cache Tier具有提升块设备、Ceph对象存储、Ceph文件系统和原生绑定的I&#x2F;O性能的潜力。</p><h2 id="Ceph-Cache-tier处理流程"><a href="#Ceph-Cache-tier处理流程" class="headerlink" title="Ceph Cache tier处理流程"></a>Ceph Cache tier处理流程</h2><p>使用命令add-cache 可以将一个cachepool作为base pool的tier。这时会设置pool的信息，在pool里面记录了cache pool和base pool的关系。客户端在获取pool信息的时候可知，目标base pool存在一个tier，叫做cache pool，那么操作base pool的请求都会发送给cache pool。请求达到cache pool中时，作为tier的pool会有一些特别的处理maybe_cache_handle，具体的流程如下图：<br><img src="/images/%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80%E4%B8%8ECeph%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A8/Cache-Tier%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B02.png" alt="Cache Tier"></p><ul><li>判断操作的object是否在cache pool中命中，如果命中，则直接在cache pool中处理，和在普通pool的请求一样处理。后续会有agent线程将缓存脏数据刷写到base pool中。</li><li>没有命中缓存的情况下，才会去判断缓存模式。如果命中缓存，不管是什么模式都会在cache pool中处理。下面的处理都是未命中缓存的情况。</li><li>判断是否是writeback模式，读操作，如果可以proxy_read，那就直接do_proxy_read读取数据即可，不可以proxy_read 就使用do_cache_redirect，告诉客户端去base pool中读取。写操作，如果当前是evict_full模式，说明现在缓存中已经达到了阈值，需要等待缓存淘汰一些object，在完成写操作，目前放在等待队列中等待，如果不是evict_full模式，则需要从base pool中promote对应的object到cache pool中，promote结束后继续处理本次的写操作。</li><li>判断是否是forward模式。在forward模式下，不再在cachepool中处理请求，会告诉客户端将请求全部发送到base pool中。</li><li>判断是不是readonly模式。写操作会告诉客户端直接想base pool写即可，如果是读操作，则会从base pool中promote该object。</li><li>判断是不是readforward模式。该模式读操作全部都告诉客户端直接去base pool中读取即可，写操作按着writeback模式处理。</li><li>判断是不是readproxy模式。该模式读操作都采用cachepool的proxy read方法，写操作按着writeback模式处理。</li></ul><p>针对其中涉及到的几个封装好的方法的操作： do_cache_redirect， do_proxy_read， do_proxy_write，promote_object<br><img src="/images/%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80%E4%B8%8ECeph%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A8/Cache-Tier%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B03.png" alt="Cache Tier"></p><ul><li><strong>do_cache_redirect</strong> ：客户端请求cache pool，cache pool告诉客户端你应该去base pool中请求，客户端收到应答后，再次发送请求到base pool中请求数据，由base pool告诉客户端请求完成。</li><li><strong>do_proxy_read</strong>：客户端发送读请求到cache pool，但是未命中，则cache pool自己会发送请求到base pool中，获取数据后，由cache pool将数据发送给客户端，完成读请求。但是值得注意的是，虽然cache pool读取到了该object，但不会保存在cache pool中，下次请求仍然需要调用函数promote_objectbasePool读取该对象请求，然后写入cachePool中。</li><li><strong>do_proxy_write</strong>：直接写数据到basePool中，同样，cachePool中并没有该数据对象，还需要后续调用promote_object函数把数据对象从basePool中读到cachePool中。</li><li><strong>promote_object</strong>：当客户端发送请求到cache pool中，但是cache pool未命中，cache pool会选择将该object从base pool中提升到cache pool中，然后在cache pool进行读写操作，操作完成后告知客户端请求完成，在cache pool会缓存该object，下次直接在cache中处理，和proxy_read存在的区别。构造PromoteCallback回调函数，然后调用函数start_copyk拷贝函数。</li></ul><p>无论是 Proxy Read 还是 Promote Object 操作最终都是调用了 objecter 的 read 方法来从base storage层读取对象数据</p><h2 id="Cache-Tier数据结构"><a href="#Cache-Tier数据结构" class="headerlink" title="Cache Tier数据结构"></a>Cache Tier数据结构</h2><p>由于 Tier cache 在 Ceph 中的存在形式是存储池，pg_pool_t保存了存储池的相关属性。(src&#x2F;osd&#x2F;osd_type.h&#x2F;struct pg_pool_t)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">uint64_t</span>&gt; tiers;   <span class="comment">//如果当前pool是一个basePool，tiers就记录改basepool的cachePool层，一个base pool可以设置多个cachePool</span></span><br><span class="line"><span class="type">int64_t</span> tier_of;            <span class="comment">//如果当前pool是一个cachePool，那么tier_of记录了该cachePool的basePool</span></span><br><span class="line"><span class="type">int64_t</span> read_tier;       <span class="comment">//设置basePool的读缓存层，根据Ceph不同的Cache Tier模式来设置</span></span><br><span class="line"><span class="type">int64_t</span> write_tier;      <span class="comment">//设置basePool的写缓存层，根据Ceph不同的Cache Tier模式来设置</span></span><br><span class="line"><span class="type">cache_mode_t</span> cache_mode;  <span class="comment">//设置Cache Tier模式</span></span><br><span class="line"><span class="type">uint64_t</span> target_max_bytes;   <span class="comment">//设置了cachePool的最大字节数</span></span><br><span class="line"><span class="type">uint64_t</span> target_max_objects; <span class="comment">//设置了cachePool的最大对象数量</span></span><br><span class="line"><span class="type">uint32_t</span> cache_target_dirty_ratio_micro;   <span class="comment">// 目标脏数据率：当脏数据比例达到这个值，后台 agent 开始 flush 数据</span></span><br><span class="line"><span class="type">uint32_t</span> cache_target_dirty_high_ratio_micro;   <span class="comment">// 高目标脏数据率：当脏数据比例达到这个值，后台 agent 开始高速 flush 数据</span></span><br><span class="line"><span class="type">uint32_t</span> cache_target_full_ratio_micro;   <span class="comment">// 数据满的比率：当数据达到这个比例时，认为数据已满，需要进行缓存淘汰</span></span><br><span class="line"><span class="type">uint32_t</span> cache_min_flush_age;      <span class="comment">// 对象在 cache 中被刷入到 storage 层的最小时间</span></span><br><span class="line"><span class="type">uint32_t</span> cache_min_evict_age;   <span class="comment">// 对象在 cache 中被淘汰的最小时间</span></span><br><span class="line">HitSet::Params hit_set_params; <span class="comment">// HitSet 相关参数</span></span><br><span class="line"><span class="type">uint32_t</span> hit_set_period;     <span class="comment">// 每间隔 hit_set_period 一段时间，系统重新产生一个新的 hit_set 对象来记录对象的缓存统计信息</span></span><br><span class="line"><span class="type">uint32_t</span> hit_set_count;      <span class="comment">// 记录系统保存最近的多少个 hit_set 记录</span></span><br><span class="line"><span class="type">bool</span> use_gmt_hitset;        <span class="comment">// hitset archive 对象的命名规则 </span></span><br><span class="line"><span class="type">uint32_t</span> hit_set_grade_decay_rate;    <span class="comment">//当前hit_set在对象温度计数上具有最高优先级，后续hit_set的优先级比预hit_set衰减此参数</span></span><br><span class="line"><span class="type">uint32_t</span> hit_set_search_last_n;      <span class="comment">//为温度累积，最多N次hit_sets</span></span><br></pre></td></tr></table></figure><h4 id="读写IO"><a href="#读写IO" class="headerlink" title="读写IO"></a>读写IO</h4><p><strong>Add Cache</strong><br>在 ceph&#x2F;src&#x2F;mon&#x2F;OSDMonitor.cc 中实现了 add-cache 命令，从命令行中获取对应的参数并绑定 Tier 关系</p><p><strong>选择 Cache Pool</strong><br>Cache Tier的应用主要体现在计算OSD的过程中，通过判断basepool的参数，来决定是否要更新targetpool：读操作时，如果有read_tier，则更新为read_tier pool；写操作时，如果有write_tier，则更新为write_tier pool。read_tier和write_tier与pool是否开启Cache Tier有关。</p><p>在 ceph&#x2F;src&#x2F;osdc&#x2F;Objecter.cc&#x2F;Objecter::_calc_target中指定目标存储池为 Cache Pool，设置之后由后续的代码在该 Pool 中执行 Crush 算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先根据base_oloc.pool获取pool信息，获取pg_pool_t对象   </span></span><br><span class="line"><span class="type">const</span> <span class="type">pg_pool_t</span> *pi = osdmap-&gt;<span class="built_in">get_pg_pool</span>(t-&gt;base_oloc.pool);</span><br><span class="line"><span class="comment">// apply tiering 根据读写操作，分别设置需要操作的 tier</span></span><br><span class="line">t-&gt;target_oid = t-&gt;base_oid;         #base_oid        <span class="comment">//读取的对象              #target_oid;          //最终读取的目标对象</span></span><br><span class="line">t-&gt;target_oloc = t-&gt;base_oloc;     #base_oloc       <span class="comment">//对象的pool信息      #//target_oloc      //最终目标对象的pool信息</span></span><br><span class="line"><span class="keyword">if</span> ((t-&gt;flags &amp; CEPH_OSD_FLAG_IGNORE_OVERLAY) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//检查cache tier，如果是读操作，并且有读缓存，就设置t-&gt;target_oloc.pool为该pool的read_tier值。</span></span><br><span class="line"><span class="keyword">if</span> (is_read &amp;&amp; pi-&gt;<span class="built_in">has_read_tier</span>())</span><br><span class="line">    t-&gt;target_oloc.pool = pi-&gt;read_tier;</span><br><span class="line">    <span class="comment">//如果是写操作，并且有写缓存，就设置t-&gt;target_oloc.pool为该pool的write_tier值。</span></span><br><span class="line"><span class="keyword">if</span> (is_write &amp;&amp; pi-&gt;<span class="built_in">has_write_tier</span>())</span><br><span class="line">        t-&gt;target_oloc.pool = pi-&gt;write_tier;</span><br><span class="line">pi = osdmap-&gt;<span class="built_in">get_pg_pool</span>(t-&gt;target_oloc.pool);</span><br><span class="line"><span class="keyword">if</span> (!pi) &#123;</span><br><span class="line">    t-&gt;osd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> RECALC_OP_TARGET_POOL_DNE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>osd 先接收到客户端发送来的请求，然后OSD::dequeue_op()调用 PrimaryLogPG:: do_request()——&gt;PrimaryLogPG::do_op()中处理，这都是正常的一个 pool 处理请求的流程，在 do_op 中来看看不同于其他普通 pool 的处理。如果开启了Cache Tier，将会在do_op中执行以下操作：</p><ol><li>首先判断hit_set中是否包含待操作的对象（hit_set-&gt;contains(obc-&gt;obs.oi.soid)），如果不包含，则把对象添加到hit_set中。添加对象后，如果hit_set满了，或者hit_set超时，则调用hit_set_persist()。</li><li>执行agent_choose_mode()，设置agent相关参数，如flush_mode、num_objects、num_bytes等。</li><li>执行maybe_handle_cache()。这里处理cache执行逻辑。</li><li>如果maybe_handle_cache()中调用maybe_handle_cache_detail()，如果成功处理了op请求，则直接return，否则会继续执行后续操作（说明不需要从datapool读取数据或者转发请求到datapool，可以直接在此osd命中查询的对象），由本OSD执行读取操作。<br><img src="/images/%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80%E4%B8%8ECeph%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A8/Cache-Tier%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B01.png" alt="Cache Tier"></li></ol><h4 id="HitSet"><a href="#HitSet" class="headerlink" title="HitSet"></a>HitSet</h4><p>在 write back&#x2F;read forward&#x2F;read proxy 模式下需要 HitSet 来记录缓存命中。</p><p>HitSet 用于跟踪和统计对象的访问行为，记录对象是否存在缓存中。定义了一个缓存查找到抽象接口，目前提供了三种实现方式：ExplicitHashHitSet，ExplicitObjectHitSet，BloomHitSet</p><p>ceph&#x2F;src&#x2F;osd&#x2F;HitSet.h 定义了抽象接口，同时该头文件中包含了具体的 HitSet 实现</p><ul><li><strong>ExplicitHashHitSet</strong><ul><li>ceph&#x2F;src&#x2F;osd&#x2F;HitSet.h&#x2F;class ExplicitHashHitSet</li><li>基于对象的 32 位 HASH 值的 set 来记录对象的命中，每个对象占用 4 bytes 内存空间</li><li>优点：空间占用相对较少，但需要根据 HASH 进行全局的扫描遍历比较</li></ul></li><li><strong>ExplicitObjectHitSet</strong><ul><li>ceph&#x2F;src&#x2F;osd&#x2F;HitSet.h&#x2F;class ExplicitObjectHitSet</li><li>使用一个基于 ceph&#x2F;src&#x2F;common&#x2F;hobject 的 set 来记录对象的命中，占用的内存取决于对象的关键信息的大小</li><li>使用内存中缓存数据结构来进行判断带来的优点就是实现相对简单直观，但占用的内存空间相对较大</li></ul></li><li><strong>BloomHitSet</strong><ul><li>ceph&#x2F;src&#x2F;osd&#x2F;HitSet.h&#x2F;class BloomHitSet</li><li>采用了压缩的 Bloom Filter 的方式来记录对象是否在缓存中，进一步减少了内存占用空间</li></ul></li></ul><h3 id="Cache-Tier的初始化"><a href="#Cache-Tier的初始化" class="headerlink" title="Cache Tier的初始化"></a>Cache Tier的初始化</h3><ul><li>src&#x2F;osd&#x2F;PrimaryLogPG.cc&#x2F;PrimaryLogPG::hit_set_setup()用来创建并初始化HisSet对象</li><li>src&#x2F;osd&#x2F;PrimaryLogPG.cc&#x2F;PrimaryLogPG::agent_setup()完成agent相关的初始化工作</li></ul><h2 id="Cache-Pool-请求处理"><a href="#Cache-Pool-请求处理" class="headerlink" title="Cache Pool 请求处理"></a>Cache Pool 请求处理</h2><p>Cache 的相关请求处理可以通过do_op()进行梳理，主要包含了 agent_choose_mode()和 maybe_handle_cache() 两个主要方法。(src&#x2F;osd&#x2F;PrimaryLogPG.cc&#x2F;do_op(OpRequestRef &amp;))</p><p><strong>agent_choose_mode(bool restart, OpRequestRef op)</strong></p><ul><li>src&#x2F;osd&#x2F;PrimaryLogPG.cc&#x2F;agent_choose_mode</li><li>该函数主要计算一个 PG 的 flush_mode 和 evic_mode 的参数值。</li><li>返回值如果为 True，表明该请求 Op 被重新加入请求队列（由于 EvictMode 为 Full），其他情况返回 false。</li></ul><p><strong>maybe_handle_cache(…)</strong></p><ul><li>src&#x2F;osd&#x2F;PrimaryLogPG.cc&#x2F;maybe_handle_cache()调用maybe_handle_cache_detail(）</li><li>处理有关cache的读写请求</li></ul><!-- 图解maybe_handle_cache_detail()缓存策略将以上缓存策略的处理流程转换为流程图如下所示（注：流程细节随着Ceph版本的迭代已经有锁改变，此处重点关注最终的调用）![Cache Tier](/images/缓存基础与Ceph分层存储/Cache-Tier源码实现2.png)针对其中涉及到的几个封装好的方法的操作： do_cache_redirect， do_proxy_read， do_proxy_write，promote_object![Cache Tier](/images/缓存基础与Ceph分层存储/Cache-Tier源码实现3.png)- **do_cache_redirect** ：客户端请求cache pool，cache pool告诉客户端你应该去base pool中请求，客户端收到应答后，再次发送请求到base pool中请求数据，由base pool告诉客户端请求完成。- **do_proxy_read**：客户端发送读请求到cache pool，但是未命中，则cache pool自己会发送请求到base pool中，获取数据后，由cache pool将数据发送给客户端，完成读请求。但是值得注意的是，虽然cache pool读取到了该object，但不会保存在cache pool中，下次请求仍然需要调用函数promote_objectbasePool读取该对象请求，然后写入cachePool中。- **do_proxy_write**：直接写数据到basePool中，同样，cachePool中并没有该数据对象，还需要后续调用promote_object函数把数据对象从basePool中读到cachePool中。- **promote_object**：当客户端发送请求到cache pool中，但是cache pool未命中，cache pool会选择将该object从base pool中提升到cache pool中，然后在cache pool进行读写操作，操作完成后告知客户端请求完成，在cache pool会缓存该object，下次直接在cache中处理，和proxy_read存在的区别。构造PromoteCallback回调函数，然后调用函数start_copyk拷贝函数。无论是 Proxy Read 还是 Promote Object 操作最终都是调用了 objecter 的 read 方法来从base storage层读取对象数据 --><h4 id="Cache-flush-evict"><a href="#Cache-flush-evict" class="headerlink" title="Cache flush &amp; evict"></a>Cache flush &amp; evict</h4><p>cachePool空间不够时，需要选择一些脏数据对象会刷到数据层，即flush操作；将一些clean对象从缓存层剔除，以释放更多的缓存空间，即evict操作。这两种操作都是在后台线程完成的。<strong>flush操作和evict操作算法的好坏决定了Cache Tier的缓存命中率</strong>。evict是针对cachepool中已经过期或过冷的数据，只需要把它从cachepool中删除即可，evict操作通常会影响缓存命中率。flush是把脏数据刷新到storagePool，flush操作通常不会直接影响缓存命中率。flush操作是将缓存中的数据写回到持久存储介质中，从而保证数据的一致性，但并不会直接影响缓存的访问，脏数据是只保存在cachePool中，经过修改后，还未写入storagePool的数据。</p><p><strong>数据结构</strong><br>src&#x2F;osd&#x2F;osd.h&#x2F;OSDServices ：定义了 AgentThread 后台线程，用于完成 flush 和 evict 操作：一是把脏对象从cachePool层适时地会刷到basePool层；二是从cachePool层剔除掉一些不经常访问的clean对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Mutex agent_lock;     <span class="comment">// agent 线程锁，保护下面所有数据结构</span></span><br><span class="line">Cond agent_cond;     <span class="comment">// 线程相应的条件变量</span></span><br><span class="line">map&lt;<span class="type">uint64_t</span>, set&lt;PGRef&gt; &gt; agent_queue;   <span class="comment">// agent线程的工作队列，保存了OSD中所有归属于cachePool的淘汰或者回刷所需的 PG 集合，根据PG集合的优先级，保存在不同的map中</span></span><br><span class="line">set&lt;PGRef&gt;::iterator agent_queue_pos;   <span class="comment">//当前在扫描的PG集合的一个位置</span></span><br><span class="line"><span class="type">bool</span> agent_valid_iterator;  <span class="comment">//只有agent_valid_iterator为true时，agent_queue_pos指针才有效，否则从集合的起始处开始扫描</span></span><br><span class="line"><span class="type">int</span> agent_ops;            <span class="comment">// 所有正在进行的回刷和淘汰操作</span></span><br><span class="line"><span class="type">int</span> flush_mode_high_count;      <span class="comment">//一旦FLUSH_MODE_HIGH有了一个pg，就可以高速刷新对象</span></span><br><span class="line">set&lt;<span class="type">hobject_t</span>&gt; agent_oids;    <span class="comment">// 所有正在进行的 agent 操作（回刷或者淘汰）的对象</span></span><br><span class="line"><span class="type">bool</span> agent_active;    <span class="comment">// agent 是否有效</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AgentThread</span> : <span class="keyword">public</span> Thread&#123;&#125; agent_thread;    <span class="comment">// agent 线程，专门用来处理cache tier数据迁移的线程，线程名叫：osd_srv_agent。其作用就是循环遍历agent_queue中的所有pg，并对他们执行agent_work()操作。osd_srv_agent线程是一个OSD上所有PG公用的，为了保证效率，设置了严格的限流参数：osd_pool_default_cache_max_evict_check_size限制依次遍历对象的总数，达到后立刻切换退出循环在osd_srv_agent中切换PG；osd_agent_max_ops设置了一个循环中最多能够处理几次flush或者evict操作。</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> agent_stop_flag;   <span class="comment">// agent 停止的标志</span></span><br><span class="line">    SafeTimer agent_timer;   <span class="comment">//agent相关定时器：当扫描一个 PG 对象时，该对象既没有剔除操作，也没有回刷操作，就停止 PG 的扫描，把该 PG 加入到定时器中，5S 后继续</span></span><br></pre></td></tr></table></figure><p>src&#x2F;osd&#x2F;TierAgentState.h：TierAgentState用来保存PG相关的agent信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">hobject_t</span> position;    <span class="comment">//PG内扫描的对象位置</span></span><br><span class="line"><span class="type">int</span> started;    <span class="comment">//PG里所有对象扫描完成后，所发起的所有的agent操作数目。如果没有agent操作，就需要延迟一段时间</span></span><br><span class="line"><span class="type">hobject_t</span> start;    <span class="comment">//本次扫描起始位置</span></span><br><span class="line"><span class="type">bool</span> delaying;    <span class="comment">//是否延迟</span></span><br><span class="line"><span class="type">pow2_hist_t</span> temp_hist;   <span class="comment">//历史统计信息</span></span><br><span class="line"><span class="type">int</span> hist_age;</span><br><span class="line">map&lt;<span class="type">time_t</span>,HitSetRef&gt; hit_set_map;   <span class="comment">//Hitset的历史记录</span></span><br><span class="line">list&lt;<span class="type">hobject_t</span>&gt; recent_clean;   <span class="comment">//最近处于clean的对象</span></span><br><span class="line"><span class="type">unsigned</span> evict_effort;      <span class="comment">//应该驱逐的对象的大致比例（假设它们均匀分布）</span></span><br></pre></td></tr></table></figure><h4 id="flush-evict-执行入口"><a href="#flush-evict-执行入口" class="headerlink" title="flush&#x2F;evict 执行入口"></a>flush&#x2F;evict 执行入口</h4><p>src&#x2F;osd&#x2F;osd.cc&#x2F;OSDService::agent_entry：agent_entry 是 agent_thread 的入口函数，它在后台调用pg-&gt;agent_work()，agent_queue的改变是在PrimaryLogPG::agent_choose_mode函数中改变的</p><p>src&#x2F;osd&#x2F;PrimaryLogPG.cc&#x2F;PrimaryLogPG::agent_work：遍历PG中所有对象，去寻找已经过期的、失效的需要flush或者evict的对象并对它们执行相应操作。</p><ol><li><p>扫描本PG的对象，从 agent_state-&gt;position 开始扫描，结果保存在 ls 中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">hobject_t</span>&gt; ls;</span><br><span class="line"><span class="type">int</span> r = pgbackend-&gt;<span class="built_in">objects_list_partial</span>(agent_state-&gt;position, ls_min, ls_max, &amp;ls, &amp;next); </span><br></pre></td></tr></table></figure></li><li><p>对扫描的 ls 对象做相应的检查，执行 evict 操作和 flush 操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">hobject_t</span>&gt;::iterator p = ls.<span class="built_in">begin</span>();p != ls.<span class="built_in">end</span>(); ++p)     </span><br><span class="line"><span class="keyword">if</span> (agent_state-&gt;evict_mode != TierAgentState::EVICT_MODE_IDLE &amp;&amp; <span class="built_in">agent_maybe_evict</span>(obc, <span class="literal">false</span>))</span><br><span class="line">    ++started;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (agent_state-&gt;flush_mode!=TierAgentState::FLUSH_MODE_IDLE&amp;&amp;agent_flush_quota&gt;<span class="number">0</span>&amp;&amp;<span class="built_in">agent_maybe_flush</span>(obc)) &#123;</span><br><span class="line">    ++started;</span><br><span class="line">    --agent_flush_quota;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p>真正执行操作的方法</p><ul><li><strong>evict</strong>：src&#x2F;osd&#x2F;PrimaryLogPG.cc&#x2F;PrimaryLogPG::agent_maybe_evict</li><li><strong>flush</strong>：src&#x2F;osd&#x2F;PrimaryLogPG.cc&#x2F;PrimaryLogPG::agent_maybe_flush</li><li><strong>start_flush</strong>：src&#x2F;osd&#x2F;PrimaryLogPG.cc&#x2F;PrimaryLogPG::start_flush 该函数完成实际的 flush 操作</li><li><strong>start_manifest_flush</strong>：src&#x2F;osd&#x2F;PrimaryLogPG.cc&#x2F;PrimaryLogPG::start_manifest_flush  真正刷回数据之前的数据准备</li><li><strong>do_manifest_flush</strong>：src&#x2F;osd&#x2F;PrimaryLogPG.cc&#x2F;PrimaryLogPG::do_manifest_flush 真正刷回数据的过程</li></ul><p>flush 操作最终是以 Op 请求的方式传递到底层存储层的，也就意味着需要再执行一次 Ceph 存储池写数据的相关逻辑。<br>Ceph的Cache Tier功能目前在对象访问频率和热点统计上的实现都比较简单，可以通过基于自学习的Cache算法提升缓存命中率。</p><p><strong>agent_state在每个函数中都起到决定性地位</strong>：在agent_work中，agent_state-&gt;evict_mode和agent_state-&gt;flush_mode的值决定要不要进行evict和flush判断。在agent_maybe_evict和agent_maybe_flush中agent_state-&gt;evict_mode的值决定要不要直接执行evict或者flush。而agent_state值的计算过程是在agent_choose_mode函数中。agent_choose_mode函数计算一个PG的flush和evict行为的相关参数。该函数主要完成以下任务：</p><ul><li>统计当前PG中dirty object数量和当前PG中所有的object数量；（dirty object指的是脏数据对象)</li><li>统计当前PG中dirty object占用的字节数和当前PG中所有object占用的总的字节数；</li><li>分别从object数量角度和object占用的字节数角度计算dirty占比和full占比；</li><li>计算当前flush mode和evict mode；</li><li>更新agent_state-&gt;flush_mode和agent_state-&gt;evict_mode；</li><li>根据当前flush mode和evict mode决定是要将当前PG加入到待处理的PG队列中；</li></ul><p>从agent_choose_mode最后可以看到，如果缓存池需要flush或者evict，需要将待处理的PG加入到agent_queue队列中，这一动作是最终通过调用_enqueue函数实现，该函数主要完成以下任务：</p><ul><li>src&#x2F;osd&#x2F;OSD.h&#x2F;OSDService::_enqueue</li><li>判断是否需要调整agent线程要处理哪个pg set；</li><li>将待处理的pg加入到pg set中；</li><li>唤醒agent线程，执行flush或者evict任务；</li></ul><p>从agent_choose_mode最后可以看到，如果缓存池需不需要flush或者evict，但是如果之前agent线程有处理过该PG，需要将待处理的PG从agent_queue队列中移除掉，这一动作最终通过调用_dequeue函数实现，该函数主要完成以下任务：</p><ul><li>src&#x2F;osd&#x2F;OSD.h&#x2F;OSDService::_dequeue</li><li>根据old_priority从agent_queue队列中获取到相应的pg set；</li><li>在pg set中查找要移除的PG；如果找到了，从pg set中删除，并调整下一个要处理的PG；</li><li>如果删除之后的pg set没有任何一个PG，需要从agent_queue队列中移除，并调整下一个要处理的pg set；</li></ul><p><strong>agent_choose_mode流程图</strong><br><img src="/images/%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80%E4%B8%8ECeph%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A8/Cache-Tier%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B04.jpg" alt="Cache Tier"><br><strong>agent_entry流程图</strong><br><img src="/images/%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80%E4%B8%8ECeph%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A8/Cache-Tier%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B05.jpg" alt="Cache Tier"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Cache-Tier架构&quot;&gt;&lt;a href=&quot;#Cache-Tier架构&quot; class=&quot;headerlink&quot; title=&quot;Cache Tier架构&quot;&gt;&lt;/a&gt;Cache Tier架构&lt;/h2&gt;&lt;p&gt;Ceph存储集群如果采用廉价的PC和传统的机械硬盘进行搭建，</summary>
      
    
    
    
    <category term="云存储" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E5%AD%98%E5%82%A8/"/>
    
    <category term="Ceph" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E5%AD%98%E5%82%A8/Ceph/"/>
    
    
    <category term="云存储" scheme="https://watsonlu6.github.io/tags/%E4%BA%91%E5%AD%98%E5%82%A8/"/>
    
    <category term="Ceph" scheme="https://watsonlu6.github.io/tags/Ceph/"/>
    
  </entry>
  
  <entry>
    <title>Ceph Cache Tier使用介绍</title>
    <link href="https://watsonlu6.github.io/Storage/Ceph/Ceph-Cache-Tier%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>https://watsonlu6.github.io/Storage/Ceph/Ceph-Cache-Tier%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</id>
    <published>2022-08-25T08:45:47.000Z</published>
    <updated>2024-09-01T13:33:52.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、Ceph-Cache-Tier介绍"><a href="#1、Ceph-Cache-Tier介绍" class="headerlink" title="1、Ceph Cache Tier介绍"></a>1、Ceph Cache Tier介绍</h2><p>缓存层(Ceph Cache Tier)为 Ceph 客户端提供了存储在后备存储层中的一部分数据的更好 I&#x2F;O 性能。缓存分层涉及创建一个相对较快&#x2F;昂贵的存储设备池（例如固态硬盘），配置为缓存层，以及一个后备池，该池由纠删码或相对较慢&#x2F;更便宜的设备组成，配置为经济的存储层。Ceph 对象处理器决定对象的存放位置，而缓存代理负责决定何时将对象从缓存中刷新到后备存储层。因此，缓存层和后备存储层对 Ceph 客户端完全透明。<br><img src="/images/%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80%E4%B8%8ECeph%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A8/Cache-Tier%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0.png" alt="Cache Tier"><br>缓存分层代理会自动处理缓存层和后备存储层之间的数据迁移。不过，管理员可以通过设置缓存模式来配置这种迁移方式。</p><ul><li><strong>写回模式 (writeback mode)：</strong> 如果基础层和缓存层被配置为写回模式，Ceph 客户端每次将数据写入时会从基础层接收到 ACK 确认。然后，缓存分层代理会判断是否设置了 <code>osd_tier_default_cache_min_write_recency_for_promote</code>。如果已经设置，并且在指定时间间隔内数据被写入的次数超过设定值，那么数据将被提升到缓存层。当 Ceph 客户端需要访问存储在基础层的数据时，缓存分层代理会从基础层读取数据并返回给客户端。当数据从基础层读取时，缓存分层代理会查阅 <code>osd_tier_default_cache_min_read_recency_for_promote</code> 的值，并决定是否将数据从基础层提升到缓存层。当数据从基础层提升到缓存层后，Ceph 客户端可以通过缓存层对其进行 I&#x2F;O 操作。这种模式非常适合处理可变数据（例如，照片&#x2F;视频编辑，事务性数据）。</li><li><strong>读代理模式 (readproxy mode)：</strong> 该模式将使用缓存层中已存在的对象，但如果缓存中不存在该对象，请求将被代理到基础层。这在从写回模式过渡到禁用缓存的过程中非常有用，因为它允许在缓存被清空的同时，工作负载能够正常运行，而不向缓存添加任何新对象。</li><li><strong>只读模式 (readonly)：</strong> 该模式在读操作时将对象提升到缓存层；写操作则会被直接转发到基础层。该模式适用于无需存储系统强制保持一致性的只读工作负载。（警告：当对象在基础层中被更新时，Ceph 不会尝试将这些更新同步到缓存中的相应对象。由于该模式被认为是实验性的，因此启用时必须传递 <code>--yes-i-really-mean-it</code> 选项。）</li><li><strong>无缓存模式 (none)：</strong> 该模式用于完全禁用缓存。</li></ul><h2 id="2、使用Ceph-Cache-Tier"><a href="#2、使用Ceph-Cache-Tier" class="headerlink" title="2、使用Ceph Cache Tier"></a>2、使用Ceph Cache Tier</h2><p>要设置缓存分层，您必须拥有两个池。一个将作为后备存储，另一个将作为缓存。在后续示例中，我们将缓存池称为 <code>hot-storage</code>，后备池称为 <code>cold-storage</code>。</p><h4 id="2-1、设置后备存储池"><a href="#2-1、设置后备存储池" class="headerlink" title="2.1、设置后备存储池"></a>2.1、设置后备存储池</h4><p>设置后备存储池通常涉及以下两种场景之一：</p><ul><li><strong>标准存储：</strong> 在这种情况下，池在 Ceph 存储集群中存储对象的多个副本。</li><li><strong>纠删码：</strong> 在这种情况下，池使用纠删码来更高效地存储数据，代价是会有一些性能上的折扣。</li></ul><p>在标准存储场景中，可以设置一个 CRUSH 规则来确定故障域（例如，osd、主机、机箱、机架、行等）。当规则中的所有存储驱动器尺寸、速度（包括 RPM 和吞吐量）和类型一致时，Ceph OSD 守护进程的性能最佳。关于创建规则的详细信息，请参阅 CRUSH Maps。一旦创建了规则，就可以创建后备存储池。</p><h4 id="2-2、设置缓存池"><a href="#2-2、设置缓存池" class="headerlink" title="2.2、设置缓存池"></a>2.2、设置缓存池</h4><p>设置缓存池的过程与标准存储场景相同，但有以下不同：缓存层的驱动器通常是高性能驱动器，位于各自的服务器中，并拥有自己的 CRUSH 规则。设置此类规则时，应考虑拥有高性能驱动器的主机，同时排除没有这些驱动器的主机。</p><h4 id="2-3、创建缓存层"><a href="#2-3、创建缓存层" class="headerlink" title="2.3、创建缓存层"></a>2.3、创建缓存层</h4><p>设置缓存层需要将一个后备存储池与一个缓存池关联起来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd tier add &#123;storagepool&#125; &#123;cachepool&#125;</span><br></pre></td></tr></table></figure><p>要设置缓存模式，请执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd tier cache-mode &#123;cachepool&#125; &#123;cache-mode&#125;</span><br></pre></td></tr></table></figure><p>缓存层会覆盖后备存储层，因此还需要执行一个额外的步骤：必须将所有客户端流量从存储池直接引导到缓存池。为此，请执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd tier set-overlay &#123;storagepool&#125; &#123;cachepool&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4、配置缓存层"><a href="#2-4、配置缓存层" class="headerlink" title="2.4、配置缓存层"></a>2.4、配置缓存层</h4><p>缓存层有多种配置选项。您可以使用以下方式设置缓存层配置选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd pool <span class="built_in">set</span> &#123;cachepool&#125; &#123;key&#125; &#123;value&#125;</span><br></pre></td></tr></table></figure><h5 id="目标大小和类型"><a href="#目标大小和类型" class="headerlink" title="目标大小和类型"></a>目标大小和类型</h5><p>Ceph 的生产缓存层使用<code>布隆过滤器</code>作为 <code>hit_set_type</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd pool <span class="built_in">set</span> &#123;cachepool&#125; hit_set_type bloom</span><br></pre></td></tr></table></figure><p><code>hit_set_count</code> 和 <code>hit_set_period</code> 定义了要存储的 HitSets 数量以及每个 HitSet 应覆盖的时间长度：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ceph osd pool <span class="built_in">set</span> &#123;cachepool&#125; hit_set_count 12</span><br><span class="line">ceph osd pool <span class="built_in">set</span> &#123;cachepool&#125; hit_set_period 14400</span><br><span class="line">ceph osd pool <span class="built_in">set</span> &#123;cachepool&#125; target_max_bytes 1000000000000</span><br></pre></td></tr></table></figure><p><em>注意</em></p><ul><li>较大的 <code>hit_set_count</code> 会消耗更多的 RAM，影响 <code>ceph-osd</code> 进程的内存使用。</li><li>通过对访问时间的分类，Ceph 可以判断 Ceph 客户端是否在一定时间内访问了一个对象至少一次或多次（即“年龄” vs “热度”）。</li></ul><h5 id="读写缓存设置"><a href="#读写缓存设置" class="headerlink" title="读写缓存设置"></a>读写缓存设置</h5><p><code>min_read_recency_for_promote</code> 定义了在处理读操作时检查对象存在性的 HitSets 数量。检查结果用于决定是否异步提升对象。其值应在 0 到 <code>hit_set_count</code> 之间。如果设置为 0，对象将始终被提升；如果设置为 1，则仅检查当前 HitSet，如果对象在当前 HitSet 中，将被提升，否则不提升。对于其他值，将检查对应数量的历史 HitSets，如果对象出现在最近的<code>min_read_recency_for_promote</code> 个 HitSets 中，将会被提升。<br><code>min_write_recency_for_promote</code>定义了写操作可以设置类似的参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceph osd pool <span class="built_in">set</span> &#123;cachepool&#125; min_read_recency_for_promote 2</span><br><span class="line">ceph osd pool <span class="built_in">set</span> &#123;cachepool&#125; min_write_recency_for_promote 2</span><br></pre></td></tr></table></figure><p><em>注意</em></p><ul><li>周期越长、<code>min_read_recency_for_promote</code> 和 <code>min_write_recency_for_promote</code> 值越高，<code>ceph-osd</code> 守护进程消耗的 RAM 就越多。特别是在代理活动冲刷或驱逐缓存对象时，所有 <code>hit_set_count</code> 个 HitSets 都会加载到 RAM 中。</li></ul><h5 id="缓存大小设置"><a href="#缓存大小设置" class="headerlink" title="缓存大小设置"></a>缓存大小设置</h5><p>缓存分层代理执行两个主要功能：</p><ul><li><strong>冲刷：</strong> 代理识别已修改（或脏）对象并将其转发到存储池以供长期存储。</li><li><strong>驱逐：</strong> 代理识别未修改（或干净）的对象，并从中驱逐最少最近使用的对象。</li></ul><p><em><strong>绝对大小设置</strong></em><br>缓存分层代理可以基于字节总数或对象总数来冲刷或驱逐对象。要指定最大字节数，请执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd pool <span class="built_in">set</span> &#123;cachepool&#125; target_max_bytes &#123;bytes&#125;</span><br></pre></td></tr></table></figure><p>例如，要在 1 TB 时进行冲刷或驱逐，请执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd pool <span class="built_in">set</span> hot-storage target_max_bytes 1099511627776</span><br></pre></td></tr></table></figure><p>要指定最大对象数量，请执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd pool <span class="built_in">set</span> &#123;cachepool&#125; target_max_objects &#123;objects&#125;</span><br></pre></td></tr></table></figure><p>例如，要在 100 万个对象时进行冲刷或驱逐，请执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd pool <span class="built_in">set</span> hot-storage target_max_objects 1000000</span><br></pre></td></tr></table></figure><p><em>注意</em></p><ul><li>Ceph 无法自动确定缓存池的大小，因此这里需要对绝对大小进行配置，否则冲刷&#x2F;驱逐将无法正常工作。如果同时指定了两个限制，当任一阈值触发时，缓存分层代理将开始冲刷或驱逐。</li><li>仅当达到 <code>target_max_bytes</code> 或 <code>target_max_objects</code> 时，所有客户端请求才会被阻塞。</li></ul><p><em><strong>相对大小设置</strong></em><br>缓存分层代理可以相对于缓存池的大小（由绝对大小设置中的 <code>target_max_bytes</code> &#x2F; <code>target_max_objects</code> 指定）来冲刷或驱逐对象。当缓存池包含一定比例的已修改（或脏）对象时，缓存分层代理将冲刷它们到存储池。要设置 <code>cache_target_dirty_ratio</code>，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd pool <span class="built_in">set</span> &#123;cachepool&#125; cache_target_dirty_ratio &#123;0.0~1.0&#125;</span><br></pre></td></tr></table></figure><p>例如，将值设置为 0.4 当已修改（脏）对象达到缓存池容量的 40% 时开始冲刷：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd pool <span class="built_in">set</span> hot-storage cache_target_dirty_ratio 0.4</span><br></pre></td></tr></table></figure><p>当已修改（脏）对象达到一定比例时，以更高速度冲刷这些对象。设置 <code>cache_target_dirty_high_ratio</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd pool <span class="built_in">set</span> &#123;cachepool&#125; cache_target_dirty_high_ratio &#123;0.0~1.0&#125;</span><br></pre></td></tr></table></figure><p>例如，将值设置为 0.6 当已修改（脏）对象达到缓存池容量的 60% 时开始积极地冲刷脏对象。显然，最好将值设置在 <code>dirty_ratio</code> 和 <code>full_ratio</code> 之间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd pool <span class="built_in">set</span> hot-storage cache_target_dirty_high_ratio 0.6</span><br></pre></td></tr></table></figure><p>当缓存池达到一定容量比例时，缓存分层代理将驱逐对象以保持空闲容量。设置 <code>cache_target_full_ratio</code>，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd pool <span class="built_in">set</span> &#123;cachepool&#125; cache_target_full_ratio &#123;0.0~1.0&#125;</span><br></pre></td></tr></table></figure><p>例如，将值设置为 0.8，当未修改（干净）对象达到缓存池容量的 80% 时开始冲刷：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd pool <span class="built_in">set</span> hot-storage cache_target_full_ratio 0.8</span><br></pre></td></tr></table></figure><h5 id="缓存年龄"><a href="#缓存年龄" class="headerlink" title="缓存年龄"></a>缓存年龄</h5><p>可以指定对象在缓存分层代理将最近修改（或脏）对象冲刷到后备存储池之前的最小年龄：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd pool <span class="built_in">set</span> &#123;cachepool&#125; cache_min_flush_age &#123;seconds&#125;</span><br></pre></td></tr></table></figure><p>例如，在 10 分钟后冲刷修改（或脏）对象，请执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd pool <span class="built_in">set</span> hot-storage cache_min_flush_age 600</span><br></pre></td></tr></table></figure><p>可以指定对象在从缓存层驱逐之前的最小年龄：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd pool &#123;cache-tier&#125; cache_min_evict_age &#123;seconds&#125;</span><br></pre></td></tr></table></figure><p>例如，在 30 分钟后驱逐对象，请执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd pool <span class="built_in">set</span> hot-storage cache_min_evict_age 1800</span><br></pre></td></tr></table></figure><h5 id="移除缓存层"><a href="#移除缓存层" class="headerlink" title="移除缓存层"></a>移除缓存层</h5><p>移除缓存层的步骤取决于缓存是回写类型还是只读类型。<br><strong>移除只读缓存</strong><br>由于只读缓存没有已修改的数据，您可以在不丢失缓存中对象的任何最新更改的情况下禁用并移除它。<br>将缓存模式更改为 <code>none</code> 以禁用它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd tier cache-mode &#123;cachepool&#125; none</span><br></pre></td></tr></table></figure><p>从后备池中移除缓存池：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd tier remove &#123;storagepool&#125; &#123;cachepool&#125;</span><br></pre></td></tr></table></figure><p><strong>移除回写缓存</strong><br>由于回写缓存可能包含已修改的数据，因此在禁用并移除它之前，必须采取措施确保不会丢失缓存中对象的任何最新更改。<br>将缓存模式更改为 <code>proxy</code>，以便新对象和已修改对象将被冲刷到后备存储池：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd tier cache-mode &#123;cachepool&#125; proxy</span><br></pre></td></tr></table></figure><p>确保缓存池已经被冲刷。此过程可能需要几分钟：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rados -p &#123;cachepool&#125; <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>如果缓存池中仍有对象，可以手动冲刷它们。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rados -p &#123;cachepool&#125; cache-flush-evict-all</span><br></pre></td></tr></table></figure><p>移除覆盖，以便客户端不会将流量引导到缓存中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd tier remove-overlay &#123;storagetier&#125;</span><br></pre></td></tr></table></figure><p>最后，从后备存储池中移除缓存层池：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd tier remove &#123;storagepool&#125; &#123;cachepool&#125;</span><br></pre></td></tr></table></figure><h2 id="3、注意事项"><a href="#3、注意事项" class="headerlink" title="3、注意事项"></a>3、注意事项</h2><p>缓存分层会降低大多数工作负载的性能。在使用此功能之前，应格外谨慎。</p><ul><li><strong>依赖于工作负载：</strong> 缓存是否能够提升性能高度依赖于工作负载。由于将对象移入或移出缓存会产生一定的成本，缓存分层只有在数据集的访问模式存在较大偏斜时才有效，例如大多数请求集中访问少量对象。缓存池的大小应足够大，以捕获工作负载的工作集，从而避免缓存抖动。</li><li><strong>难以基准测试：</strong> 大多数用户用来衡量性能的基准测试在启用缓存分层时会显示出较差的性能，部分原因是这些测试很少将请求集中在少量对象上，缓存“预热”需要较长时间，而且预热的成本可能很高。</li><li><strong>通常更慢：</strong> 对于不适合缓存分层的工作负载，其性能通常会比没有启用缓存分层的普通 RADOS 池更慢。</li><li><strong>librados 对象枚举：</strong> librados 级别的对象枚举 API 在存在缓存时并不保证一致性。如果你的应用程序直接使用 librados 并依赖对象枚举，那么缓存分层可能不会如预期工作。（对于 RGW、RBD 或 CephFS，这不是问题。）</li><li><strong>复杂性：</strong> 启用缓存分层意味着 RADOS 集群内将使用大量额外的机制和增加的复杂性。这增加了你可能会遇到其他用户尚未遇到的系统错误的概率，并使你的部署面临更高的风险。</li></ul><h4 id="3-1、已知表现良好的工作负载"><a href="#3-1、已知表现良好的工作负载" class="headerlink" title="3.1、已知表现良好的工作负载"></a>3.1、已知表现良好的工作负载</h4><ul><li><strong>RGW 时间偏斜：</strong> 如果 RGW 工作负载的情况是几乎所有读操作都针对最近写入的对象，那么一个简单的缓存分层配置可以很好地工作，该配置在可配置的时间后将最近写入的对象从缓存层降级到基础层。</li></ul><h4 id="3-2、已知表现不佳的工作负载"><a href="#3-2、已知表现不佳的工作负载" class="headerlink" title="3.2、已知表现不佳的工作负载"></a>3.2、已知表现不佳的工作负载</h4><p>以下配置已知与缓存分层配合表现不佳。</p><ul><li><strong>RBD 与复制缓存和纠删码基础：</strong> 这是一个常见的请求，但通常表现不好。即使是相对倾斜的工作负载，仍然会将一些小的写入发送到冷对象上，而由于纠删码池尚不支持小的写操作，因此必须将整个对象（通常为 4 MB）迁移到缓存中，以满足一个小的（通常为 4 KB）写入请求。只有少数用户成功部署了这种配置，而且对他们而言，这仅在数据极为冷（备份）并且完全不敏感于性能的情况下有效。</li><li><strong>RBD 与复制缓存和基础层：</strong> 使用复制基础层的 RBD 比使用纠删码基础层的表现稍好，但仍然高度依赖于工作负载中的偏斜程度，并且非常难以验证。用户需要对其工作负载有很好的理解，并需要仔细调整缓存分层参数。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、Ceph-Cache-Tier介绍&quot;&gt;&lt;a href=&quot;#1、Ceph-Cache-Tier介绍&quot; class=&quot;headerlink&quot; title=&quot;1、Ceph Cache Tier介绍&quot;&gt;&lt;/a&gt;1、Ceph Cache Tier介绍&lt;/h2&gt;&lt;p&gt;缓存</summary>
      
    
    
    
    <category term="云存储" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E5%AD%98%E5%82%A8/"/>
    
    <category term="Ceph" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E5%AD%98%E5%82%A8/Ceph/"/>
    
    
    <category term="云存储" scheme="https://watsonlu6.github.io/tags/%E4%BA%91%E5%AD%98%E5%82%A8/"/>
    
    <category term="Ceph" scheme="https://watsonlu6.github.io/tags/Ceph/"/>
    
  </entry>
  
  <entry>
    <title>缓存基础与Ceph分层存储</title>
    <link href="https://watsonlu6.github.io/Storage/%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80%E4%B8%8ECeph%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A8/"/>
    <id>https://watsonlu6.github.io/Storage/%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80%E4%B8%8ECeph%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A8/</id>
    <published>2022-08-10T11:59:00.000Z</published>
    <updated>2024-09-01T13:34:14.905Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓存基础"><a href="#缓存基础" class="headerlink" title="缓存基础"></a>缓存基础</h2><ol><li><p><strong>缓存命中率</strong>：表示从缓存中获取数据的成功率，即缓存命中的次数与总访问次数的比值。缓存命中率越高，表示缓存系统的效率越高，能够更快地响应用户的请求。</p></li><li><p><strong>缓存失效率</strong>：表示从缓存中获取数据失败的次数与总访问次数的比值。缓存失效率越高，表示缓存系统的效率越低，需要从持久存储介质中读取数据的次数也越多，可能会导致系统的响应速度变慢。</p></li><li><p><strong>缓存容量</strong>：指缓存系统能够存储数据的最大容量。缓存容量的大小会影响缓存系统的性能和可靠性，如果缓存容量不足，可能会导致缓存系统频繁地进行evict操作，从而影响系统的响应速度和可用性。</p></li><li><p><strong>缓存算法</strong>：指缓存系统用于决定哪些数据被缓存，哪些数据被删除的算法。常见的缓存算法包括LRU（最近最少使用）、LFU（最不经常使用）、FIFO（先进先出）等。</p></li><li><p><strong>脏数据（Dirty Data）</strong>：指缓存中已经被修改但尚未被写回到持久存储介质（如磁盘）中的数据。这些数据需要及时写回到持久存储介质中以保证数据的一致性。常见的处理策略包括写回（write-back）和写直达（write-through）策略。</p></li><li><p><strong>干净数据（Clean Data）</strong>：指缓存中未被修改或已经被写回到持久存储介质中的数据。干净数据在缓存系统中可以快速读取，减少写入操作，优先选择删除干净数据可以避免写回操作带来的额外开销。</p></li><li><p><strong>evict操作</strong>：从缓存中移除某些数据，以释放缓存空间供其他数据使用。常用的策略包括LRU（Least Recently Used）等，根据最近最少使用的数据进行移除。</p></li><li><p><strong>flush操作</strong>：将缓存中的数据立即写回到持久性存储介质（例如硬盘），以确保缓存中的数据与存储介质中的数据保持一致。</p></li></ol><h4 id="数据一致性和性能考虑"><a href="#数据一致性和性能考虑" class="headerlink" title="数据一致性和性能考虑"></a>数据一致性和性能考虑</h4><ul><li><p><strong>脏数据的处理</strong>：存在脏数据可能导致数据一致性问题和性能问题，因此需要及时处理脏数据。选择适当的写回策略可以平衡数据一致性和系统性能。</p></li><li><p><strong>干净数据的优先删除</strong>：在缓存系统中，干净数据的存在可以提高系统性能，因为它们可以快速读取而不需要进行额外的写入操作。当需要从缓存中删除对象时，通常优先选择删除干净数据。</p></li><li><p><strong>flush操作的选择</strong>：通常在以下情况下使用flush操作：</p><ul><li>数据一致性要求高的场景，如数据库应用</li><li>性能要求不高或系统关闭时需要保证数据的持久性</li></ul></li><li><p><strong>evict操作的选择</strong>：通常在以下情况下使用evict操作：</p><ul><li>缓存空间不足，需要释放空间</li><li>数据访问模式固定或数据访问频率低</li><li>基于缓存替换算法（如LRU、LFU、FIFO等）</li></ul></li></ul><h4 id="缓存替换算法"><a href="#缓存替换算法" class="headerlink" title="缓存替换算法"></a>缓存替换算法</h4><ul><li><strong>LRU（Least Recently Used）</strong>：根据最近的访问时间来决定删除哪些数据。</li><li><strong>LFU（Least Frequently Used）</strong>：基于数据的访问频率选择删除数据。</li><li><strong>FIFO（First In First Out）</strong>：按照数据进入缓存的时间顺序移除数据。</li><li><strong>Random（随机）</strong>：随机选择数据进行删除，简单但效果不如其他算法。</li></ul><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><ul><li><p><strong>优化evict操作</strong>：通过使用动态策略（基于数据使用情况）和静态策略（基于数据属性），可以提升缓存性能。了解系统的负载和压力情况也有助于优化evict操作。</p></li><li><p><strong>缓存命中率影响</strong>：evict操作可能导致缓存命中率下降，因为被删除的数据可能被访问到。flush操作通常不会直接影响缓存命中率，但需要高效的实现以避免影响系统性能。</p></li></ul><p>这些基本要素和策略可以帮助优化缓存系统的性能和可靠性，根据具体的应用需求进行适当的调整和选择。</p><h2 id="Ceph分层存储Cache-Tier"><a href="#Ceph分层存储Cache-Tier" class="headerlink" title="Ceph分层存储Cache Tier"></a>Ceph分层存储Cache Tier</h2><p>分层存储是存储领域中的一个重要分支，其思想基石是存储的金字塔模型——描述了快速设备通常容量小而性能高，慢速设备通常容量大而性能低。对于数据访问而言，通常在一段时间内，真实数据的访问是具有时间局部性和空间局部性的。时间局部性是指被访问的数据在短时间内可能再次被访问，空间局部性是指与被访问数据临近的数据有更大的概率被访问。故基于时间局部性理论产生了通常所说的缓存，如：cpu缓存、内存等；而基于空间局部性原理，产生了数据预取，如：指令预取（prefetch）、数据预读（read ahead）等。</p><p>目前Ceph的OSD主要可以基于SSD或者HDD的裸盘进行构建，机械盘通常比固态盘容量大、价格比固态盘低、但读写比固态盘慢，如何用机械盘和固态盘来提供一个高可靠、高性能、高性价比的分布式存储是需要解决的重要问题。如果全部基于SSD进行构建，其性能一定会最优，但是SSD价格昂贵，出于成本考虑，不可能全部采用SSD进行构建，那么SSD与HDD混合硬件架构就显得很有必要。</p><p>Ceph的缓存分层理论基础是数据存在热点，数据访问不均匀。通常，80%的应用只访问20%的数据，这20%的数据被称为热点数据。为了减少响应时间，可以将热点数据保存到性能较高的存储设备（如固态硬盘）中。在Cache Tiering中，有一个分层代理，当保存在缓存层的数据变冷或不再活跃时，该代理会将这些数据刷到存储层，并将其从缓存层中移除。这种操作称为刷新或逐出。在客户端读写数据时，Ceph的对象处理器负责决定对象存储的位置，而Cache Tier则决定何时将缓存层中的对象刷回后端存储层。对于写操作，请求到达缓存层后，完成写操作后直接应答客户端，之后由缓存层的代理线程负责将数据写入存储层。对于读操作，如果命中缓存层，直接在缓存层读取，否则可以重定向到存储层访问。如果数据近期有访问过，说明比较热，可以提升到缓存层中。对于Ceph客户端来说，缓存层和后端存储层是完全透明的。所有Ceph客户端都可以使用缓存层，因此Cache Tier具有提升块设备、Ceph对象存储、Ceph文件系统和原生绑定的I&#x2F;O性能的潜力。<br><img src="/images/%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80%E4%B8%8ECeph%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A8/%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80%E4%B8%8ECeph%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A8.jpg" alt="Cache Tier"></p><p>Ceph Cache Tier提供了快速存储池与慢速存储池间的分层缓存特性。通常来说，对于块存储用户而言，数据访问会有明显的时间局部性与空间局部性，故可以通过分层存储思想，改善资源配置及效率。Ceph提供了Cache Tier的解决方案，能够融合两种存储，通过合理配比提供容量与性能介于SSD与HDD之间的虚拟存储资源池。对于对象存储而言，目前主要对外提供基于S3与Swift restful api的访问接口。RGW对象存储可以通过对数据池进行Cache Tier，从而提高其访问效率。</p><p>在Ceph中，分层存储系统通过缓存和存储池的方式实现，热资源池可以将数据存储至那些管理SSD磁盘的OSD上，而冷资源池可以将数据存储至那些管理HDD磁盘的OSD上。若客户命中被访问的数据落在热资源池中，可以直接被访问，此时IO速度最快，接近SSD磁盘的性能。<br><img src="/images/%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80%E4%B8%8ECeph%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A8/%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80%E4%B8%8ECeph%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A81.jpg" alt="Cache Tier命中"></p><p>若客户被访问的数据不落在热资源池中，出现缓存丢失的情况，需要转向去HDD盘上读取数据，而HDD盘处理请求访问速度为毫秒级别，故网络延时与请求处理延时可以近似忽略，认为其访问速度接近HDD磁盘的性能。这时候的处理分为两种：代理读写和数据拉取。当读写请求出现缓存丢失时，代理读写向后端请求冷数据，但缓存池不对数据进行缓存，直接将请求内容返回给客户端。<br><img src="/images/%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80%E4%B8%8ECeph%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A8/%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80%E4%B8%8ECeph%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A82.jpg" alt="缓存池的代理读写"></p><p>读写请求出现缓存丢失时，缓存池向后端请求冷数据，在向后端请求冷数据后，会将数据读入缓存池，继续处理客户端请求并返回请求内容。此外，短时间内被多次访问的数据会被认为是热数据而拉取到热池中，这将消耗HDD磁盘的读带宽与SSD磁盘的写入带宽。<br><img src="/images/%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80%E4%B8%8ECeph%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A8/%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80%E4%B8%8ECeph%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A83.jpg" alt="缓存池的数据拉取"></p><p>另一方面，在热池中的数据，需要定期回写入冷池，此时，回写数据将暂用SSD与HDD磁盘的部分带宽，这个过程叫数据回写。<br><img src="/images/%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80%E4%B8%8ECeph%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A8/%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80%E4%B8%8ECeph%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A84.jpg" alt="缓存池的数据回写"></p><p>还未回写入冷资源池的数据，在热资源池中再次被修改，这种情况越多，缓存效率越高，即相当于热资源池带宽充分利用，帮助冷资源池挡掉了大量的写入带宽。可以简单的认为，有1%的数据是需要脏回刷的（即回刷后的1%数据为clean状态，所以后续的命中会是非脏命中），如果所有数据都不脏回刷，且都访问命中的话，那么脏命中率为100%。</p><p>根据上述原理，不难发现，Ceph Cache Tier的性能取决于访问命中率。访问命中率越高时，存储系统越接近SSD磁盘的性能；反之，访问命中率越低时，越接近HDD磁盘的性能。另一方面，在Ceph中，缓存粒度以对象方式进行拉取与回写，故在实际情况下，如果缓存丢失过多，将会有大量的数据会被拉取，从而占用SSD磁盘的带宽，使得其访问带宽比SATA磁盘更差。然而，在实际生产使用过程中，数据总使用量总是逐步增加的，与此同时，热数据的量也将逐步的增加。那么，在整个使用周期中，随着数据量的增加，就必然会经历以下过程：首先刚刚开始使用时，数据量还很少。此时，所有数据全部能够被缓存，数据命中率为100%，效果很好。随着总数据量与热数据量不断的增加，缓存池已经无法容纳所有数据，只能容纳较多的热数据，此时缓存命中率会随之逐步的下降。随着数据的进一步增加，缓存命中率低于某个临界值了，此时保持同样大小的缓存池已经无法给使用带来足够好的收益。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;缓存基础&quot;&gt;&lt;a href=&quot;#缓存基础&quot; class=&quot;headerlink&quot; title=&quot;缓存基础&quot;&gt;&lt;/a&gt;缓存基础&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;缓存命中率&lt;/strong&gt;：表示从缓存中获取数据的成功率，即缓存命中的次数与总访问次数的</summary>
      
    
    
    
    <category term="云存储" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E5%AD%98%E5%82%A8/"/>
    
    <category term="Ceph" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E5%AD%98%E5%82%A8/Ceph/"/>
    
    
    <category term="云存储" scheme="https://watsonlu6.github.io/tags/%E4%BA%91%E5%AD%98%E5%82%A8/"/>
    
    <category term="Ceph" scheme="https://watsonlu6.github.io/tags/Ceph/"/>
    
  </entry>
  
  <entry>
    <title>存储系统缓存/分层相关论文</title>
    <link href="https://watsonlu6.github.io/Storage/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"/>
    <id>https://watsonlu6.github.io/Storage/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/</id>
    <published>2022-02-10T07:31:33.000Z</published>
    <updated>2024-08-04T07:59:18.239Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TDC-Pool-level-object-cache-replacement-algorithm-based-on-temperature-density"><a href="#TDC-Pool-level-object-cache-replacement-algorithm-based-on-temperature-density" class="headerlink" title="TDC: Pool-level object cache replacement algorithm based on temperature density"></a>TDC: Pool-level object cache replacement algorithm based on temperature density</h2><ul><li>在原生Ceph系统的基础上，提出缓存池的基于热度密度缓存替换算法，计算每个对象消耗空间的热度密度，并以最低的热度密度驱逐对象。通过驱逐对命中率贡献不大的对象，提高缓存池的命中率以及分层存储性能。</li><li>在 Ceph 中，Cache Tier通过缓存机制和存储池方式的实现，其将热数据存储SSD池，冷数据存储HDD池。若客户访问的数据直接命中落在SSD池中，可以直接被访问，此时IO速度最快 ，接近SSD磁盘的性能。但如果被访问的数据不在SSD池中，需要转向去HDD池上读取数据，而HDD盘处理请求访问速度为毫秒级别，则认为其访问速度接近HDD磁盘的性能。</li><li>目前 Cache Tier 采用的是基于频率估计的类 LRU缓存替换算法，并未充分利用数据对象所携带的元数据信息，这种频率估计概率存在误差，缓存命中率性能有限，且很难达到理论极限。因此实际使用时缓存命中率较低，导致较长的 IO 路径，使得Cache Tier性能表现较差。为进一步提升缓存命中率，考虑 Cache Tier 数据对象可以携带更多信息的特点，提出基于热度密度的缓存替换算法(TDC)。对象的热度计算基于访问频率，而热度密度计算基于热度和缓存对象占用时空的比例。通过引入热度密度计算，可以更准确地评估对象对命中率贡献，从而更有效地驱逐对命中率贡献不大的对象。</li><li>在用户文件上传到Ceph集群时，Ceph通过调用file_to_extents()函数将文件分割成若干个对象。面对数目庞大的对象，为了计算每个对象的访问热度值，采用Multiple Bloomfilter记录存储池每个对象访问的频率，通过这种方式有效地捕获更细粒度的最近性和频率。</li><li>将数据对象在缓存池中花费的时间和占用缓存空间视为缓存成本，这样，将缓存池中的对象对缓存命中率的贡献转化成一种成本效益分析。热度密度就是一种综合考虑对象大小、访问频率和访问时间等因素的指标，可以用来评估每个对象对缓存命中率的贡献，并根据热度密度来进行缓存替换。整个图形的热度密度可以表示为所有命中对象的贡献之和除以所有对象的占用缓存资源之和。通过比较已缓存对象的热度密度，并按一定比例删除热度密度较低的对象。</li></ul><h2 id="A-Survey-on-Tiering-and-Caching-in-High-Performance-Storage-Systems"><a href="#A-Survey-on-Tiering-and-Caching-in-High-Performance-Storage-Systems" class="headerlink" title="A Survey on Tiering and Caching in High-Performance Storage Systems"></a>A Survey on Tiering and Caching in High-Performance Storage Systems</h2><ul><li>论文讨论了针对高性能存储系统的缓存和分层解决方案研究。在第2节中，简要介绍了存储设备及其技术。在第3节中，讨论关于缓存解决方案及缓存算法的研究。在第4节中，讨论关于存储分层解决方案的研究。缓存和分层已被长期用于隐藏存储层次结构中慢速设备的长延迟。</li><li>基于响应时间，计算机存储系统被设计为有组织的多级层次结构，旨在提高整体性能和存储管理。不同类型的存储介质根据其性能、容量和控制技术指定为级别。通常，层次结构中级别越低，其带宽越小，存储容量越大。层次结构中有四个主要级别：处理器寄存器和缓存（SRAM、触发器或锁存缓冲区）、主存储器（DRAM）、辅助存储（SSD、HDD）、第三级存储（可移动存储设备）。图1概述了当前可用的和新兴的存储技术。表1比较了不同的计算机存储技术。</li><li>硬盘驱动器由固定在主轴周围的刚性快速旋转磁盘和使用致动器臂重新定位的磁头组成。数字数据以磁材料薄膜磁化转变的形式存储在每个磁盘上。HDD的机电方面和存储数据的串行化使得HDD比所提到的非易失性存储器技术慢几个数量级。然而，它的低价格和极高的密度使它成为二级和三级存储级别的理想选择。根据表1，HDD的容量可以比DRAM大1000倍，而操作延迟大约慢106倍。</li><li>IDC报告[58]预测到2020年，云将只触及数字世界的24%，13%将存储在云中，63%可能根本无法触及[58]。需要保护的数据的速度超过40%，甚至比数字世界本身还要快。因此，大部分数据通常存储在更便宜、更可靠和更大的设备中，而未经处理的部分数据则保存在快速存储介质中。因此，无疑需要具有缓存&#x2F;分层机制的混合存储系统</li><li>为了减轻慢设备的长延迟，可以在混合存储系统中使用缓存机制。缓存子系统有两个主要原则：1）在将原始数据保持在层次结构的中等级别时，缓存中存在一个处理不足的数据副本；以及2）缓存层中数据的生命周期短，并且它是临时的。</li><li>分层ARC（H-ARC）[12]缓存是一种基于NVM的缓存，它优化了ARC算法，以考虑最近、频率、脏和干净四种状态，并首先将缓存拆分为脏&#x2F;干净页缓存，然后将每个部分拆分为最近&#x2F;频率页缓存。基于与ARC类似的机制，它在每个级别上按层次调整每个部分的大小。因此，H-ARC在缓存中保持较高频率的脏页的时间更长。</li><li>如今，多层存储系统中使用了许多具有不同特性和容量的存储介质。缓存和分层之间的主要区别在于，在缓存系统中，数据的副本保存在缓存中，而在分层系统中，原始数据通过升级和降级两种操作在多个层之间迁移。数据根据应用程序需求和可用层的特性进行分类，通常分为热层和冷层。热数据驻留在性能层，冷数据留在容量层。考虑到随机性、传输速度等多种因素，可能有两个以上的层。</li></ul><h2 id="eMRC-Efficient-Miss-Ratio-Approximation-for-Multi-Tier-Caching"><a href="#eMRC-Efficient-Miss-Ratio-Approximation-for-Multi-Tier-Caching" class="headerlink" title="eMRC: Efficient Miss Ratio Approximation for Multi-Tier Caching"></a>eMRC: Efficient Miss Ratio Approximation for Multi-Tier Caching</h2><ul><li>研究高效的多层缓冲命中率分析技术</li><li>未命中率曲线（MRC）是捕获工作负载特性和调整系统行为的有用工具。MRC表示缓存大小和相应的缓存未命中率之间的关系。假设随着时间的推移，工作负载相对稳定，从观察到的IO跟踪得出的MRC对于单层缓存有效工作[13]。</li><li>许多存储缓存分配方法使用未命中率曲线（MRC）来提高缓存效率。然而，他们只关注单层缓存架构，并需要整个MRC作为缓存管理的输入，而现代数据中心采用分层缓存架构以最大限度地提高资源利用率。由于每个缓存层的逐出策略和容量不同，为多层缓存生成MRC（我们称之为未命中率函数）要困难得多。我们引入eMRC，一种多维未命中率近似技术，以实现多层缓存的高效MRC生成。论文使用了一种新颖的多维性能悬崖去除方法和凸包近似技术，以使用少量采样点有效地生成没有悬崖的多维MRC。</li><li>多层缓存需要一种有效的、低开销的缓存管理方案，因为多层的任意缓存配置可能会因其副作用而对租户不利[27]。为具有不同服务级别目标（SLO）的租户配置缓存需要对缓存的每一层进行高效、准确的缓存性能分析。</li><li>扩展：已经有很多关于MRC(miss ratio curves)的理论，来对上层缓存进行建模，得出程序分配缓存大小和性能的关系模型：MissRatio&#x3D;F(capacity)。基本分为两种方法：1、通过数据重新访问距离(reuse distance)，来建立MRC模型。2、通过数据重新访问时间(reuse time)，来建立MRC模型。</li></ul><h2 id="PHOEBE-Reuse-Aware-Online-Caching-with-Reinforcement-Learning-for-Emerging-Storage-Models"><a href="#PHOEBE-Reuse-Aware-Online-Caching-with-Reinforcement-Learning-for-Emerging-Storage-Models" class="headerlink" title="PHOEBE: Reuse-Aware Online Caching with Reinforcement Learning for Emerging Storage Models"></a>PHOEBE: Reuse-Aware Online Caching with Reinforcement Learning for Emerging Storage Models</h2><ul><li>NVMe和SSD是新兴存储技术的公认代表，具有数据持久性、高访问速度、低功耗和字节寻址能力。高性能采用这些技术的一个关键问题是如何正确定义智能缓存层，以便能够很好地弥补新兴技术和主存储器之间的性能差距。快速的主机端内存和慢速的后端存储驱动器之间的延迟差异很大，存储I&#x2F;O仍然是性能瓶颈，这导致了难以置信的长I&#x2F;O等待时间和大量CPU闲置浪费。为了缓解这种延迟差异，缓存层被广泛用于驻留在主存储器和后端存储驱动器之间。缓存系统的性能通常受到三个因素的影响：数据分配策略、数据热识别的准确性和数据驱逐策略。数据分配策略基本上控制数据流，并确定各种数据的接纳，例如只读、只读或两者兼而有之；数据热识别的高精度可以防止不必要数据对缓存的污染，通过局部保护提高缓存性能；数据驱逐策略决定在缓存已满时驱逐哪个数据块，从而间接增加了缓存的有效容量。这三个因素关注三个不同的方面，具有高度相关性。值得一提的是，传统的缓存策略，如LRU和LFU，并不是一个符合所有这些因素的通用解决方案（Li等人2019；Li和Gu 2020；Liu等人2020）。</li><li>PHOEBE是一种基于强化学习的在线缓存的可重用优化方案，适用于广泛的新兴存储模型。通过与缓存环境和数据流的持续交互，PHOEBE能够从单个跟踪中提取关键的时间数据依赖性和相对位置信息，随着时间的推移变得越来越智能。实验结果表明，PHOEBE能够将LRU和最先进的基于在线学习的缓存策略Belady最优策略之间的缓存未命中率差距分别缩小70.3%和52.6%。</li><li>PHOEBE预测了一个新定义的指标，即停留优先级，以表示每个数据块的相对重要性，而不是显式预测重用距离，重用距离可能是无界值，从而增加了高精度预测的难度和复杂性。当驱逐事件发生时，缓存根据其停留优先级值替换数据块（驱逐具有最低停留优先级的数据块），旨在最大化缓存命中率。停留优先级值具有时间滞后特性，在过时时间戳处的高优先级值不能在最新时间戳处保持同样高，因此它们通常与相应的时间戳组合以得出最终驱逐决定。PHOEBE关注9个特征来提取同时考虑全局和局部模式的重用信息。前六个特征和最后一个是全局特征；第7和第8特征是从当前数据块之前的滑动窗口收集的局部特征。数据块地址、数据块地址增量、频率、重复使用距离、最终重复使用距离、平均重复使用距离、滑动窗口中的频率、滑动窗口中的缓存未命中数、优先级值</li><li>将在线缓存问题建模为马尔可夫决策过程</li><li>LeCaR（Vietri等人，2018）：一种基于在线学习的缓存策略，根据学习到的概率在LRU和LFU缓存算法之间切换。</li><li>相关工作：将机器学习应用于缓存优化有两个主要途径：设计智能预取策略或改进缓存替换策略。</li></ul><h2 id="Sprout-A-functional-caching-approach-to-minimize-service-latency-in-erasure-coded-storage"><a href="#Sprout-A-functional-caching-approach-to-minimize-service-latency-in-erasure-coded-storage" class="headerlink" title="Sprout: A functional caching approach to minimize service latency in erasure-coded storage"></a>Sprout: A functional caching approach to minimize service latency in erasure-coded storage</h2><ul><li>利用缓存优化纠删码存储的性能，没有优化缓存策略。</li><li>论文提出一种新的具有纠删码存储的缓存框架，称为功能缓存。功能缓存涉及在缓存中使用纠删码块，使得存储节点中的块和缓存组合形成的代码是最大距离可分离（MDS）纠删码。</li></ul><h2 id="SSD-HDD混合存储中基于顺序封装的缓存取出"><a href="#SSD-HDD混合存储中基于顺序封装的缓存取出" class="headerlink" title="SSD-HDD混合存储中基于顺序封装的缓存取出"></a>SSD-HDD混合存储中基于顺序封装的缓存取出</h2><ul><li>论文提出了一种基于顺序打包的缓存逐出技术，该技术将垃圾收集（GC）块中的相邻冷数据页与位于其他SSD块中的相邻冷数据页数据分组。然后，打包这些数据页一起flush到较低级别的HDD存储中，以充分利用HDD的高顺序带宽。该方法可以减少写放大对SSD缓存的负面影响，并有助于提高SSD-HDD混合存储的I&#x2F;O性能。</li><li>Shi等人[13]提出了SSDUP+，该SSDUP＋采用SSD设备来缓冲随机访问的数据，并且顺序访问的数据被刷新到磁盘的低级别存储。在SSDUP+中，需要SSD缓存来缓存热读数据，尽管它们揭示了序列特征并直接刷新到HDD上。也就是说，如果SSD缓存已满，SSDUP+必须使用最近最少使用（LRU）策略来处理缓存逐出。</li><li>将热数据放在快速存储中，将冷数据放在慢速存储中并不是一个新想法，分层存储管理通常采用快速存储作为慢速存储的缓冲[5]。已经推出了许多结合HDD和SSD的混合存储解决方案，以提高读写吞吐量[11、12、14、15]。Chen等人[11]提出Hystor将低成本HDD和高速SSD相结合，以识别关键数据（例如元数据），从而将其保存在SSD中以快速响应。此外，它利用SSD作为回写缓冲区来吸收写请求，从而产生更好的写性能。HotDataTrap[20]建议仅缓冲SSD缓存中的热数据，并将冷数据直接刷新到HDD，这为热数据存储在缓存空间中提供了更多机会。类似地，Zhang等人[21]提出了一种基于机器学习的混合存储系统写策略。具体来说，它使用机器学习来识别只写数据，并将其直接刷新到HDD中，以最大限度地减少SSD的写入流量。混合存储系统的性能受到数据刷新例程或缓存逐出方案的严重影响[2，8]。</li><li>SeqPack的Hot Read&#x2F;Write Separate模块维护两个固定长度的LRU链接列表，以分别记录最近读取和写入的数据页，用于筛选热读取数据页而不是热写入。具体而言，在发生读或写访问之后，可以将数据页插入或移动到相应链接列表的开头。然后，两个LRU链接列表都维护最近访问的读写页，这样我们可以筛选热读数据页，但不筛选热写数据页，它们可以始终缓存在SSD缓存中，同时其他数据页被视为顺序打包的候选页。sequential packer模块依赖于所提出的顺序打包模型，通过将GC块中的弹出页面与其他SSD块中的冷数据页面打包，将许多随机写入分组为大型顺序写入。GC Selector模块以较小的成本释放SSD空间，引入了一种基于成本的选择方法来定位GC目标块，<ul><li>性能指标：I&#x2F;O响应时间、缓存命中率、长尾延迟。</li></ul></li></ul><h2 id="Improving-in-memory-file-system-reading-performance-by-fine-grained-user-space-cache-mechanisms（大数据场景的缓存优化）"><a href="#Improving-in-memory-file-system-reading-performance-by-fine-grained-user-space-cache-mechanisms（大数据场景的缓存优化）" class="headerlink" title="Improving in-memory file system reading performance by fine-grained user-space cache mechanisms（大数据场景的缓存优化）"></a>Improving in-memory file system reading performance by fine-grained user-space cache mechanisms（大数据场景的缓存优化）</h2><ul><li>随着服务器的内存容量越来越大，分布式内存文件系统已被广泛使用，该系统使应用程序能够快速与数据交互。然而，现有的分布式内存文件系统在小数据读取中仍然面临数据访问性能低的问题（非混合存储），这严重降低了它们在许多重要的大数据场景中的可用性。论文分析了影响内存文件读取性能的因素，并提出了一种两层用户空间缓存管理机制：在第一层，我们缓存数据包引用以减少频繁的页面故障中断（包级缓存）；在第二层，我们缓存和管理小文件数据单元，以避免冗余的进程间通信（对象级缓存）。设计了一个基于子模块函数优化理论的细粒度缓存模型，以有效地管理客户端具有部分重叠片段的可变长度缓存单元，更准确地识别热碎片，避免不必要的RPC通信。。重点是设计可变长度缓存块的管理机制和替换策略。</li><li>[15]提出了一种缓存模型，该模型使用不同的LRU队列来管理不同大小的文件。因此，它可以减少小文件被部分锁定的频率。为了使应用程序能够从客户端节点读取和写入数据，而不会失去全局文件系统命名空间的优势。传统的缓存替换策略包括FIFO、LRU[17]、LFU[18]、ARC[19]、FBR[20]和2Q[21]。根据[19]的结果，ARC通过复杂的自调整机制改进了基本的LRU策略，在各种工作负载上优于上述算法。然而，对大数据工作负载的实验表明，即使使用非常大的缓存空间，传统的缓存方法仍然遭受相对较低的命中率[22]。为了进一步提高I&#x2F;O性能，研究人员提出了大量方法，这些方法通过专门的指标来替代缓存候选[23–26]。</li><li>许多智能技术应用于广泛领域[33-35]。受此启发，一些研究人员采用了先进的数学方法或机器学习模型来描述和分析缓存问题。例如，[24，36]考虑马尔可夫决策过程背景下的缓存替换问题，[37，38]提出了基于强化学习和长短期记忆神经网络的更复杂场景下的智能缓存替换框架。特别是，在这些算法中，基于概率模型的EVA[24]通过充分利用所有缓存单元的命中、逐出和年龄分布，实现了最佳性能。</li><li>数据压缩是另一种常用于优化缓存空间利用率的策略。通常，压缩用于优化存储级别的访问性能。事实上，压缩也可以用于优化缓存性能[45–48]。压缩可以扩大有效的缓存容量，因此，通过保存更多对象可以减少缓存未命中。然而，由于压缩&#x2F;解压缩过程，压缩方案引入了额外的访问延迟。更糟糕的是，由于压缩比不可预测，这可能会导致性能下降。</li><li>数据包级缓存机制：在分布式文件系统中，要读取的数据被拆分为数据包，以便在多次小规模读取时容错和提高性能。当读取文件时，客户端调用mmap()将数据包映射到进程的虚拟地址空间，并调用munmap()读取后立即释放映射区域。在某种情况下，每个计算任务都将调用mmap()和munmap()，导致多页错误中断。为了提高读取性能，论文设计了一种包级缓存机制：在读取后不会立即释放它们，而是设法存储读取数据包的引用以供后续使用。数据包级缓存机制维护缓存队列。如果数据包的引用被减少到0，则该数据包的参考被放入队列。当队列大小超过阈值, 包将由munmap()根据缓存迁移策略调用。（带有优先级计数和缓存队列的数据包级缓存机制）</li><li>对象级缓存机制：哈希表：在第一级，整个文件被分成几个桶；每个文件片段根据其起始地址和结束地址被放入特定的存储桶中。红黑树：当单个存储桶中的单元数量超过限制时，缓存模型会根据当前存储桶中所有元素的地址将其放入红黑树中。当存储桶中的单元数小于限制时，原始红黑树将被删除。双重链接列表：文件片段自然按其起始地址和结束地址排序。每个缓存单元包含指向最近单元的前指针和后指针。</li><li>为了获得对象级缓存模型中缓存管理问题的近似解，论文实现了[53]提出的两种Greedy和ISK算法</li></ul><h2 id="Improving-NAND-Flash-Based-Disk-Caches"><a href="#Improving-NAND-Flash-Based-Disk-Caches" class="headerlink" title="Improving NAND Flash Based Disk Caches"></a>Improving NAND Flash Based Disk Caches</h2><ul><li>论文介绍了Flash在当今的服务器平台中用作磁盘缓存的研究。提出了两项改进。第一种方法通过将基于Flash的磁盘缓存拆分为单独的读写区域来提高性能和可靠性。第二种通过采用可编程闪存控制器来提高可靠性。它可以根据应用的需求改变错误码强度（可纠正位的数量）和存储单元可以存储的位的数量（单元密度）。Flash的可管理性和可靠性是一个具有挑战性的问题，需要解决这些问题才能将Flash完全集成到数据中心。提出了一种用于NAND闪存的硬件辅助软件管理磁盘缓存。</li><li>为了减轻磨损，对基于闪存的磁盘缓存的闪存擦除执行磨损级别管理。对于读缓存和写缓存，首先使用LRU策略选择要逐出的块，该策略针对磁盘缓存容量未命中（对于读缓存）或容量写入（对于写缓存，需要首先擦除块的异地写入）。然而，如果该块的磨损超过最新块的磨损预定阈值，则驱逐与最小磨损相对应的块（最新块）以平衡磨损水平。从整个闪存块集合中选择最新的块。在驱逐最新的块之前，它的内容被迁移到旧块。</li></ul><h2 id="Optimizing-the-SSD-Burst-Buffer-by-Traffic-Detection（细粒度缓存替换策略）"><a href="#Optimizing-the-SSD-Burst-Buffer-by-Traffic-Detection（细粒度缓存替换策略）" class="headerlink" title="Optimizing the SSD Burst Buffer by Traffic Detection（细粒度缓存替换策略）"></a>Optimizing the SSD Burst Buffer by Traffic Detection（细粒度缓存替换策略）</h2><ul><li>HPC存储系统仍然使用硬盘驱动器（HDD）作为其主要存储设备。固态驱动器（SSD）被广泛部署为HDD的缓冲区。还提出了突发缓冲器来管理突发写入请求的SSD缓冲。虽然突发缓冲区在许多情况下可以提高I&#x2F;O性能，但它具有一些限制，例如需要大的SSD容量以及计算阶段和数据flush阶段之间的和谐重叠。提出了一种称为SSDUP+的方案。SSDUP+旨在通过解决上述限制来改善突发缓冲区。首先，为了减少对SSD容量的需求，只选择一部分数据写入SSD，而其余数据则直接写入HDD，而不牺牲I&#x2F;O性能。开发了一种新的方法来检测和量化写入流量中的数据随机性。此外，提出了一种自适应算法来动态地对随机写入进行分类。通过这样做，需要更少的SSD容量来实现与其他突发缓冲方案类似的性能。然后，为了克服计算阶段和flush阶段完美重叠的困难，提出了SSD缓冲区的流水线机制，在流水线机制中，SSD缓冲区被分成两半。当一半接收写入数据时，另一半完全占用将数据从SSD刷新到HDD。其中数据缓冲和刷新在流水线中执行。为了提高I&#x2F;O吞吐量，采用了流量感知刷新策略来减少HDD中的I&#x2F;O干扰。最后，为了进一步提高SSD中缓冲随机写入的性能，SSDUP+通过使用日志结构存储数据，将SSD中的随机写入转换为顺序写入。此外，SSDUP+使用AVL树结构来存储数据的序列信息。SSDUP+以减少满足突发性大规模I&#x2F;O访问性能所需的SSD容量，从另一个角度来看，在相同的SSD容量下提高I&#x2F;O性能。</li><li>硬盘驱动器（HDD）仍然被用作HPC存储系统中的主要永久存储设备，部分原因是其成本低，可以在访问大型连续数据块时提供高带宽。然而，HDD有一个主要缺点：当随机访问数据时，由于磁盘头的缓慢机械移动，它们的性能很差。固态驱动器（SSD）等新的存储设备由于其接近零的寻道延迟和优异的性能（特别是对于随机访问）而被广泛部署在HPC环境中。然而，SSD比HDD昂贵得多。因此，在大规模生产HPC系统中使用SSD作为唯一的存储设备并不是一个经济高效的解决方案，更不用说SSD的技术限制，例如磨损和寿命有限的问题。解决HDD随机数据访问问题的一个流行解决方案是使用SSD缓冲HDD和计算节点之间的数据流。另一方面，对HDD的突发随机写入可能会显著降低HPC存储系统上运行的数据密集型应用程序的性能。为了解决上述问题，引入了突发缓冲器，它使用SSD缓冲器作为计算节点和基于HDD的存储服务器之间的中间层，以吸收突发写入请求。</li></ul><h2 id="Exploration-and-Exploitation-for-Buffer-Controlled-HDD-Writes-for-SSD-HDD-Hybrid-Storage-Server（细粒度缓存替换策略）"><a href="#Exploration-and-Exploitation-for-Buffer-Controlled-HDD-Writes-for-SSD-HDD-Hybrid-Storage-Server（细粒度缓存替换策略）" class="headerlink" title="Exploration and Exploitation for Buffer-Controlled HDD-Writes for SSD-HDD Hybrid Storage Server（细粒度缓存替换策略）"></a>Exploration and Exploitation for Buffer-Controlled HDD-Writes for SSD-HDD Hybrid Storage Server（细粒度缓存替换策略）</h2><ul><li>结合固态驱动器（SSD）和硬盘驱动器（HDD）的混合存储服务器为应用程序提供了成本效益和μ级响应能力。会导致HDD通常利用不足，而SSD使用过度，特别是在密集写入下。这会导致SSD的快速磨损和高尾部延迟。HDD的一系列顺序和连续写入呈现出周期性、阶梯状的写入延迟模式，即低（35μs）、中（55μs）和高延迟（12毫秒），这是由HDD控制器内的缓冲写入导致的。可以利用HDD的潜在μs级IO延迟，以吸收过多的SSD写入，而不会降低性能。论文建立了一个描述阶梯行为的HDD写入模型，并设计了一个配置过程来初始化和动态重新校准模型参数。然后，提出了一种缓冲区控制写入方法（BCW），以主动控制缓冲区写入，从而用应用程序数据调度低延迟和中延迟时段，并用填充数据填充高延迟时段。利用BCW，设计了一个混合IO调度器（MIOS），以自适应地将传入数据引导到SSD和HDD。进一步设计了多HDD调度以最小化HDD写入延迟</li></ul><h2 id="Cache-Replacement-Policy-Based-on-Expected-Hit-Count"><a href="#Cache-Replacement-Policy-Based-on-Expected-Hit-Count" class="headerlink" title="Cache Replacement Policy Based on Expected Hit Count"></a>Cache Replacement Policy Based on Expected Hit Count</h2><ul><li>现有处理器采用最近最少使用（LRU）策略的变体来确定替换的缓存块。不幸的是，LRU提供的服务与Belady的MIN之间存在很大差距，这是最佳的更换策略。Belady的MIN要求选择具有最长重用距离的缓存块，因此，由于需要了解未来，这是不可行的。在论文研究中，发现缓存块的预期命中数与其重用距离的倒数之间存在很强的相关性。论文提出了用于替换缓存中的缓存块的预期命中计数（EHC）策略，在现有低成本替换策略的基础上，采用基于命中计数的缓存块选择程序，以显著提高最后一级缓存中缓存块选择的质量，而无需相应的区域开销。</li><li>现代处理器经常需要从最后一级缓存中移出一段数据，以便为新数据留出空间。替换策略决定了在所有可能的候选项中，在新数据到达时应该从缓存中删除哪个候选项。</li><li>使用第二届缓存替换锦标赛（CRC2）发布的模拟框架评估预期命中计数（EHC）策略。</li></ul><h2 id="Hystor-Making-the-best-use-of-solid-state-drives-in-high-performance-storage-systems（分层存储）"><a href="#Hystor-Making-the-best-use-of-solid-state-drives-in-high-performance-storage-systems（分层存储）" class="headerlink" title="Hystor: Making the best use of solid state drives in high performance storage systems（分层存储）"></a>Hystor: Making the best use of solid state drives in high performance storage systems（分层存储）</h2><ul><li>由于SSD相对较高的价格和较低的容量，需要解决的一个主要系统研究问题是如何以成本和性能有效的方式使SSD在高性能存储系统中发挥最有效的作用。论文设计和实现Hystor高性能混合存储系统，Hystor将SSD和HDD作为一个单块设备进行管理，Hystor可以有效地识别（1）可能导致长延迟或（2）语义关键的块（例如文件系统元数据），并将其存储在SSD中以供将来访问，从而实现显著的性能改进。为了进一步利用最先进SSD中极高的写入性能，Hystor还充当回写缓冲区，以加快写入请求。</li><li>将高容量SSD视为存储的一部分，而不是缓存位置。相应地，与基于缓存的传统策略不同，基于缓存的策略在每次数据访问时频繁更新缓存内容，论文只定期和异步地重新组织设备之间的块布局，以实现长期优化。Hystor通过三个主要组件实现其数据管理的优化目标。首先，通过实时监控I&#x2F;O流量，Hystor自动学习工作负载访问模式并识别性能关键块。只有能够带来最大性能优势的块才能从HDD重新映射到高速SSD。第二，通过有效利用现有接口中可用的高级信息，Hystor识别语义关键块（例如文件系统元数据），并及时为它们提供高优先级，使其留在SSD中，这进一步提高了系统性能。第三，传入的写入被缓冲到低延迟SSD中，以提高写入密集型工作负载的性能。</li></ul><h2 id="Back-to-the-Future-Leveraging-Belady’s-Algorithm-for-Improved-Cache-Replacement"><a href="#Back-to-the-Future-Leveraging-Belady’s-Algorithm-for-Improved-Cache-Replacement" class="headerlink" title="Back to the Future: Leveraging Belady’s Algorithm for Improved Cache Replacement"></a>Back to the Future: Leveraging Belady’s Algorithm for Improved Cache Replacement</h2><ul><li>缓存是减少数据访问的长延迟的重要机制，其有效性受到其替换策略的显著影响。论文解释了缓存替换算法如何通过将其应用于过去的缓存访问来学习Belady的算法，以告知未来的缓存替换决策。并提出了基于Belady的缓存替换算法，将Belady方法的变体应用于过去的内存访问历史。如果过去的行为是未来行为的良好预测，论文提出的策略将接近Belady算法的行为。新缓存替换策略由两部分组成。第一个使用OPTgen算法重构了Belady对过去缓存访问的最佳解决方案。第二个是一个预测器，它可以学习OPT对过去PC的行为，以告知同一PC对未来负载的驱逐决定。</li><li>在缺乏明确反馈的情况下，现有的替换策略基于启发式方法，如最近最少使用（LRU）和最近最多使用（MRU），这两种方法都适用于不同的工作负载。然而，即使使用越来越聪明的技术来优化和组合这些策略，这些基于启发式的解决方案也仅限于特定类别的访问模式，无法在更复杂的场景中表现良好。</li><li>将缓存替换视为一个二进制分类问题，其目标是确定传入的行是缓存友好的还是缓存厌恶的：缓存友好的行以高优先级插入，而缓存厌恶的行被标记为未来冲突的驱逐候选行。为了确定传入线路应如何分类，Hawkeye重构了Belady对过去访问的最优解决方案，以了解单个加载指令的行为。</li></ul><h2 id="Performance-Evaluation-of-Traditional-Caching-Policies-on-A-Large-System-with-Petabytes-of-Data"><a href="#Performance-Evaluation-of-Traditional-Caching-Policies-on-A-Large-System-with-Petabytes-of-Data" class="headerlink" title="Performance Evaluation of Traditional Caching Policies on A Large System with Petabytes of Data"></a>Performance Evaluation of Traditional Caching Policies on A Large System with Petabytes of Data</h2><ul><li>大多数现有的缓存性能研究都评估填充相对较小缓存的、相当小的文件。很少有报告讨论了传统缓存替换策略在超大系统上的性能。论文在PB级存储系统中，全面评估了几种缓存策略的性能，包括先进先出（FIFO）、最近最少使用（LRU）和最不频繁使用（LFU）。研究表明当应用于大型数据集和小型数据集时，传统缓存策略能够提高性能。</li><li>在整个评估过程中，FIFO缓存替换策略经常导致比LRU或LFU显著更低的命中率，尽管有一小部分数据点的FIFO命中率较高。LRU缓存替换策略在所有测试的替换策略中获得了最高的比率，但与LFU策略相比，LRU导致平均命中率的标准偏差更高。当排除攻击性用户时，LFU缓存替换策略的平均命中率最高，而当LRU包含攻击性用户后，该策略的命中率仅超过0.29%。</li><li>将可用缓存的大小增加一倍，最多可以提高12%的命中率。论文建议额外的需求可以通过简单地扩展缓存大小来降低性能增益的价值。论文认为，对专用缓存策略进行更彻底的检查能够专注于大规模缓存大小的优化。通过将所使用的缓存大小增加一倍，命中率发生了相对较小的变化，这表明，在使用更有效的缓存策略的同时，缩小总体缓存大小将节省大量空间，并减少用作缓存所需的活动磁盘数。</li><li>预取是另一种有可能显著提高缓存性能的技术[24]，[25]，[26]，[27]，[28]。事实上，预取比简单地用流行文档加载缓存更有效[33]。有效的预取策略可以帮助缓存将命中率提高50%[32]。智能地预加载数据可以在不增加成本的情况下实现性能提高，因为使用预取的缓存可以与不使用预取缓存的两倍缓存一样有效[30]。已经证明，使用有效的预取方案可以显著减少不同缓存替换策略的命中率之间的差异，增强了格式良好的预取算法的重要性[33]。</li></ul><h2 id="Improving-Cache-Management-Policies-Using-Dynamic-Reuse-Distances"><a href="#Improving-Cache-Management-Policies-Using-Dynamic-Reuse-Distances" class="headerlink" title="Improving Cache Management Policies Using Dynamic Reuse Distances"></a>Improving Cache Management Policies Using Dynamic Reuse Distances</h2><ul><li>论文提出了一种新的PDP缓存管理策略，一种使用动态重用距离来进一步改进缓存替换策略，该策略防止替换缓存线，直到对其缓存集进行一定数量的访问，称为保护距离（PD）。该策略保护缓存线足够长，可以重复使用，但不能超过该长度，以避免缓存污染。这可以与旁路机制相结合，该机制也依赖于动态重用分析，以绕过预期重用较少的管线。如果没有未保护的行，则忽略未命中提取。提出了一种基于动态重用历史的命中率模型，并动态计算了使命中率最大的PD。PD会定期重新计算，以跟踪程序的内存访问行为和阶段。</li></ul><h2 id="Optimum-Caching-versus-LRU-and-LFU-Comparison-and-Combined-Limited-Look-Ahead-Strategies"><a href="#Optimum-Caching-versus-LRU-and-LFU-Comparison-and-Combined-Limited-Look-Ahead-Strategies" class="headerlink" title="Optimum Caching versus LRU and LFU: Comparison and Combined Limited Look-Ahead Strategies"></a>Optimum Caching versus LRU and LFU: Comparison and Combined Limited Look-Ahead Strategies</h2><ul><li>将基于最近最少使用（LRU）和最不频繁使用（LFU）替换原则的web缓存策略与根据Belady算法的最佳缓存进行比较。研究了一种结合LRU、LFU或其他非预测方法的有限前瞻最优策略的组合方法。、通过模拟，根据请求跟踪和独立参考模型（IRM）的前瞻性程度来评估命中率增益，并对观察到的行为进行分析确认。</li><li>将常用缓存策略的命中率和更新工作量与最佳缓存作为性能上限进行比较。缓存策略性能评估的三种基本方法是通过跟踪模拟、根据综合模型模拟运行生成的请求模式和分析。</li><li>对一种组合缓存方法的评估表明，优化缓存不仅可以提供缓存命中率上限，而且可以部分用于视频流的缓存和服务于巨大请求工作负载的缓存。对缓存和请求特定参数对有限前瞻方案适用性的影响进行更详细的分析，以供将来研究。</li></ul><h2 id="A-Distributed-Block-Storage-Optimization-Mechanism-Based-on-Ceph"><a href="#A-Distributed-Block-Storage-Optimization-Mechanism-Based-on-Ceph" class="headerlink" title="A Distributed Block Storage Optimization Mechanism Based on Ceph"></a>A Distributed Block Storage Optimization Mechanism Based on Ceph</h2><ul><li>为了应对企业在提高块存储服务的资源利用率和读&#x2F;写速率方面面临的挑战，Ceph提供了缓存分层，以提高异构存储环境中的群集性能。然而，由于缓存污染，缓存分层中最近最少使用的（LRU）算法会驱逐更多有价值的数据，这会导致某些请求的延迟更高；同时，当在存储节点上分配数据时，可扩展哈希下的受控复制（CRUSH）算法只考虑存储节点容量，这使得Ceph无法动态平衡节点的I&#x2F;O负载。为了解决这些问题，提出了一种基于预测模型的存储选择策略，以提高缓存池中对象访问的命中率，提高集群的整体I&#x2F;O性能；此外，还提出了缓存池I&#x2F;O负载平衡策略。与原生机制相比，所提出的块存储优化机制可以实现更高的I&#x2F;O吞吐量和更均衡的I&#x2F;O负载。</li><li>当数据在缓存层被逐出时，缓存分层中的LRU算法仅基于最近的访问记录逐出数据，这可能会由于偶尔的冷数据访问而导致逐出更有价值的热数据[3]。基于Ceph的缓存分层机制，论文提出了一种基于预测模型的存储选择策略，该策略根据对象访问频率确定对象请求是访问SSD OSD池还是访问后端HDD OSD池。该策略可以减少冷数据处理所造成的不必要开销，从而提高集群的总体I&#x2F;O性能。</li><li>为了有效利用缓存分层中有限的缓存池资源，冷数据应该存储在后端存储池中，而热数据应该存储到缓存池中。因此，在海量数据存储的背景下，区分数据的热量（即访问频率）并采用不同的处理策略可以充分利用Cache Tiering中的存储资源，并减少冷数据处理（例如冷数据从后端存储池进入缓存池，LRU驱逐冷数据）所造成的不必要开销。提出了一种基于预测模型的存储选择策略。该策略适应海量数据存储的特点，分析存储对象的长期访问记录。同时，根据某一时间段内的对象热度，判断是选择访问SSD缓存池还是后端HDD存储池，以减少冷数据处理带来的不必要开销，最终提高集群性能。</li></ul><h2 id="Maximizing-Cache-Performance-Under-Uncertainty（提出EVA）2017-HPCA"><a href="#Maximizing-Cache-Performance-Under-Uncertainty（提出EVA）2017-HPCA" class="headerlink" title="Maximizing Cache Performance Under Uncertainty（提出EVA）2017 HPCA"></a>Maximizing Cache Performance Under Uncertainty（提出EVA）2017 HPCA</h2><ul><li>指出Belady理论假设了对未来的完全了解，但这在实践中是不可用的，其明显在信息不完善的情况下是次优的。并建议：对于实际的缓存替换，应该根据其经济增加值（即其预期命中率与平均值的差异）来替代。缓存替换中的两个主要权衡：命中概率和缓存空间，并描述了EVA如何在一个直观的度量中协调它们。通过借鉴马尔可夫决策过程（MDP）理论，证明了EVA最大化了缓存命中率。</li><li>最常见的缓存替换策略是使用最近性和频率启发式。大多数缓存替换策略采用某种形式的最近性，有利于最近被引用的候选人：例如，LRU仅使用最近性，而RRIP[17，39]预测较老的候选人需要更长的时间才能被引用。类似地，一些不假设最近的政策仍然基于候选人最后被引用的时间：PDP[14]保护候选人直到某个年龄；IRGD[35]使用年龄的启发式函数。另一种常见的缓存替换策略解释动态行为的方式是通过频率，倾向于先前重用的候选：例如，LFU单独使用频率，ARC[26]和SRRIP[17]等“抗扫描”策略倾向于至少重用一次的候选。</li><li>EVA缓存替换策略：本质上是一种成本效益分析，即候选数据的命中概率是否值得其所消耗的缓存空间。EVA将每个候选数据选视为一项投资，试图留住利润最高的候选候选（以命中率衡量）。首先，EVA奖励每个候选数据预期的未来命中率。然后，由于缓存空间是一种稀缺资源，EVA需要考虑每个候选将消耗多少空间。EVA通过对每个候选数据在缓存中花费的时间“收费”来实现这一点。具体而言，EVA以单行的平均命中率（即缓存的命中率除以其大小）对候选项收费，因为这是消耗缓存空间的长期机会成本。<br>EVA &#x3D; Expected hits - (Cache hit rate&#x2F; Cache size) * Expected time</li><li>EVA策略的实现主要包括以下几个步骤：<ol><li>计算每个缓存行的经济增值（EVA）：EVA是一个衡量缓存行价值的指标，它考虑了缓存行的命中概率和占用缓存空间的时间成本。具体地，EVA等于缓存行的期望命中次数减去缓存的命中率乘以缓存行在缓存中的时间。 </li><li>选择EVA最小的缓存行进行替换：当需要替换缓存行时，EVA策略会选择EVA最小的缓存行进行替换。这是因为EVA最小的缓存行对缓存的贡献最小，替换它可以最大化缓存的命中率。</li><li>更新缓存行的EVA值：当缓存行被访问时，EVA策略会更新它的EVA值。具体地，EVA策略会根据缓存行的命中情况和占用缓存空间的时间，重新计算缓存行的EVA值。 </li><li>调整缓存大小：EVA策略还可以根据缓存的命中率和缓存行的EVA值，动态调整缓存的大小。具体地，当缓存的命中率较低时，EVA策略会增加缓存的大小；当缓存的命中率较高时，EVA策略会减小缓存的大小。 EVA策略的实现比较简单，只需要对每个缓存行维护一个EVA值，并选择EVA最小的缓存行进行替换即可。</li></ol></li></ul><h2 id="LHD-Improving-Cache-Hit-Rate-by-Maximizing-Hit-Density-2018-NSDI"><a href="#LHD-Improving-Cache-Hit-Rate-by-Maximizing-Hit-Density-2018-NSDI" class="headerlink" title="LHD: Improving Cache Hit Rate by Maximizing Hit Density  2018 NSDI"></a>LHD: Improving Cache Hit Rate by Maximizing Hit Density  2018 NSDI</h2><ul><li>云应用程序的性能严重依赖于数据中心键值缓存的命中率。键值缓存通常使用最近最少使用（LRU）作为其逐出策略，但在实际工作负载下，LRU的命中率远不是最佳的。论文提出最小命中密度（LHD）缓存替换算法，这是一种针对键值缓存的新驱逐策略。LHD预测每个对象每消耗空间的预期命中率（命中密度），过滤对缓存命中率贡献不大的对象。与先前的驱逐策略不同，LHD不依赖启发式，而是使用条件概率严格地模拟对象的行为，以实时调整其行为。</li><li>缓存命中率的小幅增加会对应用程序性能产生巨大影响。例如，将命中率从98%提高到99%，只需1%，就可以将对数据库的请求数量减半。使用上面使用的延迟数，这将平均服务时间从210µs减少到110µs（接近2倍），并且对于云应用程序来说，重要的是，将长延迟请求的尾部减半[21]。为了提高缓存命中率，云提供商通常会扩展服务器数量，从而增加缓存总容量[37]。从长远来看，添加缓存容量是不可行的，因为命中率随着缓存容量的增加呈对数增长[3，13，20]。需要大量内存才能显著影响命中率。在一定的缓存空间条件下，可以采用高效的缓存替换策略来提高缓存命中率。</li><li>流行的内存缓存使用最近最少使用（LRU）或LRU的变体作为其逐出策略。然而，LRU远不是缓存工作负载的最佳选择，因为：当工作负载具有可变的对象大小时，LRU的性能会受到影响，以及常见的访问模式暴露了LRU中的病态，导致命中率低。LRU的这些缺点已经得到了充分的记录，先前的工作已经提出了许多针对LRU的驱逐政策[4，14，16，25，35，38，40]。然而，这些策略并没有被广泛采用，因为它们通常需要大量的参数调整，这使得它们的性能不可靠，并且全局同步状态会影响它们的请求吞吐量。</li><li>论文提出命中密度的概念，用它衡量对象对缓存命中率的贡献程度。根据每个对象的信息（其年龄或大小）推断出每个对象的命中密度，然后以最小的命中密度（LHD）驱逐该对象。最小命中密度（LHD）是一种基于命中密度的缓存替换策略。LHD在线监控对象，并使用条件概率预测其可能的行为。LHD利用了许多不同的对象特性（例如，年龄、频率、应用程序id和大小），并且很容易支持其他对象。动态排名使LHD能够随时间调整其替换策略，以适应不同的应用程序工作负载，而无需任何手动调整。例如，在某个工作负载上，LHD可能最初接近LRU，然后切换到最近使用的（MRU）、最不频繁使用的（LFU）或其组合。LHD动态预测每个对象每消耗空间的预期命中率或命中密度，并以最低的命中率驱逐对象。通过过滤掉对缓存命中率贡献不大的对象，LHD逐渐提高了平均命中率。</li><li>根据Memcachier[36]提供的为期一周的商业memcached跟踪和Microsoft Research提供的存储跟踪对LHD进行了评估[48]。LHD显著提高了先前策略的命中率，例如，与LRU相比，将未命中率减少了一半，与最近的策略相比，减少了四分之一，并且还避免了诸如影响先前策略的性能悬崖等问题。图1显示了实现与LHD相同命中率所需的缓存大小，Memcachier上为256 MB，Microsoft跟踪上为64 GB。LHD需要的空间比以前的驱逐策略少得多，从而节省了现代数据中心数千台服务器的成本。</li><li>先前的缓存替换策略以许多不同的方式改进了LRU。几乎所有的政策都通过额外的机制来改善其最坏的病理状况。例如，ARC[35]使用两个LRU列表来区分新进入的对象，并限制来自不常访问对象的污染。类似地，AdaptSize[9]在LRU列表前面添加了一个概率过滤器，以限制大型物体的污染。最近的一些策略将访问划分为多个LRU列表，以消除性能悬崖[6，18，51]或在不同大小的对象之间分配空间[10，17，18，37，41，43，49]。所有这些策略都使用LRU列表作为核心机制，因此保留了最近性作为内置假设。此外，他们增加的机制可以引入新的假设和病理。例如，ARC通过将频繁访问的对象与新允许的对象放在一个单独的LRU列表中，并倾向于驱逐新允许的物体，从而假设频繁访问的物体更有价值。这通常是LRU的改进，但可能表现为病态。</li><li>EVA，一种最近针对处理器缓存的驱逐策略[7，8]，引入了使用条件概率来平衡命中与消耗的资源的想法。LHD和EVA之间有几个显著的差异，使LHD能够在关键价值工作负载上表现出色。首先，LHD和EVA使用不同的排名功能。EVA根据对象的命中率（而不是命中密度）对其进行排名。</li><li>LHD算法的实现过程如下：<ol><li>首先，需要为每个对象计算其期望的命中率。这可以通过以下公式计算： Hit density &#x3D; Hit probability * Object size &#x2F; Expected time in cache 其中，Hit probability是对象在其生命周期内被访问的概率，Object size是对象的大小，Expected time in cache是对象在缓存中的期望时间。在LHD算法中，Expected time in cache是通过对象的访问模式和缓存的大小等因素来计算的。具体地，可以使用以下公式计算对象的Expected time in cache： Expected time in cache &#x3D; (Cache size &#x2F; Object size) * (1 &#x2F; Hit probability) 其中，Cache size是缓存的大小，Object size是对象的大小，Hit probability是对象在其生命周期内被访问的概率。这个公式的意思是，如果缓存中有足够的空间来存储对象，那么对象在缓存中的期望时间就是对象被访问的平均间隔时间的倒数。这个期望时间可以用来计算对象的期望命中率，从而帮助LHD算法更好地预测对象的命中率。</li><li>然后，需要为每个对象维护一个命中率分布。这可以通过记录对象的命中和驱逐时间来实现。当对象被命中时，将其命中时间添加到命中率分布中。当对象被驱逐时，将其驱逐时间添加到驱逐率分布中。 </li><li>当需要驱逐一个对象时，LHD算法会选择命中率分布最小的对象进行驱逐。这可以通过计算每个对象的命中率分布的加权平均值来实现。具体地，对于每个对象，将其命中率分布的每个时间点乘以其命中率，然后将所有时间点的乘积相加，得到该对象的加权平均命中率。然后，选择加权平均命中率最小的对象进行驱逐。</li><li>在实现过程中，还可以使用其他技术来优化LHD算法的性能。例如，可以使用分类来改进预测，以便更好地考虑对象的特征。还可以使用并发技术来提高算法的吞吐量。 总之，LHD算法的实现过程包括计算对象的期望命中率，维护命中率分布，选择命中率分布最小的对象进行驱逐等步骤。通过这些步骤，LHD算法可以更好地预测对象的命中率，从而提高缓存</li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TDC-Pool-level-object-cache-replacement-algorithm-based-on-temperature-density&quot;&gt;&lt;a href=&quot;#TDC-Pool-level-object-cache-replacement-al</summary>
      
    
    
    
    <category term="云存储" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E5%AD%98%E5%82%A8/"/>
    
    <category term="存储基础" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E5%AD%98%E5%82%A8/%E5%AD%98%E5%82%A8%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="云存储" scheme="https://watsonlu6.github.io/tags/%E4%BA%91%E5%AD%98%E5%82%A8/"/>
    
    <category term="存储基础" scheme="https://watsonlu6.github.io/tags/%E5%AD%98%E5%82%A8%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
