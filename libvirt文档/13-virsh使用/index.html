<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>13 virsh使用 | watson Lu&#39;blogs</title>
  <meta name="description" content="原文链接：https:&#x2F;&#x2F;www.libvirt.org&#x2F;manpages&#x2F;virsh.html 1 概述virsh [选项]… [命令字符串]virsh [选项]… 命令 [参数]… 2 描述virsh 程序是用于管理 virsh 客户域的主要接口。该程序可用于创建、暂停和关闭域，还可以用于列出当前域。Libvirt 是一个 C 工具包，用于与 Linux（及其他操作系统）最新版本的虚拟化功能交">
<meta property="og:type" content="article">
<meta property="og:title" content="13 virsh使用">
<meta property="og:url" content="https://watsonlu6.github.io/libvirt%E6%96%87%E6%A1%A3/13-virsh%E4%BD%BF%E7%94%A8/index.html">
<meta property="og:site_name" content="watson&#39;blogs">
<meta property="og:description" content="原文链接：https:&#x2F;&#x2F;www.libvirt.org&#x2F;manpages&#x2F;virsh.html 1 概述virsh [选项]… [命令字符串]virsh [选项]… 命令 [参数]… 2 描述virsh 程序是用于管理 virsh 客户域的主要接口。该程序可用于创建、暂停和关闭域，还可以用于列出当前域。Libvirt 是一个 C 工具包，用于与 Linux（及其他操作系统）最新版本的虚拟化功能交">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-04-01T07:50:26.000Z">
<meta property="article:modified_time" content="2025-04-29T14:32:00.485Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="云计算">
<meta property="article:tag" content="libvirt">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="https://watsonlu6.github.io/libvirt%E6%96%87%E6%A1%A3/13-virsh%E4%BD%BF%E7%94%A8/index.html">
  
    <link rel="alternate" href="/atom.xml" title="watson&#39;blogs" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 7.3.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/watsonLu6/" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">watson</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Cloud computing development engineer</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> BeiJing, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/watsonLu6/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA%E7%94%9F%E6%B4%BB/">个人生活</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%91%E5%AD%98%E5%82%A8/">云存储</a><span class="category-list-count">29</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%91%E5%AD%98%E5%82%A8/Ceph/">Ceph</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%91%E5%AD%98%E5%82%A8/%E5%AD%98%E5%82%A8%E5%9F%BA%E7%A1%80/">存储基础</a><span class="category-list-count">5</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</a><span class="category-list-count">13</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/libvirt/">libvirt</a><span class="category-list-count">13</span></li></ul></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ceph/" rel="tag">Ceph</a><span class="tag-list-count">24</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/libvirt/" rel="tag">libvirt</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AA%E4%BA%BA%E7%94%9F%E6%B4%BB/" rel="tag">个人生活</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%91%E5%AD%98%E5%82%A8/" rel="tag">云存储</a><span class="tag-list-count">29</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/" rel="tag">云计算</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%98%E5%82%A8%E5%9F%BA%E7%A1%80/" rel="tag">存储基础</a><span class="tag-list-count">5</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/Ceph/" style="font-size: 13.75px;">Ceph</a> <a href="/tags/libvirt/" style="font-size: 13.5px;">libvirt</a> <a href="/tags/%E4%B8%AA%E4%BA%BA%E7%94%9F%E6%B4%BB/" style="font-size: 13px;">个人生活</a> <a href="/tags/%E4%BA%91%E5%AD%98%E5%82%A8/" style="font-size: 14px;">云存储</a> <a href="/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/" style="font-size: 13.5px;">云计算</a> <a href="/tags/%E5%AD%98%E5%82%A8%E5%9F%BA%E7%A1%80/" style="font-size: 13.25px;">存储基础</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">四月 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">三月 2024</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a><span class="archive-list-count">5</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/libvirt/">libvirt</a>
              </p>
              <p class="item-title">
                <a href="/libvirt%E6%96%87%E6%A1%A3/13-virsh%E4%BD%BF%E7%94%A8/" class="title">13 virsh使用</a>
              </p>
              <p class="item-date">
                <time datetime="2024-04-01T07:50:26.000Z" itemprop="datePublished">2024-04-01</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/libvirt/">libvirt</a>
              </p>
              <p class="item-title">
                <a href="/libvirt%E6%96%87%E6%A1%A3/12-libvirt%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/" class="title">12 libvirt使用示例</a>
              </p>
              <p class="item-date">
                <time datetime="2024-03-12T07:50:26.000Z" itemprop="datePublished">2024-03-12</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/libvirt/">libvirt</a>
              </p>
              <p class="item-title">
                <a href="/libvirt%E6%96%87%E6%A1%A3/11-libvirt%E8%B0%83%E8%AF%95%E4%B8%8E%E6%97%A5%E5%BF%97/" class="title">11 libvirt调试与日志</a>
              </p>
              <p class="item-date">
                <time datetime="2024-03-11T07:50:26.000Z" itemprop="datePublished">2024-03-11</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/libvirt/">libvirt</a>
              </p>
              <p class="item-title">
                <a href="/libvirt%E6%96%87%E6%A1%A3/10-libvirt%E5%AE%89%E5%85%A8%E6%A8%A1%E5%BC%8F/" class="title">10 libvirt安全模式</a>
              </p>
              <p class="item-date">
                <time datetime="2024-03-10T07:50:26.000Z" itemprop="datePublished">2024-03-10</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/libvirt/">libvirt</a>
              </p>
              <p class="item-title">
                <a href="/libvirt%E6%96%87%E6%A1%A3/9-libvirt%E4%BA%8B%E4%BB%B6%E5%92%8C%E8%AE%A1%E6%97%B6%E5%99%A8%E5%A4%84%E7%90%86/" class="title">9 libvirt事件和计时器处理</a>
              </p>
              <p class="item-date">
                <time datetime="2024-03-09T07:50:26.000Z" itemprop="datePublished">2024-03-09</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-libvirt文档/13-virsh使用" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      13 virsh使用
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/libvirt%E6%96%87%E6%A1%A3/13-virsh%E4%BD%BF%E7%94%A8/" class="article-date">
	  <time datetime="2024-04-01T07:50:26.000Z" itemprop="datePublished">2024-04-01</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</a>►<a class="article-category-link" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/libvirt/">libvirt</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/libvirt/" rel="tag">libvirt</a>, <a class="article-tag-link-link" href="/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/" rel="tag">云计算</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/libvirt%E6%96%87%E6%A1%A3/13-virsh%E4%BD%BF%E7%94%A8/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <p>原文链接：<a target="_blank" rel="noopener" href="https://www.libvirt.org/manpages/virsh.html">https://www.libvirt.org/manpages/virsh.html</a></p>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 <strong>概述</strong></h1><p>virsh [<em>选项</em>]… [<em>命令字符串</em>]<br>virsh [<em>选项</em>]… <em>命令</em> [<em>参数</em>]…</p>
<h1 id="2-描述"><a href="#2-描述" class="headerlink" title="2 描述"></a>2 <strong>描述</strong></h1><p>virsh 程序是用于管理 virsh 客户域的主要接口。该程序可用于创建、暂停和关闭域，还可以用于列出当前域。Libvirt 是一个 C 工具包，用于与 Linux（及其他操作系统）最新版本的虚拟化功能交互。它是在 GNU 宽通用公共许可证下可用的免费软件。Linux 操作系统的虚拟化意味着能够在单个硬件系统上同时运行多个操作系统实例，其中基本资源由 Linux 实例驱动。该库旨在提供长期稳定的 C API。目前支持 Xen、QEMU、KVM、LXC、OpenVZ、VirtualBox 和 VMware ESX。</p>
<p>大多数 virsh 使用的基本结构如下：</p>
<p>virsh [<em>选项</em>]… &lt;*命令*&gt; &lt;*域*&gt; [<em>参数</em>]…</p>
<p>其中，<em>命令</em> 是下面列出的命令之一；<em>域</em> 是数字域 ID、域名或域 UUID；<em>参数</em> 是特定于命令的选项。少数例外情况是命令作用于所有域、整个机器或直接作用于 Xen 虚拟机管理程序时。这些例外情况将在相关命令中明确说明。注意：可以为域指定数字名称，但这样做会导致域只能通过域 ID 识别。换句话说，如果提供数字值，它将被解释为域 ID，而不是名称。任何以 # 开头的 <em>命令</em> 将被视为注释并静默忽略，所有其他无法识别的 <em>命令</em> 将被诊断。</p>
<p>virsh 程序可以通过在 shell 命令行中提供命令及其参数来运行单个 <em>命令</em>，也可以通过 <em>命令字符串</em> 运行，<em>命令字符串</em> 是一个由多个 <em>命令</em> 操作及其参数组成的单个 shell 参数，命令之间用空格分隔，并用分号或换行符分隔，其中未引用的反斜杠换行对将被省略。在 <em>命令字符串</em> 中，virsh 理解与 shell 相同的单引号、双引号和反斜杠转义，但在创建单个 shell 参数时必须添加另一层 shell 转义，任何以未引用的 <em>#</em> 开头的单词将开始一个注释，直到换行符结束。如果在命令行中未给出命令，virsh 将启动一个最小的解释器等待输入命令，然后使用 quit 命令退出程序。</p>
<p>virsh 程序支持以下 <em>选项</em>。</p>
<p>-c, --connect <em>URI</em><br>连接到指定的 <em>URI</em>，类似于 connect 命令，而不是默认连接。</p>
<p>-d, --debug <em>级别</em><br>启用整数 <em>级别</em> 及更高级别的调试消息。<em>级别</em> 范围为 0 到 4（默认值）。有关每个 <em>级别</em> 的描述，请参阅下面 VIRSH_DEBUG 环境变量的文档。</p>
<p>-e, --escape <em>字符串</em><br>为 <em>console</em> 命令设置替代转义序列。默认使用 telnet 的 ^]。使用脱字符表示法时允许的字符为：字母字符、@、[、]、\、^、_。</p>
<p>-h, --help<br>忽略所有其他参数，并表现得像给出了 help 命令一样。</p>
<p>-k, --keepalive-interval <em>间隔</em><br>设置发送保活消息的 <em>间隔</em>（以秒为单位），以检查与服务器的连接是否仍然存活。将间隔设置为 0 会禁用客户端保活机制。</p>
<p>-K, --keepalive-count <em>计数</em><br>设置在服务器未响应的情况下可以发送保活消息的次数，而不会将连接标记为死亡。如果 <em>间隔</em> 设置为 0，则此设置无效。</p>
<p>-l, --log <em>文件</em><br>将日志详细信息输出到 <em>文件</em>。</p>
<p>-q, --quiet<br>避免额外的信息性消息。</p>
<p>-r, --readonly<br>使初始连接为只读，类似于 connect 命令的 <em>--readonly</em> 选项。</p>
<p>-t, --timing<br>输出每个命令的耗时信息。</p>
<p>-v, --version[&#x3D;short]<br>忽略所有其他参数，并打印 virsh 所使用的 libvirt 库的版本。</p>
<p>-V, --version&#x3D;long<br>忽略所有其他参数，并打印 virsh 所使用的 libvirt 库的版本以及编译的选项和驱动程序。</p>
<h1 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3 注意事项"></a>3 <strong>注意事项</strong></h1><p>大多数 virsh 操作依赖于 libvirt 库能够连接到已运行的 libvirtd 服务。通常可以使用命令 <code>service libvirtd start</code> 完成此操作。</p>
<p>由于与虚拟机管理程序通信所使用的通道，大多数 virsh 命令需要 root 权限才能运行。以非 root 用户身份运行将返回错误。</p>
<p>大多数 virsh 命令是同步执行的，除了 shutdown、setvcpus 和 setmem 等少数命令。在这些情况下，virsh 程序返回并不意味着操作已完成，必须定期轮询以检测客户机是否已完成操作。</p>
<p>virsh 致力于向后兼容。尽管 help 命令仅列出命令的首选用法，但如果旧版本的 virsh 支持命令或选项的替代拼写（例如 <em>--tunnelled</em> 而不是 <em>--tunneled</em>），则使用旧拼写的脚本将继续有效。</p>
<p>一些 virsh 命令接受可选的带单位的整数；如果未提供单位，则命令中会列出默认单位（出于历史原因，某些命令默认为字节，而其他命令默认为千字节）。以下不区分大小写的后缀可用于选择特定单位：</p>
<p>b, byte 字节 1<br>KB 千字节 1,000<br>k, KiB 千二进制字节 1,024<br>MB 兆字节 1,000,000<br>M, MiB 兆二进制字节 1,048,576<br>GB 吉字节 1,000,000,000<br>G, GiB 吉二进制字节 1,073,741,824<br>TB 太字节 1,000,000,000,000<br>T, TiB 太二进制字节 1,099,511,627,776<br>PB 拍字节 1,000,000,000,000,000<br>P, PiB 拍二进制字节 1,125,899,906,842,624<br>EB 艾字节 1,000,000,000,000,000,000<br>E, EiB 艾二进制字节 1,152,921,504,606,846,976</p>
<h1 id="4-通用命令"><a href="#4-通用命令" class="headerlink" title="4 通用命令"></a>4 <strong>通用命令</strong></h1><p>以下命令是通用的，即不特定于某个域。<br><strong>help</strong><br><strong>语法：</strong><br>help [命令或分组]<br>此命令列出每个 virsh 命令。不带选项使用时，所有命令将按相关类别分组显示，每行一个命令，并显示每个分组的关键字。<br>要仅显示特定分组的命令，请将该分组的关键字作为选项。例如：</p>
<p><strong>示例 1：</strong></p>
<p>virsh # help host</p>
<p>主机和虚拟机管理程序（帮助关键字 ‘host’）:</p>
<p>capabilities              显示功能<br>cpu-models                显示架构的 CPU 型号<br>connect                   连接到虚拟机管理程序<br>freecell                  NUMA 空闲内存<br>hostname                  打印虚拟机管理程序主机名<br>qemu-attach               附加到现有 QEMU 进程<br>qemu-monitor-command      QEMU 监视器命令<br>qemu-agent-command        QEMU 客户机代理命令<br>sysinfo                   打印虚拟机管理程序系统信息<br>uri                       打印虚拟机管理程序规范 URI  </p>
<p>要显示特定命令的详细信息，请将其名称作为选项。例如：</p>
<p><strong>示例 2：</strong><br>virsh # help list<br>名称<br>list - 列出域<br>概要<br>list [–inactive] [–all]  </p>
<p>描述<br>返回域列表。  </p>
<p>选项<br>–inactive  列出非活动域<br>–all       列出非活动和活动域</p>
<hr>
<p><strong>quit, exit</strong><br><strong>语法：</strong><br>quit<br>exit<br>退出交互式终端。 </p>
<hr>
<p><strong>version</strong><br><strong>语法：</strong><br>version [–daemon]<br>打印此构建的主要版本信息。如果指定 <em>–daemon</em>，则输出中会包含 libvirt 守护程序的版本。  </p>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ virsh version  </span><br><span class="line">Compiled against library: libvirt 1.2.3  </span><br><span class="line">Using library: libvirt 1.2.3  </span><br><span class="line">Using API: QEMU 1.2.3  </span><br><span class="line">Running hypervisor: QEMU 2.0.50  </span><br><span class="line"></span><br><span class="line">$ virsh version --daemon  </span><br><span class="line">Compiled against library: libvirt 1.2.3  </span><br><span class="line">Using library: libvirt 1.2.3  </span><br><span class="line">Using API: QEMU 1.2.3  </span><br><span class="line">Running hypervisor: QEMU 2.0.50  </span><br><span class="line">Running against daemon: 1.2.6</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>cd</strong><br><strong>语法：</strong><br>cd [目录]<br>将当前目录更改为 <em>目录</em>。cd 命令的默认目录是主目录，如果环境中没有 <em>HOME</em> 变量，则为根目录。  </p>
<hr>
<p><strong>pwd</strong><br><strong>语法：</strong><br>pwd<br>打印当前目录。  </p>
<hr>
<p><strong>connect</strong><br><strong>语法：</strong><br>connect [URI] [–readonly]<br>连接到虚拟机管理程序。当 shell 首次启动时，此命令会自动运行，并使用命令行中 -c 选项请求的 <em>URI</em> 参数。<em>URI</em> 参数指定如何连接到虚拟机管理程序。URI 文档 <a target="_blank" rel="noopener" href="https://libvirt.org/uri.html">https://libvirt.org/uri.html</a> 列出了支持的值，但最常见的有：  </p>
<ul>
<li>xen:&#x2F;&#x2F;&#x2F;system<br>用于连接到本地 Xen 虚拟机管理程序。  </li>
<li>qemu:&#x2F;&#x2F;&#x2F;system<br>以 root 身份连接到本地监督 QEMU 和 KVM 域的守护程序。  </li>
<li>qemu:&#x2F;&#x2F;&#x2F;session<br>以普通用户身份连接到其自己的 QEMU 和 KVM 域集。  </li>
<li>lxc:&#x2F;&#x2F;&#x2F;system<br>连接到本地 Linux 容器。<br>要查找当前使用的 URI，请查看下面记录的 <em>uri</em> 命令。</li>
</ul>
<p>对于远程访问，请参阅 URI 文档 <a target="_blank" rel="noopener" href="https://libvirt.org/uri.html">https://libvirt.org/uri.html</a> 了解如何创建 URI。*–readonly* 选项允许只读连接。  </p>
<hr>
<p><strong>uri</strong><br><strong>语法：</strong><br>uri<br>打印虚拟机管理程序的规范 URI，在 shell 模式下可能有用。  </p>
<hr>
<p><strong>hostname</strong><br><strong>语法：</strong><br>hostname<br>打印虚拟机管理程序的主机名。  </p>
<hr>
<p><strong>sysinfo</strong><br><strong>语法：</strong><br>sysinfo<br>打印虚拟机管理程序的 XML 表示的系统信息（如果可用）。  </p>
<hr>
<p><strong>nodeinfo</strong><br><strong>语法：</strong><br>nodeinfo<br>返回有关节点的基本信息，例如 CPU 的数量和类型，以及物理内存的大小。<br>强烈不建议使用此命令，因为提供的信息不能保证在所有硬件平台上都准确。<br><em>CPU 频率</em> 值仅反映机器中第一个 CPU 当前的运行速度。此速度可能因 CPU 而异，并且会随着主机操作系统调整而变化。<br>用于获取数据的数据结构不可扩展，因此仅支持全局节点&#x2F;插槽&#x2F;核心&#x2F;线程（插槽&#x2F;核心&#x2F;线程是每个 NUMA 节点）拓扑信息。如果主机 CPU 有任何进一步的分组（例如 die、集群等）或 NUMA 拓扑不对称，则数据结构无法真实表示系统。在这种情况下，将报告一个伪造的拓扑（节点 &#x3D; 1，插槽 &#x3D; 1，核心 &#x3D; 主机 CPU 数量，线程 &#x3D; 1），仅正确表示主机 CPU 总数。<br>建议使用 <em>capabilities</em> 命令替代，该命令在 &#x2F;capabilities&#x2F;host&#x2F;topology XPath 下报告数据（频率除外）。  </p>
<hr>
<p><strong>nodecpumap</strong><br><strong>语法：</strong><br>nodecpumap [–pretty]<br>显示节点的 CPU 总数、在线 CPU 数量以及在线 CPU 列表。<br>使用 <em>–pretty</em> 时，在线 CPU 将以范围形式打印，而不是列表形式。  </p>
<hr>
<p><strong>nodecpustats</strong><br><strong>语法：</strong><br>nodecpustats [CPU] [–percent]<br>返回节点的 CPU 统计信息。如果指定 <em>CPU</em>，则仅打印指定 CPU 的统计信息。如果指定 <em>–percent</em>，则打印每种 CPU 统计信息在 1 秒内的百分比。  </p>
<hr>
<p><strong>nodememstats</strong><br><strong>语法：</strong><br>nodememstats [单元]<br>返回节点的内存统计信息。如果指定 <em>单元</em>，则仅打印指定单元的统计信息。  </p>
<hr>
<p><strong>nodesevinfo</strong><br><strong>语法：</strong><br>nodesevinfo<br>报告有关节点的 AMD SEV 启动安全功能的信息（如果有）。其中一些信息也会在域功能 XML 文档中报告。  </p>
<hr>
<p><strong>nodesuspend</strong><br><strong>语法：</strong><br>nodesuspend [目标] [持续时间]<br>将节点（主机）置于系统范围的睡眠状态，并安排节点的实时时钟中断在指定的 <em>持续时间</em> 后恢复节点。<em>目标</em> 指定主机将挂起到的状态，可以是 “mem”（挂起到 RAM）、”disk”（挂起到磁盘）或 “hybrid”（挂起到 RAM 和磁盘）。<em>持续时间</em> 指定主机挂起的时间（以秒为单位），应至少为 60 秒。  </p>
<hr>
<p><strong>node-memory-tune</strong><br><strong>语法：</strong><br>node-memory-tune [shm-pages-to-scan] [shm-sleep-millisecs] [shm-merge-across-nodes]<br>允许显示或设置节点内存参数。<em>shm-pages-to-scan</em> 可用于设置共享内存服务在休眠前扫描的页数；<em>shm-sleep-millisecs</em> 可用于设置共享内存服务在下一次扫描前休眠的毫秒数；<em>shm-merge-across-nodes</em> 指定是否可以从不同的 NUMA 节点合并页。设置为 0 时，仅可以合并物理位于同一 NUMA 节点内存区域的页。设置为 1 时，可以合并所有节点的页。默认为 1。<br>注意：当前“共享内存服务”仅指 KSM（内核同页合并）。  </p>
<hr>
<p><strong>capabilities</strong><br><strong>语法：</strong><br>capabilities [–xpath 表达式] [–wrap]<br>打印描述当前连接的虚拟机管理程序功能的 XML 文档。这包括主机在 CPU 和功能方面的能力部分，以及每种可以虚拟化的客户机的描述集。更完整的描述请参阅：<br><a target="_blank" rel="noopener" href="https://libvirt.org/formatcaps.html">https://libvirt.org/formatcaps.html</a><br>XML 还显示 NUMA 拓扑信息（如果可用）。<br>如果 <strong>–xpath</strong> 参数提供 XPath 表达式，则将对输出 XML 求值，并仅打印匹配的节点。默认行为是将每个匹配节点打印为独立文档，但为了方便进一步处理，**–wrap** 参数会将匹配节点包装在公共根节点中。  </p>
<hr>
<p><strong>domcapabilities</strong><br><strong>语法：</strong><br>domcapabilities [virttype] [emulatorbin] [arch] [machine]<br>[–xpath 表达式] [–wrap]<br>[–disable-deprecated-features]<br>打印描述当前连接的虚拟机管理程序域功能的 XML 文档，这些信息可以来自现有域或 virsh capabilities 输出。如果您打算创建新域并想知道它是否可以通过为特定模拟器和架构创建域来使用 VFIO，这可能很有用。<br>每个虚拟机管理程序对哪些选项是必需的、哪些是可选的会有不同的要求。虚拟机管理程序可以支持为任何选项提供默认值。  </p>
<p><em>virttype</em> 选项指定使用的虚拟化类型。该值可以来自域 XML 中 &lt;domain&#x2F;&gt; 顶级元素的 ‘type’ 属性，也可以来自 virsh capabilities 输出中每个 &lt;guest&#x2F;&gt; 元素的 ‘type’ 属性。<em>emulatorbin</em> 选项指定模拟器的路径。该值可以来自域 XML 中的 &lt;emulator&gt; 元素或 virsh capabilities 输出。<em>arch</em> 选项指定用于域的架构。该值可以来自域 XML 中 &lt;os&#x2F;&gt; 元素和 &lt;type&#x2F;&gt; 子元素的 “arch” 属性，也可以来自 virsh capabilities 输出中 &lt;arch&#x2F;&gt; 元素的 “name” 属性。<em>machine</em> 指定模拟器的机器类型。该值可以来自域 XML 中 &lt;os&#x2F;&gt; 元素和 &lt;type&#x2F;&gt; 子元素的 “machine” 属性，也可以来自 virsh capabilities 输出中特定架构和域类型的机器列表。  </p>
<p>对于 QEMU 虚拟机管理程序，必须提供 <em>virttype</em> 为 ‘qemu’ 或 ‘kvm’ 以及 <em>emulatorbin</em> 或 <em>arch</em> 才能为默认 <em>machine</em> 生成输出。提供 <em>machine</em> 值将为特定机器生成输出。  </p>
<p>如果 <strong>–xpath</strong> 参数提供 XPath 表达式，则将对输出 XML 求值，并仅打印匹配的节点。默认行为是将每个匹配节点打印为独立文档，但为了方便进一步处理，**–wrap** 参数会将匹配节点包装在公共根节点中。<br><strong>–disable-deprecated-features</strong> 参数将修改 host-model CPU XML 的内容，更新功能列表，其中包含虚拟机管理程序标记为已弃用的 CPU 模型的任何功能。这些功能将与 “disable” 策略配对。  </p>
<hr>
<p><strong>pool-capabilities</strong><br><strong>语法：</strong><br>pool-capabilities<br>打印描述连接的存储驱动程序存储池功能的 XML 文档。如果您打算创建新存储池并需要了解可用的池类型、支持的存储池源和目标卷格式以及创建池所需的源元素，这可能很有用。  </p>
<hr>
<p><strong>inject-nmi</strong><br><strong>语法：</strong><br>inject-nmi 域<br>向客户机注入 NMI。  </p>
<hr>
<p><strong>list</strong><br><strong>语法：</strong><br>list [–inactive | –all]<br>[–managed-save] [–title]<br>{ [–table] | –name | –id } [–uuid]<br>[–persistent] [–transient]<br>[–with-managed-save] [–without-managed-save]<br>[–autostart] [–no-autostart]<br>[–with-snapshot] [–without-snapshot]<br>[–with-checkpoint] [–without-checkpoint]<br>[–state-running] [–state-paused]<br>[–state-shutoff] [–state-other]<br>打印有关现有域的信息。如果未指定选项，则打印有关运行域的信息。  </p>
<p><strong>示例 1：</strong><br>列表的示例格式如下：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">virsh list  </span><br><span class="line"></span><br><span class="line">Id   名称       状态  </span><br><span class="line">----------------------------------  </span><br><span class="line">0    Domain-0   running  </span><br><span class="line">2    fedora     paused</span><br></pre></td></tr></table></figure>
<p>名称是域的名称。ID 是域的数字 ID。状态是运行状态（见下文）。  </p>
<p><strong>状态</strong><br>状态字段列出每个域当前的状态。域可以处于以下可能的状态之一：  </p>
<ul>
<li>running<br>域当前正在 CPU 上运行。  </li>
<li>idle<br>域处于空闲状态，未运行或不可运行。这可能是由于域正在等待 I&#x2F;O（传统等待状态）或因为没有其他事情可做而进入睡眠状态。  </li>
<li>paused<br>域已暂停，通常是由于管理员运行 virsh suspend。在暂停状态下，域仍会消耗分配的资源（如内存），但没有资格由虚拟机管理程序调度。  </li>
<li>in shutdown<br>域正在关闭过程中，即客户操作系统已收到通知并应正在优雅地停止其操作。  </li>
<li>shut off<br>域未运行。通常这表示域已完全关闭或尚未启动。  </li>
<li>crashed<br>域已崩溃，这始终是暴力结束。通常只有在域配置为崩溃时不重启时才会出现此状态。  </li>
<li>pmsuspended<br>域已由客户电源管理暂停，例如进入 s3 状态。</li>
</ul>
<p>通常仅列出活动域。要列出非活动域，请指定 <em>–inactive</em> 或 <em>–all</em> 以同时列出活动和非活动域。  </p>
<p><strong>过滤</strong><br>要进一步过滤域列表，可以指定 list 命令支持的一个或多个过滤标志。这些标志按功能分组。从组中指定一个或多个标志会启用过滤组。注意，某些标志组合可能不会产生任何结果。支持的过滤标志和组：<br>–persistent<br>标志 <em>–persistent</em> 用于在返回的列表中包括持久客户机。要包括临时客户机，请指定 <em>–transient</em>。<br>–with-managed-save<br>要列出具有托管保存映像的域，请指定标志 <em>–with-managed-save</em>。对于没有托管保存映像的域，请指定 <em>–without-managed-save</em>。<br>–state-running<br>以下过滤标志按状态选择域：*–state-running* 用于运行域，*–state-paused* 用于暂停域，*–state-shutoff* 用于关闭域，*–state-other* 用于所有其他状态作为后备。<br>–autostart<br>要列出自动启动域，请使用标志 <em>–autostart</em>。要列出禁用此功能的域，请使用 <em>–no-autostart</em>。<br>–with-snapshot<br>可以使用标志 <em>–with-snapshot</em> 列出具有快照映像的域，使用 <em>–without-snapshot</em> 列出没有快照的域。<br>–with-checkpoint<br>可以使用标志 <em>–with-checkpoint</em> 列出具有检查点的域，使用 <em>–without-checkpoint</em> 列出没有检查点的域。  </p>
<p>在与旧服务器通信时，此命令被迫使用一系列具有固有竞争的 API 调用，如果在收集列表时域状态在调用之间更改，则可能不会列出域或域可能多次出现。新服务器没有此问题。  </p>
<p>如果指定 <em>–managed-save</em>，则具有托管保存状态（仅在域处于关闭状态时可能，因此需要指定 <em>–inactive</em> 或 <em>–all</em> 才能实际列出它们）的域将在列表中显示为已保存。此标志仅可与默认 <em>–table</em> 输出一起使用。注意，此标志不会过滤域列表。  </p>
<p>如果指定 <em>–name</em>，则打印域名而不是表格格式，每行一个。如果指定 <em>–uuid</em>，则打印域的 UUID 而不是名称。如果指定 <em>–id</em>，则打印域的 ID 而不是名称。但是，可以组合 <em>–name</em>、*–uuid* 和 <em>–id</em> 以仅选择要打印的所需字段。标志 <em>–table</em> 指定应使用传统的表格格式输出，但它与 <em>–name</em> 和 <em>–id</em> 互斥。这是默认值，如果未指定 <em>–name</em>、*–uuid* 或 <em>–id</em>，则将使用它。如果未指定 <em>–name</em> 或 <em>–uuid</em>，但指定了 <em>–id</em>，则仅列出活动域，即使使用 <em>–all</em> 参数，否则输出将仅包含一堆仅包含 <em>-1</em> 的行。如果 <em>–table</em> 与 <em>–uuid</em> 组合，则域 UUID 将作为额外列打印。  </p>
<p>如果指定 <em>–title</em>，则会在额外列中打印域的简短描述（标题）。此标志仅可与默认 <em>–table</em> 输出一起使用。  </p>
<p><strong>示例 2：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">virsh list --title  </span><br><span class="line"></span><br><span class="line">Id   名称       状态    标题  </span><br><span class="line">----------------------------------  </span><br><span class="line">0    Domain-0   running Mailserver 1  </span><br><span class="line">2    fedora     paused  </span><br></pre></td></tr></table></figure>

<hr>
<p><strong>freecell</strong><br><strong>语法：</strong><br>freecell [{ [–cellno] 单元号 | –all }]<br>打印机器或 NUMA 单元中的可用内存量。freecell 命令可以根据指定的选项提供三种不同的机器可用内存显示之一。不带选项时，显示机器上的总空闲内存。使用 –all 选项时，显示每个单元的空闲内存和机器上的总空闲内存。最后，使用数字参数或 –cellno 加单元号时，将仅显示指定单元的空闲内存。  </p>
<hr>
<p><strong>freepages</strong><br><strong>语法：</strong><br>freepages [{ [–cellno] 单元号 [–pagesize] 页大小 | –all }]<br>打印 NUMA 单元中的可用页数。<em>单元号</em> 指您感兴趣的 NUMA 单元。<em>页大小</em> 是一个带单位的整数（参见上面的 NOTES）。或者，如果使用 <em>–all</em>，则打印每个可能的 NUMA 单元和页大小组合的信息。  </p>
<hr>
<p><strong>allocpages</strong><br><strong>语法：</strong><br>allocpages [–pagesize] 页大小 [–pagecount] 页数 [ [–cellno] 单元号] [–add] [–all]<br>更改主机上 <em>页大小</em> 的页池大小。如果指定 <em>–add</em>，则将 <em>页数</em> 页添加到池中。但是，如果未指定 <em>–add</em>，则 <em>页数</em> 将作为池的新绝对大小（这可用于释放一些页并缩小池）。<em>单元号</em> 修饰符可用于将修改范围缩小到单个主机 NUMA 单元。在范围的另一端是 <em>–all</em>，它将在所有 NUMA 单元上执行修改。  </p>
<hr>
<p><strong>cpu-baseline</strong><br><strong>语法：</strong><br>cpu-baseline 文件 [–features] [–migratable]<br>计算基线 CPU，该 CPU 将由 &lt;文件&gt; 中给出的所有主机 CPU 支持。（参见 hypervisor-cpu-baseline 命令以获取可由特定虚拟机管理程序提供的 CPU。）主机 CPU 列表是通过从 &lt;文件&gt; 中提取所有 &lt;cpu&gt; 元素构建的。因此，&lt;文件&gt; 可以包含由换行符分隔的一组 &lt;cpu&gt; 元素，甚至可以包含 capabilities 命令打印的一组完整的 &lt;capabilities&gt; 元素。如果指定 <em>–features</em>，则生成的 XML 描述将显式包括构成 CPU 的所有功能，没有此选项时，属于 CPU 模型的功能将不会在 XML 描述中列出。如果指定 <em>–migratable</em>，则阻止迁移的功能将不会包含在生成的 CPU 中。  </p>
<hr>
<p><strong>cpu-compare</strong><br><strong>语法：</strong><br>cpu-compare 文件 [–error] [–validate]<br>将 XML &lt;文件&gt; 中的 CPU 定义与主机 CPU 进行比较。（参见 hypervisor-cpu-compare 命令以将 CPU 定义与特定虚拟机管理程序在主机上能够提供的 CPU 进行比较。）XML &lt;文件&gt; 可以包含主机或客户机 CPU 定义。主机 CPU 定义是 capabilities 命令打印的 &lt;cpu&gt; 元素及其内容。客户机 CPU 定义是域 XML 定义中的 &lt;cpu&gt; 元素及其内容，或从域功能 XML（由 domcapabilities 命令打印）中找到的主机 CPU 模型创建的 CPU 定义。除了 &lt;cpu&gt; 元素本身外，此命令还接受包含 CPU 定义的完整域 XML、capabilities XML 或域功能 XML。有关客户机 CPU 定义的更多信息，请参阅：<a target="_blank" rel="noopener" href="https://libvirt.org/formatdomain.html#elementsCPU">https://libvirt.org/formatdomain.html#elementsCPU</a><br>如果指定 <em>–error</em>，则当给定 CPU 与主机 CPU 不兼容时，命令将返回错误，并打印提供有关不兼容性更多详细信息的消息。如果指定 <em>–validate</em>，则根据内部 RNG 模式验证 XML 文档的格式。  </p>
<hr>
<p><strong>cpu-models</strong><br><strong>语法：</strong><br>cpu-models 架构<br>打印 libvirt 为指定架构已知的 CPU 模型列表。特定虚拟机管理程序是否能够创建使用任何打印的 CPU 模型的域是一个单独的问题，可以通过查看 domcapabilities 命令返回的域功能 XML 来回答。此外，对于某些架构，libvirt 不知道任何 CPU 模型，可用的 CPU 模型仅受虚拟机管理程序的限制。对于这些架构，此命令将打印所有 CPU 模型都被接受，实际支持的 CPU 模型列表可以在域功能 XML 中检查。  </p>
<hr>
<p><strong>hypervisor-cpu-compare</strong><br><strong>语法：</strong><br>hypervisor-cpu-compare 文件 [virttype] [emulator] [arch] [machine] [–error] [–validate]<br>将 XML &lt;文件&gt; 中的 CPU 定义与虚拟机管理程序在主机上能够提供的 CPU 进行比较。（这与 cpu-compare 不同，后者在不考虑任何特定虚拟机管理程序及其能力的情况下将 CPU 定义与主机 CPU 进行比较。）  </p>
<p>XML <em>文件</em> 应包含客户机 CPU 定义：域 XML 定义中的 &lt;cpu&gt; 元素及其内容，或从域功能 XML（由 domcapabilities 命令打印）中的 &lt;mode name&#x3D;”host-model”&gt; 元素创建的主机 CPU 模型创建的 CPU 定义。域功能 XML 中的 &lt;mode name&#x3D;”host-model”&gt; 元素本身或其 &lt;cpu&gt; 父元素不被接受。必须将元素转换为实际的 CPU 定义。有关客户机 CPU 定义的更多信息，请参阅：  <a target="_blank" rel="noopener" href="https://libvirt.org/formatdomain.html#elementsCPU">https://libvirt.org/formatdomain.html#elementsCPU</a><br>或者，此命令在提供完整域或域功能 XML 时将自动提取 CPU 定义。  </p>
<p>出于历史原因，XML <em>文件</em> 也可以包含主机 CPU 定义，但强烈不建议这种用法，因为它很可能会提供不正确的结果。  </p>
<p><em>virttype</em> 选项指定虚拟化类型（可在域 XML 中 &lt;domain&gt; 顶级元素的 ‘type’ 属性中使用）。<em>emulator</em> 指定模拟器的路径，<em>arch</em> 指定 CPU 架构，<em>machine</em> 指定机器类型。如果指定 <em>–error</em>，则当给定 CPU 与主机 CPU 不兼容时，命令将返回错误，并打印提供有关不兼容性更多详细信息的消息。如果指定 <em>–validate</em>，则根据内部 RNG 模式验证 XML 文档的格式。  </p>
<hr>
<p><strong>hypervisor-cpu-baseline</strong><br><strong>语法：</strong><br>hypervisor-cpu-baseline [文件] [virttype] [emulator] [arch] [machine]<br>[–features] [–migratable] [模型]  </p>
<p>计算基线 CPU，该 CPU 将与 XML <em>文件</em> 中定义的所有 CPU 以及虚拟机管理程序在主机上能够提供的 CPU 兼容。（这与 cpu-baseline 不同，后者在计算基线 CPU 时不考虑任何虚拟机管理程序的能力。）<br>作为 <em>文件</em> 的替代方案，如果 XML 仅包含没有附加功能的 CPU 模型，则可以将 CPU 模型名称本身作为 <em>模型</em> 传递。必须使用 <em>文件</em> 和 <em>模型</em> 中的一个。  </p>
<p>XML <em>文件</em> 应包含从域功能 XML（在每个主机上由 domcapabilities 命令打印）中的 &lt;mode name&#x3D;”host-model”&gt; 元素创建的主机 CPU 模型创建的客户机 CPU 定义。域功能 XML 中的 &lt;mode name&#x3D;”host-model”&gt; 元素本身或其 &lt;cpu&gt; 父元素不被接受。必须将元素转换为实际的 CPU 定义。  </p>
<p>或者，此命令在提供域功能 XML 时将自动提取 CPU 定义。  </p>
<p>出于历史原因，XML <em>文件</em> 也可以包含主机 CPU 定义，但强烈不建议这种用法，因为它很可能会提供不正确的结果。  </p>
<p>当 <em>文件</em> 仅包含单个 CPU 定义时，命令将打印相同的 CPU，并附加虚拟机管理程序能力施加的限制。具体来说，在没有其他选项的情况下运行 virsh hypervisor-cpu-baseline 命令对 virsh domcapabilities 的结果进行操作，将域功能 XML 中的主机 CPU 模型转换为可直接在域 XML 中使用的形式。运行带有 <em>模型</em>（或仅包含模型且没有功能元素的单个 CPU 定义的 <em>文件</em>）的命令，该模型在 virsh domcapabilities 中被标记为不可用，将提供阻止此 CPU 模型可用的功能列表。  </p>
<p><em>virttype</em> 选项指定虚拟化类型（可在域 XML 中 &lt;domain&gt; 顶级元素的 ‘type’ 属性中使用）。<em>emulator</em> 指定模拟器的路径，<em>arch</em> 指定 CPU 架构，<em>machine</em> 指定机器类型。如果指定 <em>–features</em>，则生成的 XML 描述将显式包括构成 CPU 的所有功能，没有此选项时，属于 CPU 模型的功能将不会在 XML 描述中列出。如果指定 <em>–migratable</em>，则阻止迁移的功能将不会包含在生成的 CPU 中。  </p>
<hr>
<p><strong>hypervisor-cpu-models</strong><br><strong>语法：</strong><br>hypervisor-cpu-models [–virttype virttype] [–emulator emulator]<br>[–arch arch] [–machine machine] [–all]  </p>
<p>打印虚拟机管理程序为指定架构已知的 CPU 模型列表。不能保证列出的 CPU 将在主机上运行。要确定 CPU 模型与主机的兼容性，请参阅 virsh hypervisor-cpu-baseline 和 virsh hypervisor-cpu-compare。  </p>
<p><em>virttype</em> 选项指定虚拟化类型（可在域 XML 中 &lt;domain&gt; 顶级元素的 ‘type’ 属性中使用）。<em>emulator</em> 指定模拟器的路径，<em>arch</em> 指定 CPU 架构，<em>machine</em> 指定机器类型。  </p>
<p>默认情况下，仅报告虚拟机管理程序在主机上声称“可用”的模型。选项 <em>–all</em> 将报告虚拟机管理程序已知的每个 CPU 模型，包括不受支持的模型（例如新一代模型）。</p>
<hr>
<h1 id="5-域命令"><a href="#5-域命令" class="headerlink" title="5 域命令"></a>5 <strong>域命令</strong></h1><p>以下命令直接操作域，如前所述，大多数命令将域作为第一个参数。<em>域</em>可以指定为短整数、名称或完整的UUID。<br><strong>autostart</strong><br><strong>语法：</strong><br>autostart [–disable] 域<br>配置域在启动时自动启动。<br>选项 <em>–disable</em> 禁用自动启动。</p>
<hr>
<p><strong>blkdeviotune</strong><br><strong>语法：</strong><br>blkdeviotune 域 设备 [ [–config] [–live] | [–current]]<br>[[total-bytes-sec] | [read-bytes-sec] [write-bytes-sec]]<br>[[total-iops-sec] | [read-iops-sec] [write-iops-sec]]<br>[[total-bytes-sec-max] | [read-bytes-sec-max] [write-bytes-sec-max]]<br>[[total-iops-sec-max] | [read-iops-sec-max] [write-iops-sec-max]]<br>[[total-bytes-sec-max-length] | [read-bytes-sec-max-length] [write-bytes-sec-max-length]]<br>[[total-iops-sec-max-length] | [read-iops-sec-max-length] [write-iops-sec-max-length]]<br>[size-iops-sec] [group-name]</p>
<p>设置或查询域块设备的IO参数。<em>设备</em>指定域中附加的磁盘设备的唯一目标名称（&lt;target dev&#x3D;’name’&#x2F;&gt;）或源文件（&lt;source file&#x3D;’name’&#x2F;&gt;）（参见domblklist列出这些名称）。</p>
<p>如果未指定限制，则查询当前IO限制设置。否则，使用以下标志更改限制：*–total-bytes-sec* 指定总吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–read-bytes-sec* 指定读取吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–write-bytes-sec* 指定写入吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–total-iops-sec* 指定每秒总IO操作限制。*–read-iops-sec* 指定每秒读取IO操作限制。*–write-iops-sec* 指定每秒写入IO操作限制。*–total-bytes-sec-max* 指定最大总吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–read-bytes-sec-max* 指定最大读取吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–write-bytes-sec-max* 指定最大写入吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–total-iops-sec-max* 指定每秒最大总IO操作限制。*–read-iops-sec-max* 指定每秒最大读取IO操作限制。*–write-iops-sec-max* 指定每秒最大写入IO操作限制。*–total-bytes-sec-max-length* 指定允许最大总吞吐量限制的持续时间（秒）。*–read-bytes-sec-max-length* 指定允许最大读取吞吐量限制的持续时间（秒）。*–write-bytes-sec-max-length* 指定允许最大写入吞吐量限制的持续时间（秒）。*–total-iops-sec-max-length* 指定允许最大总IO操作限制的持续时间（秒）。*–read-iops-sec-max-length* 指定允许最大读取IO操作限制的持续时间（秒）。*–write-iops-sec-max-length* 指定允许最大写入IO操作限制的持续时间（秒）。*–size-iops-sec* 指定每秒大小IO操作限制。*–group-name* 指定在多个驱动器之间共享IO配额的组名。对于QEMU域，如果未提供名称，则默认为每个<em>设备</em>有一个单独的组。</p>
<p>旧版本的virsh仅接受下划线而非连字符的选项，例如*–total_bytes_sec*。</p>
<p>字节和IOPS值是独立的，但仅设置一个值（例如–read-bytes-sec）会将该类别中的其他两个值重置为无限制。显式的0也会清除任何限制。对于给定的总值的非零值不能与读取或写入的非零值混合使用。</p>
<p>长度值的处理方式由管理程序决定。对于QEMU管理程序，如果设置了IO限制值或最大值，则默认显示1秒的值。提供0将值重置回默认值。</p>
<p>如果指定*–live<em>，则影响正在运行的客户机。如果指定</em>–config<em>，则影响持久客户机的下一次启动。如果指定</em>–current<em>，则根据客户机的当前状态等效于</em>–live<em>或</em>–config<em>。设置磁盘IO参数时，可以同时指定</em>–live<em>和</em>–config<em>标志，但</em>–current<em>是互斥的。查询时只能指定</em>–live<em>、</em>–config<em>或</em>–current*中的一个。如果未指定标志，行为因管理程序而异。</p>
<hr>
<p><strong>domthrottlegroupset</strong><br><strong>语法：</strong><br>domthrottlegroupset 域 组名 [ [–config] [–live] | [–current]]<br>[[total-bytes-sec] | [read-bytes-sec] [write-bytes-sec]]<br>[[total-iops-sec] | [read-iops-sec] [write-iops-sec]]<br>[[total-bytes-sec-max] | [read-bytes-sec-max] [write-bytes-sec-max]]<br>[[total-iops-sec-max] | [read-iops-sec-max] [write-iops-sec-max]]<br>[[total-bytes-sec-max-length] | [read-bytes-sec-max-length] [write-bytes-sec-max-length]]<br>[[total-iops-sec-max-length] | [read-iops-sec-max-length] [write-iops-sec-max-length]]<br>[size-iops-sec]</p>
<p>添加或更新特定域的节流组。<em>组名</em>指定唯一的节流组名称，定义限制，并将被驱动器引用。</p>
<p>如果未指定限制，则默认为全零，这将失败。否则，使用以下标志设置限制：*–total-bytes-sec* 指定总吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–read-bytes-sec* 指定读取吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–write-bytes-sec* 指定写入吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–total-iops-sec* 指定每秒总IO操作限制。*–read-iops-sec* 指定每秒读取IO操作限制。*–write-iops-sec* 指定每秒写入IO操作限制。*–total-bytes-sec-max* 指定最大总吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–read-bytes-sec-max* 指定最大读取吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–write-bytes-sec-max* 指定最大写入吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–total-iops-sec-max* 指定每秒最大总IO操作限制。*–read-iops-sec-max* 指定每秒最大读取IO操作限制。*–write-iops-sec-max* 指定每秒最大写入IO操作限制。*–total-bytes-sec-max-length* 指定允许最大总吞吐量限制的持续时间（秒）。*–read-bytes-sec-max-length* 指定允许最大读取吞吐量限制的持续时间（秒）。*–write-bytes-sec-max-length* 指定允许最大写入吞吐量限制的持续时间（秒）。*–total-iops-sec-max-length* 指定允许最大总IO操作限制的持续时间（秒）。*–read-iops-sec-max-length* 指定允许最大读取IO操作限制的持续时间（秒）。*–write-iops-sec-max-length* 指定允许最大写入IO操作限制的持续时间（秒）。*–size-iops-sec* 指定每秒大小IO操作限制。</p>
<p>字节和IOPS值是独立的，但仅设置一个值（例如–read-bytes-sec）会将该类别中的其他两个值重置为无限制。显式的0也会清除任何限制。对于给定的总值的非零值不能与读取或写入的非零值混合使用。</p>
<p>长度值的处理方式由管理程序决定。对于QEMU管理程序，如果设置了IO限制值或最大值，则默认显示1秒的值。提供0将值重置回默认值。</p>
<p>如果指定*–live<em>，则影响正在运行的客户机。如果指定</em>–config<em>，则影响持久客户机的下一次启动。如果指定</em>–current<em>，则根据客户机的当前状态等效于</em>–live<em>或</em>–config<em>。设置磁盘IO参数时，可以同时指定</em>–live<em>和</em>–config<em>标志，但</em>–current*是互斥的。如果未指定标志，行为因管理程序而异。</p>
<hr>
<p><strong>domthrottlegroupdel</strong><br><strong>语法：</strong><br>domthrottlegroupdel 域 组名 [ [–config] [–live] | [–current]]</p>
<p>使用指定的<em>组名</em>从域中删除节流组。如果节流组当前被磁盘资源引用，则尝试删除节流组将失败。如果<em>组名</em>不存在，将发生错误。</p>
<p>如果指定*–live<em>，则影响正在运行的客户机。如果客户机未运行，则返回错误。如果指定</em>–config<em>，则影响持久客户机的下一次启动。如果指定</em>–current<em>，则根据客户机的当前状态等效于</em>–live<em>或</em>–config*。</p>
<hr>
<p><strong>domthrottlegroupinfo</strong><br><strong>语法：</strong><br>domthrottlegroupinfo 域 组名 [ [–config] [–live] | [–current]]</p>
<p>显示域节流组信息，包括IO限制设置。</p>
<p>如果指定*–live<em>，则从正在运行的客户机获取节流组数据。如果客户机未运行，则返回错误。如果指定</em>–config<em>，则从持久客户机的下一次启动获取节流组数据。如果指定</em>–current<em>或未指定</em>–live<em>和</em>–config<em>，则根据客户机的当前状态获取节流组数据，可以是活动或离线状态。如果同时指定</em>–live<em>和</em>–config<em>，则</em>–config*选项优先获取当前描述。</p>
<hr>
<p><strong>domthrottlegrouplist</strong><br><strong>语法：</strong><br>domthrottlegrouplist 域 [–inactive]<br>打印显示与域关联的所有节流组名称的表格。如果指定*–inactive*，则查询将在下次启动时使用的节流组数据，而不是当前正在使用的域。</p>
<hr>
<p><strong>blkiotune</strong><br><strong>语法：</strong><br>blkiotune 域 [–weight 权重] [–device-weights 设备权重]<br>[–device-read-iops-sec 设备读取IOPS]<br>[–device-write-iops-sec 设备写入IOPS]<br>[–device-read-bytes-sec 设备读取字节]<br>[–device-write-bytes-sec 设备写入字节]<br>[ [–config] [–live] | [–current]]</p>
<p>显示或设置块IO参数。QEMU&#x2F;KVM支持*–weight<em>。</em>–weight*范围为[100, 1000]。在内核2.6.39之后，该值可以在[10, 1000]范围内。</p>
<p>设备权重是一个字符串，列出一个或多个设备&#x2F;权重对，格式为&#x2F;路径&#x2F;到&#x2F;设备,权重,&#x2F;路径&#x2F;到&#x2F;设备,权重。每个权重在[100, 1000]范围内，内核2.6.39之后为[10, 1000]，或值为0以从每设备列表中删除该设备。仅修改字符串中列出的设备；其他设备的现有每设备权重保持不变。</p>
<p>设备读取IOPS是一个字符串，列出一个或多个设备&#x2F;读取IOPS对，格式为&#x2F;路径&#x2F;到&#x2F;设备,读取IOPS,&#x2F;路径&#x2F;到&#x2F;设备,读取IOPS。每个读取IOPS是一个无符号整数，值为0以从每设备列表中删除该设备。仅修改字符串中列出的设备；其他设备的现有每设备读取IOPS保持不变。</p>
<p>设备写入IOPS是一个字符串，列出一个或多个设备&#x2F;写入IOPS对，格式为&#x2F;路径&#x2F;到&#x2F;设备,写入IOPS,&#x2F;路径&#x2F;到&#x2F;设备,写入IOPS。每个写入IOPS是一个无符号整数，值为0以从每设备列表中删除该设备。仅修改字符串中列出的设备；其他设备的现有每设备写入IOPS保持不变。</p>
<p>设备读取字节是一个字符串，列出一个或多个设备&#x2F;读取字节对，格式为&#x2F;路径&#x2F;到&#x2F;设备,读取字节,&#x2F;路径&#x2F;到&#x2F;设备,读取字节。每个读取字节是一个无符号长整型，值为0以从每设备列表中删除该设备。仅修改字符串中列出的设备；其他设备的现有每设备读取字节保持不变。</p>
<p>设备写入字节是一个字符串，列出一个或多个设备&#x2F;写入字节对，格式为&#x2F;路径&#x2F;到&#x2F;设备,写入字节,&#x2F;路径&#x2F;到&#x2F;设备,写入字节。每个写入字节是一个无符号长整型，值为0以从每设备列表中删除该设备。仅修改字符串中列出的设备；其他设备的现有每设备写入字节保持不变。</p>
<p>如果指定*–live<em>，则影响正在运行的客户机。如果指定</em>–config<em>，则影响持久客户机的下一次启动。如果指定</em>–current<em>，则根据客户机的当前状态等效于</em>–live<em>或</em>–config<em>。可以同时指定</em>–live<em>和</em>–config<em>标志，但</em>–current*是互斥的。如果未指定标志，行为因管理程序而异。</p>
<hr>
<p><strong>blockcommit</strong><br><strong>语法：</strong><br>blockcommit 域 路径 [带宽] [–bytes] [基础]<br>[–shallow] [顶部] [–delete] [–keep-relative]<br>[–wait [–async] [–verbose]] [–timeout 秒]<br>[–active] [{–pivot | –keep-overlay}]</p>
<p>通过将链顶部的更改（快照或增量文件）提交到基础映像中，减少基础映像链的长度。默认情况下，此命令尝试展平整个链。如果<em>基础</em>和&#x2F;或<em>顶部</em>指定为链中的文件，则操作仅限于提交该部分链；*–shallow<em>可以代替</em>基础<em>指定要提交的顶部映像的直接基础文件。正在提交的文件将变为无效，可能在操作开始时即如此；使用</em>–delete<em>标志将在成功完成提交操作后尝试删除这些无效文件。使用</em>–keep-relative*标志时，基础文件路径将保持相对路径。</p>
<p>当省略<em>顶部</em>或将其指定为活动映像时，还可以指定*–active<em>以触发两阶段活动提交。在第一阶段，</em>顶部<em>被复制到</em>基础<em>中，作业只能取消，顶部仍包含尚未在基础中的数据。在第二阶段，</em>顶部<em>和</em>基础<em>保持相同，直到调用带有</em>–abort<em>标志的blockjob（保持顶部作为跟踪从该时间点更改的活动映像）或</em>–pivot*标志（使基础成为新的活动映像并使顶部无效）。</p>
<p>默认情况下，此命令尽快返回，整个磁盘的数据在后台提交；可以使用blockjob检查操作进度。但是，如果指定*–wait<em>，则此命令将阻塞，直到操作完成（或对于</em>–active<em>，进入第二阶段），或由于可选的</em>timeout<em>秒超时或发送SIGINT（通常使用Ctrl-C）而取消操作。使用</em>–verbose<em>与</em>–wait<em>将产生定期状态更新。如果触发作业取消，</em>–async<em>将尽快将控制权返回给用户，否则命令可能会继续阻塞一段时间，直到作业完成清理。使用</em>–pivot<em>是结合</em>–active* <em>–wait</em>与自动blockjob <em>–pivot</em>的简写；使用*–keep-overlay<em>是结合</em>–active* <em>–wait</em>与自动blockjob <em>–abort</em>的简写。</p>
<p><em>路径</em>指定磁盘的完全限定路径；它对应于域中附加的磁盘设备的唯一目标名称（&lt;target dev&#x3D;’name’&#x2F;&gt;）或源文件（&lt;source file&#x3D;’name’&#x2F;&gt;）（参见domblklist列出这些名称）。<em>带宽</em>指定复制带宽限制（MiB&#x2F;s），但对于QEMU，仅在线域可能为非零值。有关<em>带宽</em>参数的更多信息，请参见blockjob命令的相应部分。</p>
<hr>
<p><strong>blockcopy</strong><br><strong>语法：</strong><br>blockcopy 域 路径 { 目标 [格式] [–blockdev] | –xml 文件 }<br>[–shallow] [–reuse-external] [带宽]<br>[–wait [–async] [–verbose]] [{–pivot | –finish}]<br>[–timeout 秒] [粒度] [缓冲区大小] [–bytes]<br>[–transient-job] [–synchronous-writes] [–print-xml]<br>将磁盘基础映像链复制到目标。必须存在<em>目标</em>作为目标文件名，或*–xml<em>包含描述目标的顶级&lt;disk&gt;元素的XML文件名。此外，如果给出</em>目标<em>，则应指定</em>格式<em>以声明目标的格式（如果省略</em>格式<em>，则libvirt将重用源的格式，或使用</em>–reuse-external<em>强制探测目标格式，这可能是潜在的安全漏洞）。该命令支持</em>–raw<em>作为</em>–format&#x3D;raw<em>的布尔标志同义词。使用</em>目标<em>时，目标被视为常规文件，除非使用</em>–blockdev<em>表示它是块设备。默认情况下，此命令展平整个链；但如果指定</em>–shallow*，则副本共享基础链。</p>
<p>如果指定*–reuse-external<em>，则目标必须存在并具有足够的空间来保存副本。如果</em>–shallow<em>与</em>–reuse-external*一起使用，则预创建的映像必须具有与原始映像的基础文件相同的客户可见内容。这可以用于修改目标上的基础文件名。</p>
<p>默认情况下，复制作业在后台运行，并分为两个阶段。最初，作业必须从源复制所有数据，在此阶段，作业只能取消以恢复到源磁盘，不保证目标的状态。在此阶段完成后，源和目标保持镜像，直到调用带有*–abort<em>和</em>–pivot<em>标志的blockjob切换到副本，或不带</em>–pivot<em>的调用将目标保留为该时间点的忠实副本。但是，如果指定</em>–wait<em>，则此命令将阻塞，直到镜像阶段开始，或如果可选的</em>timeout<em>秒超时或发送SIGINT（通常使用Ctrl-C）则取消操作。使用</em>–verbose<em>与</em>–wait<em>将产生定期状态更新。使用</em>–pivot<em>（类似于blockjob <em>–pivot</em>）或</em>–finish<em>（类似于blockjob <em>–abort</em>）隐含</em>–wait<em>，并将干净地结束作业，而不是保持在镜像阶段。如果超时或</em>–finish<em>触发作业取消，</em>–async*将尽快将控制权返回给用户，否则命令可能会继续阻塞一段时间，直到作业实际取消。</p>
<p><em>路径</em>指定磁盘的完全限定路径。<em>带宽</em>指定复制带宽限制（MiB&#x2F;s）。指定负值被视为无符号长整型值，可能基本上无限制，但更可能溢出；使用0更安全。有关<em>带宽</em>参数的更多信息，请参见blockjob命令的相应部分。指定<em>粒度</em>允许微调检测到脏区域时要复制的粒度；较大的值触发较少的IO开销，但总体上可能复制更多的数据（默认值通常正确）；管理程序可能限制为2的幂或落在特定范围内。指定<em>缓冲区大小</em>将控制在复制期间可以同时传输的数据量；较大的值使用更多内存，但可能允许更快完成（默认值通常正确）。</p>
<p><em>–transient-job</em>允许指定如果VM在作业完成前崩溃或关闭，用户不需要恢复作业。如果管理程序应用了复制作业对临时域的限制，此标志将删除该限制。</p>
<p>如果指定*–synchronous-writes*，则块作业将等待客户写入传播到原始映像和复制目标，以确保如果目标存储较慢，作业会收敛。这可能会影响块作业运行时的写入性能。</p>
<p>如果指定*–print-xml*，则打印用于启动块复制作业的XML，而不是启动作业。</p>
<hr>
<p><strong>blockjob</strong><br><strong>语法：</strong><br>blockjob 域 路径 { [–abort] [–async] [–pivot] |<br>[–info] [–raw] [–bytes] | [带宽] }<br>管理活动块操作。有三种互斥模式：*–info<em>、</em>带宽<em>和</em>–abort<em>。</em>–async<em>和</em>–pivot<em>隐含中止模式；</em>–raw<em>隐含信息模式；如果未给出模式，则假定为</em>–info*模式。</p>
<p><em>路径</em>指定磁盘的完全限定路径；它对应于域中附加的磁盘设备的唯一目标名称（&lt;target dev&#x3D;’name’&#x2F;&gt;）或源文件（&lt;source file&#x3D;’name’&#x2F;&gt;）（参见domblklist列出这些名称）。</p>
<p>在*–abort<em>模式下，将中止指定磁盘上的活动作业。如果还指定</em>–async<em>，则此命令将立即返回，而不是等待取消完成。如果指定</em>–pivot*，则请求将活动复制或活动提交作业切换到新映像。</p>
<p>在*–info<em>模式下，将打印指定磁盘上的活动作业信息。默认情况下，输出为单个人类可读的摘要行；此格式可能在将来的版本中更改。添加</em>–raw<em>以稳定格式列出结构的每个字段。如果设置</em>–bytes*标志，则如果服务器无法提供字节&#x2F;秒分辨率，则命令将出错；省略标志时，原始输出以MiB&#x2F;s列出，人类可读输出自动选择服务器支持的最佳分辨率。</p>
<p><em>带宽</em>可用于设置活动作业的带宽限制（MiB&#x2F;s）。如果指定*–bytes<em>，则带宽值解释为字节&#x2F;秒。指定负值被视为无符号长整型值或基本上无限制。管理程序可以选择是否拒绝该值或将其转换为允许的最大值。可选地，可以使用缩放正数作为带宽（参见上面的NOTES）。使用</em>–bytes<em>与缩放值允许选择更细的粒度。不带</em>–bytes<em>的缩放值将向下舍入到MiB&#x2F;s。请注意，</em>–bytes*可能不受管理程序支持。</p>
<p>请注意，对应于拉模式备份的块作业报告的进度不是备份的进度，而是备份所需的临时空间的使用情况。</p>
<hr>
<p><strong>blockpull</strong><br><strong>语法：</strong><br>blockpull 域 路径 [带宽] [–bytes] [基础]<br>[–wait [–verbose] [–timeout 秒] [–async]]<br>[–keep-relative]<br>从基础映像链中填充磁盘。默认情况下，此命令展平整个链；但如果指定<em>基础</em>，包含链中基础文件之一的名称，则该文件成为新的基础文件，仅拉取链的中间部分。一旦从基础映像链中拉取了所有请求的数据，磁盘就不再依赖于该部分基础链。</p>
<p>默认情况下，此命令尽快返回，整个磁盘的数据在后台拉取；可以使用blockjob检查操作进度。但是，如果指定*–wait<em>，则此命令将阻塞，直到操作完成，或如果可选的</em>timeout<em>秒超时或发送SIGINT（通常使用Ctrl-C）则取消操作。使用</em>–verbose<em>与</em>–wait<em>将产生定期状态更新。如果触发作业取消，</em>–async*将尽快将控制权返回给用户，否则命令可能会继续阻塞一段时间，直到作业完成清理。</p>
<p>使用*–keep-relative*标志将保持基础链名称的相对性。</p>
<p><em>路径</em>指定磁盘的完全限定路径；它对应于域中附加的磁盘设备的唯一目标名称（&lt;target dev&#x3D;’name’&#x2F;&gt;）或源文件（&lt;source file&#x3D;’name’&#x2F;&gt;）（参见domblklist列出这些名称）。<em>带宽</em>指定复制带宽限制（MiB&#x2F;s）。有关<em>带宽</em>参数的更多信息，请参见blockjob命令的相应部分。</p>
<hr>
<p><strong>blockresize</strong><br><strong>语法：</strong><br>blockresize 域 路径 ([大小] | [–capacity])<br>在域运行时调整块设备的大小。<em>路径</em>指定块设备的绝对路径；它对应于域中附加的磁盘设备的唯一目标名称（&lt;target dev&#x3D;’name’&#x2F;&gt;）或源文件（&lt;source file&#x3D;’name’&#x2F;&gt;）（参见domblklist列出这些名称）。</p>
<p>对于没有元数据的映像格式（原始格式）存储在固定大小的存储（例如块设备）中，可以使用*–capacity*标志将设备调整为基础设备的完整大小。</p>
<p><em>大小</em>是一个缩放整数（参见上面的NOTES），如果没有后缀，则默认为KiB（1024字节的块）。必须使用“B”后缀以获取字节（请注意，由于历史原因，这与vol-resize不同，后者默认不带后缀的字节）。</p>
<hr>
<p><strong>console</strong><br><strong>语法：</strong><br>console 域 [设备名] [–safe] [–force] [–resume]<br>连接到客户机的虚拟串行控制台。可选的<em>设备名</em>参数引用为客户机配置的备用控制台、串行或并行设备的设备别名。如果省略，将打开主控制台。</p>
<p>如果指定*–safe<em>标志，则仅在驱动程序支持安全控制台处理时尝试连接。此标志指定服务器必须确保对控制台设备的独占访问。可选地，可以指定</em>–force*标志，请求断开任何现有会话，例如在连接断开的情况下。</p>
<p>如果指定*–resume*标志，则在连接到控制台后恢复客户机。</p>
<hr>
<p><strong>cpu-stats</strong><br><strong>语法：</strong><br>cpu-stats 域 [–total] [起始] [数量]<br>提供域的CPU统计信息。域应正在运行。默认显示所有CPU的统计信息和总计。使用*–total<em>仅显示总计统计信息，</em>起始<em>仅显示从</em>起始<em>开始的CPU的统计信息，</em>数量<em>仅显示</em>数量*个CPU的统计信息。</p>
<hr>
<p><strong>create</strong><br><strong>语法：</strong><br>create 文件 [–console] [–paused] [–autodestroy]<br>[–pass-fds N,M,…] [–validate] [–reset-nvram]</p>
<p>从XML &lt;文件&gt;创建域。可选地，可以传递*–validate*选项以根据内部RNG模式验证输入XML文件的格式（与使用virt-xml-validate(1)工具相同）。使用此命令创建的域将是临时的（一旦销毁即消失）或现有的持久客户机，将运行一次性使用的配置，保持持久XML不变（这在基于原始XML的各种配置的自动化测试中可能很方便）。请参见下面的示例以了解用法演示。</p>
<p>如果使用*–paused<em>选项且驱动程序支持，则域将被暂停；否则将运行。如果请求</em>–console<em>，则在创建后附加到控制台。如果请求</em>–autodestroy*，则当virsh关闭其与libvirt的连接或以其他方式退出时，客户机将自动销毁。</p>
<p>如果指定*–pass-fds*，则参数是逗号分隔的打开文件描述符列表，这些文件描述符应传递到客户机中。文件描述符将在客户机中重新编号，从3开始。这仅支持基于容器的虚拟化。</p>
<p>如果指定*–reset-nvram*，则任何现有的NVRAM文件将被删除并从其原始模板重新初始化。</p>
<p><strong>示例：</strong></p>
<ol>
<li>从现有域准备模板（如果从头开始编写，则直接跳到3a）<br># virsh dumpxml &lt;域&gt; &gt; 域.xml</li>
<li>使用您选择的编辑器编辑模板：<br> a. 必须更改！&lt;name&gt;和&lt;uuid&gt;（&lt;uuid&gt;也可以删除），或<br> b. 不要更改！&lt;name&gt;或&lt;uuid&gt;<br># $EDITOR 域.xml</li>
<li>从domain.xml创建域，取决于是否遵循2a或2b：<br> a. 域将是临时的<br> b. 现有的持久客户机将使用修改后的一次性配置运行<br># virsh create domain.xml</li>
</ol>
<hr>
<p><strong>define</strong><br><strong>语法：</strong><br>define 文件 [–validate]<br>从XML &lt;文件&gt;定义域。可选地，可以使用*–validate*（与使用virt-xml-validate(1)工具相同）根据内部RNG模式验证输入XML文件的格式。域定义已注册但未启动。如果域已在运行，则更改将在下次启动时生效。</p>
<hr>
<p><strong>desc</strong><br><strong>语法：</strong><br>desc 域 [ [–live] [–config] | [–current]] [–title] [–edit] [–new-desc 新描述或标题消息]</p>
<p>显示或修改域的描述和标题。这些值是允许存储任意文本数据的用户字段，以便轻松识别域。标题应简短，尽管未强制执行。（另请参见适用于基于XML的域元数据的元数据。）</p>
<p>标志*–live<em>或</em>–config<em>选择此命令是作用于域的实时定义还是持久定义。如果同时指定</em>–live<em>和</em>–config<em>，则</em>–config<em>选项优先获取当前描述，并在设置描述时同时更新实时配置和配置。</em>–current*是互斥的，如果未指定这些标志，则隐含。</p>
<p>标志*–edit*指定应打开包含当前描述或标题内容的编辑器，并在之后保存内容。</p>
<p>标志*–title*选择操作标题字段而不是描述。</p>
<p>如果既不指定*–edit<em>也不指定</em>–new-desc*，则显示注释或描述而不是修改。</p>
<hr>
<p><strong>destroy</strong><br><strong>语法：</strong><br>destroy 域 [–graceful] [–remove-logs]<br>立即终止域<em>域</em>。这不会给域操作系统任何反应的机会，相当于物理机器上拔掉电源线。在大多数情况下，您会希望改用shutdown命令。但是，这不会删除客户机使用的任何存储卷，如果域是持久的，则可以稍后重新启动。</p>
<p>如果<em>域</em>是临时的，则一旦客户机停止运行，任何快照的元数据将丢失，但快照内容仍然存在，具有相同名称和UUID的新域可以使用snapshot-create恢复快照元数据。类似地，任何检查点的元数据将丢失，但可以使用checkpoint-create恢复。</p>
<p>如果指定*–graceful*，则在客户机在合理超时后未停止时，不采取极端措施（例如SIGKILL）；而是返回错误。</p>
<p>如果指定*–remove-logs<em>，则删除每个</em>域*的日志文件。并非所有部署配置都受支持。</p>
<p>对于QEMU，仅当使用virlogd处理QEMU进程输出时才支持该标志。否则忽略该标志。</p>
<hr>
<p><strong>domblkerror</strong><br><strong>语法：</strong><br>domblkerror 域<br>显示块设备上的错误。当domstate命令说域由于I&#x2F;O错误而暂停时，此命令通常很有用。domblkerror命令列出所有处于错误状态的块设备以及每个设备上看到的错误。</p>
<hr>
<p><strong>domblkinfo</strong><br><strong>语法：</strong><br>domblkinfo 域 [块设备 –all] [–human]<br>获取域的块设备大小信息。<em>块设备</em>对应于域中附加的磁盘设备的唯一目标名称（&lt;target dev&#x3D;’name’&#x2F;&gt;）或源文件（&lt;source file&#x3D;’name’&#x2F;&gt;）（参见domblklist列出这些名称）。如果指定*–human<em>，则输出将具有人类可读的输出。如果指定</em>–all<em>，则输出将是一个表格，显示与</em>域<em>关联的所有块设备大小信息。</em>–all*选项优先于其他选项。</p>
<hr>
<p><strong>domblklist</strong><br><strong>语法：</strong><br>domblklist 域 [–inactive] [–details]<br>打印一个表格，显示与<em>域</em>关联的所有块设备的简要信息。如果指定*–inactive<em>，则查询将在下次启动时使用的块设备，而不是当前正在使用的域。如果指定</em>–details<em>，还将打印磁盘类型和设备值。其他需要块设备名称的上下文（例如</em>domblkinfo<em>或用于磁盘快照的</em>snapshot-create*）将接受此命令打印的目标或唯一源名称。</p>
<hr>
<p><strong>domblkstat</strong><br><strong>语法：</strong><br>domblkstat 域 [块设备] [–human]<br>获取正在运行的域的块设备统计信息。<em>块设备</em>对应于域中附加的磁盘设备的唯一目标名称（&lt;target dev&#x3D;’name’&#x2F;&gt;）或源文件（&lt;source file&#x3D;’name’&#x2F;&gt;）（参见domblklist列出这些名称）。在LXC或QEMU域上，省略<em>块设备</em>将汇总整个域的块设备统计信息。</p>
<p>使用*–human*以获得更人类可读的输出。</p>
<p>这些字段的可用性取决于管理程序。不支持的字段将从输出中缺失。如果与较新版本的libvirtd通信，可能会出现其他字段。</p>
<p>字段说明（字段按以下顺序出现）：</p>
<ul>
<li>rd_req - 读取操作计数</li>
<li>rd_bytes - 读取字节计数</li>
<li>wr_req - 写入操作计数</li>
<li>wr_bytes - 写入字节计数</li>
<li>errs - 错误计数</li>
<li>flush_operations - 刷新操作计数</li>
<li>rd_total_times - 读取操作花费的总时间（纳秒）</li>
<li>wr_total_times - 写入操作花费的总时间（纳秒）</li>
<li>flush_total_times - 刷新操作花费的总时间（纳秒）</li>
<li>&lt;– 管理程序提供的其他字段 –&gt;</li>
</ul>
<hr>
<p><strong>domblkthreshold</strong><br><strong>语法：</strong><br>domblkthreshold 域 设备 阈值<br>设置传递块阈值事件的阈值值。<em>设备</em>指定磁盘设备目标或使用’target[1]’语法给定设备的支持链元素。<em>阈值</em>是偏移的缩放值。如果块设备应写入超过该偏移，则将传递事件。</p>
<hr>
<p><strong>domcontrol</strong><br><strong>语法：</strong><br>domcontrol 域<br>返回用于控制域的VMM接口状态。对于除“ok”或“error”之外的状态，该命令还打印自控制接口进入其当前状态以来经过的秒数。</p>
<hr>
<p><strong>domdirtyrate-calc</strong><br><strong>语法：</strong><br>domdirtyrate-calc &lt;域&gt; [–seconds &lt;秒&gt;]<br>–mode&#x3D;[page-sampling | dirty-bitmap | dirty-ring]</p>
<p>计算活动域的内存脏页率，用户可能期望以此决定是否适合迁移出去。seconds参数可用于在特定时间计算脏页率，现在最多允许60s，如果缺失则默认为1s。这三种<em>page-sampling、dirty-bitmap、dirty-ring</em>模式在指定计算模式时是互斥且可选的，如果缺失则<em>page-sampling</em>是默认模式。通过调用’domstats –dirtyrate’可以获取计算的脏页率信息。</p>
<hr>
<p><strong>domdisplay</strong><br><strong>语法：</strong><br>domdisplay 域 [–include-password] [ [–type] 类型] [–all]<br>输出可用于通过VNC、SPICE或RDP连接到域的图形显示的URI。可以使用type参数选择特定的图形显示类型（例如“vnc”、“spice”、“rdp”）。如果指定*–include-password<em>，则SPICE通道密码将包含在URI中。如果指定</em>–all*，则显示所有可能的图形显示，因为VM可能有多个图形显示。</p>
<hr>
<p><strong>domdisplay-reload</strong><br><strong>语法：</strong><br>domdisplay-reload &lt;域&gt; [–type &lt;类型&gt;]<br>重新加载域的图形显示。这会重新加载其TLS证书而不重新启动域。type可以是<em>virDomainGraphicsReloadType</em>枚举中的任何常量。默认情况下，重新加载任何支持的类型（目前仅VNC）。</p>
<hr>
<p><strong>domfsfreeze</strong><br><strong>语法：</strong><br>domfsfreeze 域 [ [–mountpoint] 挂载点…]<br>冻结正在运行的域中的已挂载文件系统，以准备一致的快照。</p>
<p><em>–mountpoint</em>选项接受参数挂载点，这是要冻结的文件系统的挂载点路径。此选项可以多次出现。如果未指定此选项，则冻结每个已挂载的文件系统。</p>
<p>注意：snapshot-create命令具有*–quiesce*选项，可以自动冻结和解冻文件系统以保持快照一致。domfsfreeze命令仅在用户希望利用libvirt不支持的存储设备的本地快照功能时才需要。</p>
<hr>
<p><strong>domfsinfo</strong><br><strong>语法：</strong><br>domfsinfo 域<br>显示正在运行的域中已挂载文件系统的列表。该列表包含挂载点、客户机中已挂载设备的名称、文件系统类型和域XML中使用的唯一目标名称（&lt;target dev&#x3D;’name’&#x2F;&gt;）。</p>
<p>注意：此命令需要在域的客户机操作系统中配置并运行客户机代理。</p>
<hr>
<p><strong>domfsthaw</strong><br><strong>语法：</strong><br>domfsthaw 域 [ [–mountpoint] 挂载点…]<br>解冻由domfsfreeze命令冻结的正在运行的域中的已挂载文件系统。<br><em>–mountpoint</em>选项接受参数挂载点，这是要解冻的文件系统的挂载点路径。此选项可以多次出现。如果未指定此选项，则解冻每个已挂载的文件系统。</p>
<hr>
<p><strong>domfstrim</strong><br><strong>语法：</strong><br>domfstrim 域 [–minimum 字节] [–mountpoint 挂载点]<br>在正在运行的域中的所有已挂载文件系统上发出fstrim命令。它丢弃文件系统未使用的块。如果指定*–minimum<em>字节，则告诉客户内核连续空闲范围的长度。小于此值的可能会被忽略（这是一个提示，客户可能不会遵守）。通过增加此值，fstrim操作将更快完成，对于具有严重碎片化空闲空间的文件系统，尽管并非所有块都会被丢弃。默认值为零，表示“丢弃每个空闲块”。此外，如果用户只想修剪一个挂载点，可以通过可选的</em>–mountpoint*参数指定。</p>
<hr>
<p><strong>domhostname</strong><br><strong>语法：</strong><br>domhostname 域 [–source lease|agent]<br>如果管理程序可用，则返回域的主机名。<br><em>–source</em>参数指定用于主机名的数据源，当前为“lease”读取DHCP租约或“agent”通过代理查询客户操作系统。如果未指定，驱动程序返回可用的默认方法（某些驱动程序仅支持一种类型的源）。</p>
<hr>
<p><strong>domid</strong><br><strong>语法：</strong><br>domid 域名或UUID<br>将域名（或UUID）转换为域ID</p>
<hr>
<p><strong>domif-getlink</strong><br><strong>语法：</strong><br>domif-getlink 域 接口设备 [–config]<br>查询域虚拟接口的链接状态。如果指定*–config<em>，则查询持久配置，为了兼容性，</em>–persistent<em>是</em>–config*的别名。<br><em>接口设备</em>可以是接口的目标名称或MAC地址。</p>
<hr>
<p><strong>domif-setlink</strong><br><strong>语法：</strong><br>domif-setlink 域 接口设备 状态 [–config] [–print-xml]<br>修改域虚拟接口的链接状态。状态的可能值为“up”和“down”。如果指定*–config<em>，则仅修改域的持久配置，为了兼容性，</em>–persistent<em>是</em>–config<em>的别名。</em>接口设备<em>可以是接口的目标名称或MAC地址。<br>如果指定</em>–print-xml*，则打印用于更新接口的XML。</p>
<hr>
<p><strong>domifaddr</strong><br><strong>语法：</strong><br>domifaddr 域 [接口] [–full]  [–source lease|agent|arp]<br>获取正在运行的域的接口列表及其IP和MAC地址，或如果指定<em>接口</em>，则仅显示一个接口的有限输出。请注意，<em>接口</em>可能依赖于驱动程序，可以是客户操作系统中的名称或域XML中看到的名称。此外，在某些管理程序（特别是QEMU）下，整个命令可能要求为查询的域配置客户代理。</p>
<p>如果指定*–full*，则当接口有多个IP地址或别名时，始终显示接口名称和MAC地址；否则，仅对第一个名称和MAC地址显示接口名称和MAC地址，其他使用相同名称和MAC地址的显示为“-”。</p>
<p><em>–source</em>参数指定用于地址的数据源，当前为“lease”读取DHCP租约，“agent”通过代理查询客户操作系统，或“arp”从主机的arp表中获取IP。如果未指定，“lease”是默认值。</p>
<hr>
<p><strong>backup-begin</strong><br><strong>语法：</strong><br>backup-begin 域 [backupxml] [checkpointxml] [–reuse-external]<br>开始新的备份作业。如果省略<em>backupxml</em>，则默认为使用libvirt生成的文件名的完整备份；提供XML允许微调，例如请求相对于早期检查点的增量备份，控制哪些磁盘参与或涉及哪些文件名，或请求使用拉模型备份。<em>backup-dumpxml</em>命令显示libvirt分配的任何结果值。有关备份XML的更多信息，请参见：<a target="_blank" rel="noopener" href="https://libvirt.org/formatbackup.html">https://libvirt.org/formatbackup.html</a></p>
<p>如果使用*–reuse-external<em>，则指示libvirt重用用户在</em>backupxml*中提供的临时和输出文件。</p>
<p>如果指定<em>checkpointxml</em>，则使用包含<em>domaincheckpoint</em>顶级元素的第二个文件创建同时检查点，以便在创建备份时进行稍后的增量备份。有关检查点的更多详细信息，请参见<em>checkpoint-create</em>。</p>
<p>此命令尽快返回，备份作业在后台运行；可以使用<em>domjobinfo</em>检查推送模型备份的进度，或使用<em>event</em>等待事件（拉模型备份的进度由连接到NBD导出的任何第三方控制）。使用<em>domjobabort</em>结束作业。</p>
<hr>
<p><strong>backup-dumpxml</strong><br><strong>语法：</strong><br>backup-dumpxml [–xpath 表达式] [–wrap] 域<br>输出描述当前备份作业的XML。<br>如果**–xpath<strong>参数提供XPath表达式，则将对输出XML求值，并仅打印匹配的节点。默认行为是将每个匹配节点打印为独立文档，但是为了便于进一步处理，</strong>–wrap**参数将使匹配节点包装在公共根节点中。</p>
<hr>
<p><strong>domiflist</strong><br><strong>语法：</strong><br>domiflist 域 [–inactive]<br>打印显示与域关联的所有虚拟接口的简要信息的表格。如果指定*–inactive<em>，则查询将在下次启动时使用的虚拟接口，而不是当前正在使用的域。其他需要虚拟接口MAC地址的上下文（例如</em>detach-interface<em>或</em>domif-setlink*）将接受此命令打印的MAC地址。</p>
<hr>
<p><strong>domifstat</strong><br><strong>语法：</strong><br>domifstat 域 接口设备<br>获取正在运行的域的网络接口统计信息。网络接口统计信息仅适用于具有物理源接口的接口。这不包括例如“user”接口类型，因为它是具有NAT到外部世界的虚拟LAN。<em>接口设备</em>可以是接口的目标名称或MAC地址。请注意，对于非托管<em>ethernet</em>类型，返回的统计信息可能交换了RX&#x2F;TX。</p>
<hr>
<p><strong>domiftune</strong><br><strong>语法：</strong><br>domiftune 域 接口设备 [ [–config] [–live] | [–current]]<br>[–inbound 平均,峰值,突发,下限]<br>[–outbound 平均,峰值,突发]</p>
<p>设置或查询域的网络接口的带宽参数。<em>接口设备</em>可以是接口的目标名称（&lt;target dev&#x3D;’name’&#x2F;&gt;）或MAC地址。</p>
<p>如果未指定*–inbound<em>或</em>–outbound<em>，则此命令将查询并显示带宽设置。否则，它将设置入站或出站带宽。</em>平均,峰值,突发,下限<em>与命令</em>attach-interface<em>中的相同。</em>平均<em>、</em>峰值<em>和</em>下限<em>的值以千字节&#x2F;秒表示，而</em>突发<em>以</em>峰值*速度的单次突发中的千字节表示，如网络XML文档中所述：<a target="_blank" rel="noopener" href="https://libvirt.org/formatnetwork.html#quality-of-service%E3%80%82">https://libvirt.org/formatnetwork.html#quality-of-service。</a></p>
<p>要清除入站或出站设置，分别使用*–inbound<em>或</em>–outbound*，平均值为零。</p>
<p>如果指定*–live<em>，则影响正在运行的客户机。如果指定</em>–config<em>，则影响持久客户机的下一次启动。如果指定</em>–current<em>，则根据客户机的当前状态等效于</em>–live<em>或</em>–config<em>。可以同时指定</em>–live<em>和</em>–config<em>标志，但</em>–current*是互斥的。如果未指定标志，行为因管理程序而异。</p>
<hr>
<p><strong>dominfo</strong><br><strong>语法：</strong><br>dominfo 域<br>返回有关域的基本信息。</p>
<hr>
<p><strong>domjobabort</strong><br><strong>语法：</strong><br>domjobabort 域 [–postcopy]<br>中止当前正在运行的域作业。<br>当中止的作业是进入后复制模式的迁移时，由于迁移中涉及的没有一个主机具有域的完整状态，因此无法中止。可选的*–postcopy<em>可用于中断此类迁移，尽管这样做可能会有效地暂停域，直到迁移恢复（另请参见迁移的</em>–postcopy-resume*选项）。</p>
<hr>
<p><strong>domjobinfo</strong><br><strong>语法：</strong><br>domjobinfo 域 [–completed [–keep-completed]] [–anystats] [–rawstats]<br>返回在域上运行的作业的信息。*–completed<em>告诉virsh返回最近完成的作业的信息。完成的作业的统计信息在读取后自动销毁（除非使用</em>–keep-completed*）或重新启动libvirtd时。</p>
<p>通常仅打印正在运行和成功完成的作业的统计信息。*–anystats*也可用于显示失败作业的统计信息。</p>
<p>如果使用*–rawstats*，则所有字段按从服务器接收的方式打印，不尝试解释数据。“Job type:”字段是特殊的，因为它是通过API报告的，不是统计信息的一部分。</p>
<p>请注意，对于已完成的迁移返回的时间信息可能完全不相关，除非源主机和目标主机具有同步时间（即，两者都运行NTP守护程序）。</p>
<hr>
<p><strong>domlaunchsecinfo</strong><br><strong>语法：</strong><br>domlaunchsecinfo 域<br>返回与正在运行的域关联的启动安全参数的信息。<br>报告的参数集将根据活动的启动安全保护类型而变化。如果没有活动，则不报告任何参数。</p>
<hr>
<p><strong>domsetlaunchsecstate</strong><br><strong>语法：</strong><br>domsetlaunchsecstate 域 –secrethdr hdr-filename<br>–secret secret-filename [–set-address 地址]<br>在客户内存中设置启动安全密钥。客户必须在其配置中启用launchSecurity类型并处于暂停状态。成功后，客户可以转换为运行状态。失败时，应销毁客户。<br><em>–secrethdr</em>指定包含base64编码的密钥头的文件名。头包括管理程序固件恢复启动密钥明文所需的工件。*–secret*指定包含base64编码的加密启动密钥的文件名。<br><em>–set-address</em>选项可用于指定客户内存中设置密钥的物理地址。如果未指定，地址将由管理程序确定。</p>
<hr>
<p><strong>dommemstat</strong><br><strong>语法：</strong><br>dommemstat 域 [–period 秒] [ [–config] [–live] | [–current]]<br>获取正在运行的域的内存统计信息。<br>这些字段的可用性取决于管理程序。不支持的字段将从输出中缺失。如果与较新版本的libvirtd通信，可能会出现其他字段。<br>字段说明：</p>
<ul>
<li>swap_in - 从交换空间读取的数据量（KiB）</li>
<li>swap_out - 写入交换空间的内存量（KiB）</li>
<li>major_fault - 需要磁盘IO的页面错误数</li>
<li>minor_fault - 其他页面错误数</li>
<li>unused - 系统未使用的内存量（KiB）</li>
<li>available - 域可见的可用内存量（KiB）</li>
<li>actual - 当前气球值（KiB）</li>
<li>rss - 运行域进程的驻留集大小（KiB）</li>
<li>usable - 可以通过气球回收而不会导致主机交换的内存量（KiB）</li>
<li>last-update - 上次统计信息更新的时间戳（秒）</li>
<li>disk_caches - 无需额外IO即可回收的内存量，通常是磁盘缓存（KiB）</li>
<li>hugetlb_pgalloc - 从域内启动的成功大页分配数</li>
<li>hugetlb_pgfail - 从域内启动的失败大页分配数</li>
</ul>
<p>对于带有内存气球的QEMU&#x2F;KVM，将可选的*–period<em>设置为大于0的值（秒）将允许气球驱动程序返回额外的统计信息，这些统计信息将由后续的dommemstat命令显示。将</em>–period*设置为0将停止气球驱动程序的收集，但不会清除气球驱动程序中的统计信息。至少需要QEMU&#x2F;KVM 1.5在主机上运行。</p>
<p><em>–live</em>、*–config<em>和</em>–current<em>标志仅在用于设置气球驱动程序的收集周期时有效。如果指定</em>–live<em>，则仅影响正在运行的客户机的收集周期。如果指定</em>–config<em>，则影响持久客户机的下一次启动。如果指定</em>–current<em>，则根据客户机的当前状态等效于</em>–live<em>或</em>–config*。</p>
<p>可以同时指定*–live<em>和</em>–config<em>标志，但</em>–current*是互斥的。如果未指定标志，行为因客户机状态而异。</p>
<hr>
<p><strong>domname</strong><br><strong>语法：</strong><br>domname 域ID或UUID<br>将域ID（或UUID）转换为域名</p>
<hr>
<p><strong>dompmsuspend</strong><br><strong>语法：</strong><br>dompmsuspend 域 目标 [–duration 秒]<br>将正在运行的域挂起到以下状态之一（可能的<em>目标</em>值）：</p>
<ul>
<li>mem - 相当于S3 ACPI状态</li>
<li>disk - 相当于S4 ACPI状态</li>
<li>hybrid - RAM保存到磁盘但不关闭电源<br><em>–duration</em>参数指定域挂起后唤醒前的秒数（另请参见dompmwakeup）。默认为0，表示无限挂起时间。（此功能目前不受任何管理程序驱动程序支持，应使用0。）</li>
</ul>
<p>注意：此命令需要在域的客户机操作系统中配置并运行客户机代理。</p>
<p>请注意，至少对于QEMU，当使用目标磁盘时，域的进程将终止，并在libvirt请求唤醒域时启动新进程。因此，任何运行时更改（例如设备热插拔或内存设置）将丢失，除非这些更改是使用*–config*标志进行的。</p>
<hr>
<p><strong>dompmwakeup</strong><br><strong>语法：</strong><br>dompmwakeup 域<br>从pmsuspended状态唤醒域（由dompmsuspend或客户机本身挂起）。向处于pmsuspended状态的客户注入唤醒，而不是等待先前请求的持续时间（如果有）过去。此操作不一定失败，如果域正在运行。</p>
<hr>
<p><strong>domrename</strong><br><strong>语法：</strong><br>domrename 域 新名称<br>重命名域。此命令将当前域名更改为第二个参数中指定的新名称。<br>注意：域必须处于非活动状态。</p>
<hr>
<p><strong>domstate</strong><br><strong>语法：</strong><br>domstate 域 [–reason]<br>返回有关域的状态。*–reason*告诉virsh还打印状态的原因。</p>
<hr>
<p><strong>domstats</strong><br><strong>语法：</strong><br>domstats [–raw] [–enforce] [–backing] [–nowait] [–state]<br>[–cpu-total] [–balloon] [–vcpu] [–interface]<br>[–block] [–perf] [–iothread] [–memory] [–dirtyrate] [–vm]<br>[ [–list-active] [–list-inactive]<br>[–list-persistent] [–list-transient] [–list-running]<br>[–list-paused] [–list-shutoff] [–list-other]] | [域 …]<br>获取多个或所有域的统计信息。不带任何参数时，此命令打印所有域的所有可用统计信息。<br>要收集统计信息的域列表可以通过将域列为空格分隔的列表来限制，或通过指定其中一个过滤标志*–list-NNN*。（这些方法不能组合使用。）</p>
<p>默认情况下，某些返回的字段可能会通过一组漂亮的打印机转换为更人类友好的值。要抑制此行为，请使用*–raw*标志。</p>
<p>可以通过特定标志选择各个统计信息组。默认情况下，返回所有支持的统计信息组。支持的统计信息组标志包括：*–state<em>、</em>–cpu-total<em>、</em>–balloon<em>、</em>–vcpu<em>、</em>–interface<em>、</em>–block<em>、</em>–perf<em>、</em>–iothread<em>、</em>–memory<em>、</em>–dirtyrate<em>、</em>–vm*。</p>
<p>请注意，根据管理程序类型和版本或域状态，可能不会返回以下所有统计信息。<br>选择*–state*组时，返回以下字段：</p>
<ul>
<li>state.state - VM的状态，作为virDomainState枚举中的数字返回</li>
<li>state.reason - 进入给定状态的原因，作为与给定状态对应的virDomain*Reason枚举中的整数返回<br><em>–cpu-total</em>返回：</li>
<li>cpu.time - 此域的总CPU时间（纳秒）</li>
<li>cpu.user - 用户CPU时间（纳秒）</li>
<li>cpu.system - 系统CPU时间（纳秒）</li>
<li>cpu.haltpoll.success.time - CPU暂停轮询成功时间（纳秒）</li>
<li>cpu.haltpoll.fail.time - CPU暂停轮询失败时间（纳秒）</li>
<li>cpu.cache.monitor.count - 此域的缓存监视器数量</li>
<li>cpu.cache.monitor.&lt;num&gt;.name - 缓存监视器&lt;num&gt;的名称</li>
<li>cpu.cache.monitor.&lt;num&gt;.vcpus - 缓存监视器&lt;num&gt;的vcpu列表</li>
<li>cpu.cache.monitor.&lt;num&gt;.bank.count - 缓存监视器&lt;num&gt;中的缓存库数量</li>
<li>cpu.cache.monitor.&lt;num&gt;.bank.&lt;index&gt;.id - 主机为缓存监视器&lt;num&gt;中的库&lt;index&gt;分配的缓存ID</li>
<li>cpu.cache.monitor.&lt;num&gt;.bank.&lt;index&gt;.bytes - 域在缓存库&lt;index&gt;上使用的最后一级缓存的字节数</li>
</ul>
<p><em>–balloon</em>返回：</p>
<ul>
<li>balloon.current - 当前使用的内存（KiB）</li>
<li>balloon.maximum - 允许的最大内存（KiB）</li>
<li>balloon.swap_in - 从交换空间读取的数据量（KiB）</li>
<li>balloon.swap_out - 写入交换空间的内存量（KiB）</li>
<li>balloon.major_fault - 需要磁盘IO的页面错误数</li>
<li>balloon.minor_fault - 其他页面错误数</li>
<li>balloon.unused - 系统未使用的内存量（KiB）</li>
<li>balloon.available - 域可见的可用内存量（KiB）</li>
<li>balloon.rss - 运行域进程的驻留集大小（KiB）</li>
<li>balloon.usable - 可以通过气球回收而不会导致主机交换的内存量（KiB）</li>
<li>balloon.last-update - 上次统计信息更新的时间戳（秒）</li>
<li>balloon.disk_caches - 无需额外IO即可回收的内存量，通常是磁盘（KiB）</li>
<li>balloon.hugetlb_pgalloc - 通过virtio气球从域内启动的成功大页分配数</li>
<li>balloon.hugetlb_pgfail - 通过virtio气球从域内启动的失败大页分配数</li>
</ul>
<p><em>–vcpu</em>返回：</p>
<ul>
<li>vcpu.current - 当前在线虚拟CPU的数量</li>
<li>vcpu.maximum - 在线虚拟CPU的最大数量</li>
<li>vcpu.&lt;num&gt;.state - 虚拟CPU&lt;num&gt;的状态，作为virVcpuState枚举中的数字</li>
<li>vcpu.&lt;num&gt;.time - 虚拟CPU&lt;num&gt;花费的虚拟CPU时间（纳秒）</li>
<li>vcpu.&lt;num&gt;.wait - vCPU&lt;num&gt;线程在调度程序有其他任务在其前面运行时在运行队列中等待的时间（纳秒），在Linux上需要CONFIG_SCHED_INFO</li>
<li>vcpu.&lt;num&gt;.halted - 虚拟CPU&lt;num&gt;是否暂停：是或否（可能表示处理器空闲或甚至禁用，取决于架构）</li>
<li>vcpu.&lt;num&gt;.delay - vCPU&lt;num&gt;线程在调度程序有其他任务在其前面运行时在运行队列中等待的时间（纳秒）。作为窃取时间暴露给VM。<br>此组统计信息还报告额外的管理程序来源的每vCPU统计信息。此组中的管理程序特定统计信息具有以下命名方案：</li>
</ul>
<p>vcpu.&lt;num&gt;.$NAME.$TYPE<br><strong>$NAME</strong><br>管理程序提供的统计信息字段的名称<br><strong>$TYPE</strong><br>值的类型。返回以下类型：</p>
<p><strong>cur</strong><br>当前瞬时值<br><strong>sum</strong><br>聚合值<br><strong>max</strong><br>峰值值<br>返回值可以是无符号长整型或布尔型。含义是管理程序特定的。请参阅<em>--vm</em>组的免责声明，该组也由管理程序特定的统计信息组成。</p>
<p><em>–interface</em>返回：</p>
<ul>
<li>net.count - 此域上的网络接口数量</li>
<li>net.&lt;num&gt;.name - 接口&lt;num&gt;的名称</li>
<li>net.&lt;num&gt;.rx.bytes - 接收的字节数</li>
<li>net.&lt;num&gt;.rx.pkts - 接收的数据包数</li>
<li>net.&lt;num&gt;.rx.errs - 接收错误数</li>
<li>net.&lt;num&gt;.rx.drop - 丢弃的接收数据包数</li>
<li>net.&lt;num&gt;.tx.bytes - 发送的字节数</li>
<li>net.&lt;num&gt;.tx.pkts - 发送的数据包数</li>
<li>net.&lt;num&gt;.tx.errs - 发送错误数</li>
<li>net.&lt;num&gt;.tx.drop - 丢弃的发送数据包数</li>
</ul>
<p><em>–perf</em>返回所有启用的性能事件的统计信息：</p>
<ul>
<li>perf.cmt - 当前使用的缓存使用量（字节）</li>
<li>perf.mbmt - 从一级缓存到另一级的总系统带宽</li>
<li>perf.mbml - 内存控制器的内存流量带宽</li>
<li>perf.cpu_cycles - CPU周期计数（总&#x2F;经过）</li>
<li>perf.instructions - 指令计数</li>
<li>perf.cache_references - 缓存命中计数</li>
<li>perf.cache_misses - 缓存未命中计数</li>
<li>perf.branch_instructions - 分支指令计数</li>
<li>perf.branch_misses - 分支未命中计数</li>
<li>perf.bus_cycles - 总线周期计数</li>
<li>perf.stalled_cycles_frontend - 前端指令处理器管道中的停滞CPU周期计数</li>
<li>perf.stalled_cycles_backend - 后端指令处理器管道中的停滞CPU周期计数</li>
<li>perf.ref_cpu_cycles - 参考CPU周期计数</li>
<li>perf.cpu_clock - CPU时钟时间</li>
<li>perf.task_clock - 任务时钟时间</li>
<li>perf.page_faults - 页面错误计数</li>
<li>perf.context_switches - 上下文切换计数</li>
<li>perf.cpu_migrations - CPU迁移计数</li>
<li>perf.page_faults_min - 次要页面错误计数</li>
<li>perf.page_faults_maj - 主要页面错误计数</li>
<li>perf.alignment_faults - 对齐错误计数</li>
<li>perf.emulation_faults - 仿真错误计数<br>有关每个事件的更多详细信息，请参阅perf命令。</li>
</ul>
<p><em>–block</em>返回有关与每个域关联的磁盘的信息。使用*–backing*标志将此信息扩展到覆盖支持链中的所有资源，而不是默认情况下将信息限制为每个客户磁盘的活动层。列出的信息包括：</p>
<ul>
<li>block.count - 列出的块设备数量</li>
<li>block.&lt;num&gt;.name - 块设备&lt;num&gt;的目标名称（如果存在*–backing*，则多个条目使用相同的名称）</li>
<li>block.&lt;num&gt;.backingIndex - 当存在*–backing*时，与域XML中列出的&lt;backingStore&gt;索引匹配</li>
<li>block.&lt;num&gt;.path - 块设备&lt;num&gt;的文件源，如果是本地文件或块设备</li>
<li>block.&lt;num&gt;.rd.reqs - 读取请求数</li>
<li>block.&lt;num&gt;.rd.bytes - 读取字节数</li>
<li>block.&lt;num&gt;.rd.times - 读取花费的总时间（纳秒）</li>
<li>block.&lt;num&gt;.wr.reqs - 写入请求数</li>
<li>block.&lt;num&gt;.wr.bytes - 写入字节数</li>
<li>block.&lt;num&gt;.wr.times - 写入花费的总时间（纳秒）</li>
<li>block.&lt;num&gt;.fl.reqs - 总刷新请求数</li>
<li>block.&lt;num&gt;.fl.times - 缓存刷新花费的总时间（纳秒）</li>
<li>block.&lt;num&gt;.errors - 仅Xen：’oo_req’值</li>
<li>block.&lt;num&gt;.allocation - 最高写入扇区的偏移（字节）</li>
<li>block.&lt;num&gt;.capacity - 源文件的逻辑大小（字节）</li>
<li>block.&lt;num&gt;.physical - 源文件的物理大小（字节）</li>
<li>block.&lt;num&gt;.threshold - 传递VIR_DOMAIN_EVENT_ID_BLOCK_THRESHOLD事件的阈值（字节）。参见domblkthreshold。</li>
</ul>
<p><em>–iothread</em>返回有关运行客户机上的IOThread的信息（如果管理程序支持）。<br>每个线程的“poll-max-ns”是允许每个轮询间隔发生的最大纳秒数。轮询间隔是允许线程处理数据的时间段，然后客户将其CPU量子返回给主机。设置得太小的值不允许IOThread在CPU上运行足够长的时间来处理数据。设置得太高的值会消耗过多的CPU时间，每个IOThread无法允许CPU上运行的其他线程获得时间。轮询间隔不可用于统计目的。</p>
<ul>
<li><strong>iothread.count</strong> - 后续列表中的IOThread的最大数量<br>作为无符号整数。列表中的每个IOThread将使用其iothread_id值作为&lt;id&gt;。如果轮询值不受支持，则&lt;id&gt;条目可能少于iothread.count值。</li>
<li>iothread.&lt;id&gt;.poll-max-ns - &lt;id&gt; IOThread使用的最大轮询时间（纳秒）。值为0（零）表示轮询被禁用。</li>
<li>iothread.&lt;id&gt;.poll-grow - 轮询时间增长值。值为0（零）表示增长由管理程序管理。</li>
<li>iothread.&lt;id&gt;.poll-shrink - 轮询时间缩小值。值为（零）表示缩小由管理程序管理。</li>
</ul>
<p><em>–memory</em>返回：</p>
<ul>
<li>memory.bandwidth.monitor.count - 此域的内存带宽监视器数量</li>
<li>memory.bandwidth.monitor.&lt;num&gt;.name - 监视器&lt;num&gt;的名称</li>
<li>memory.bandwidth.monitor.&lt;num&gt;.vcpus - 监视器&lt;num&gt;的vcpu列表</li>
<li><strong>memory.bandwidth.monitor.&lt;num&gt;.node.count</strong> - 内存</li>
</ul>
<p>控制器在监视器&lt;num&gt;中的数量</p>
<ul>
<li>memory.bandwidth.monitor.&lt;num&gt;.node.&lt;index&gt;.id - 主机为监视器&lt;num&gt;中的控制器&lt;index&gt;分配的内存控制器ID</li>
<li>memory.bandwidth.monitor.&lt;num&gt;.node.&lt;index&gt;.bytes.local - 通过@vcpus消耗的字节数，这些vcpu通过属于调度主机CPU的同一处理器中的内存控制器。</li>
<li>memory.bandwidth.monitor.&lt;num&gt;.node.&lt;index&gt;.bytes.total - 通过@vcpus消耗的总字节数，这些vcpu通过所有内存控制器，无论是本地还是远程控制器。</li>
</ul>
<p><em>–dirtyrate</em>返回：</p>
<ul>
<li>dirtyrate.calc_status - 上次内存脏页率计算的状态，作为virDomainDirtyRateStatus枚举中的数字返回。</li>
<li>dirtyrate.calc_start_time - 上次内存脏页率计算的开始时间。</li>
<li>dirtyrate.calc_period - 上次内存脏页率计算的周期。</li>
<li>dirtyrate.megabytes_per_second - 计算的内存脏页率（MiB&#x2F;s）。</li>
<li>dirtyrate.calc_mode - 上次测量使用的计算模式（page-sampling&#x2F;dirty-bitmap&#x2F;dirty-ring）</li>
<li>dirtyrate.vcpu.&lt;num&gt;.megabytes_per_second - 虚拟CPU的内存脏页率（MiB&#x2F;s）</li>
</ul>
<p><em>–vm</em>返回：<br><em>--vm</em>选项启用管理程序特定统计信息的报告。字段的命名和含义完全取决于管理程序。<br>此组中的统计信息具有以下命名方案：<br>vm.$NAME.$TYPE<br><strong>$NAME</strong><br>管理程序提供的统计信息字段的名称<br><strong>$TYPE</strong><br>值的类型。返回以下类型：</p>
<p><strong>cur</strong><br>当前瞬时值<br><strong>sum</strong><br>聚合值<br><strong>max</strong><br>峰值值<br>返回值可以是无符号长整型或布尔型。<br><strong>警告</strong>：此组中报告的统计信息是运行时收集的，源自管理程序，因此不属于libvirt的常规稳定API策略。</p>
<p>Libvirt无法保证从外部源报告的统计信息将在管理程序的未来版本中存在，或命名或含义保持一致。但是，对现有字段的更改预计很少。</p>
<p>选择特定的统计信息组不保证守护程序支持所选统计信息组。标志<em>--enforce</em>强制命令在守护程序不支持所选组时失败。</p>
<p>在收集统计信息时，libvirtd可能会等待一段时间，如果给定域上已有另一个作业正在运行以完成。这可能导致不必要的延迟传递统计信息。使用<em>--nowait</em>抑制此行为。另一方面，此类域可能会缺少某些统计信息。</p>
<hr>
<p><strong>domtime</strong><br><strong>语法：</strong><br>domtime 域 { [–now] [–pretty] [–sync] [–time 时间] }<br>获取或设置域的系统时间。当不带任何参数（但<em>域</em>）运行时，打印域的当前系统时间。<em>--pretty</em>修饰符可用于以更人类可读的形式打印时间。</p>
<p>当指定<em>--time</em>时间时，不获取域的时间，而是设置它。<em>--now</em>修饰符的作用类似于<em>--time</em> $now的别名，这意味着它设置virsh运行的主机上当前的时间。在这两种情况下（设置和获取），时间是以1970-01-01纪元以来的秒数为单位的UTC时间。<em>--sync</em>修改设置行为：忽略传递的时间，而是从域的RTC读取要设置的时间。请注意，某些管理程序可能需要配置客户代理才能获取或设置客户时间。</p>
<hr>
<p><strong>domuuid</strong><br><strong>语法：</strong><br>domuuid 域名或ID<br>将域名或ID转换为域UUID</p>
<hr>
<p><strong>domxml-from-native</strong><br><strong>语法：</strong><br>domxml-from-native 格式 配置<br>将原生客户配置格式<em>格式</em>的文件<em>配置</em>转换为域XML格式。对于QEMU&#x2F;KVM管理程序，<em>格式</em>参数必须为qemu-argv。对于Xen管理程序，<em>格式</em>参数可以是xen-xm、xen-xl或xen-sxpr。对于LXC管理程序，<em>格式</em>参数必须为lxc-tools。对于VMware&#x2F;ESX管理程序，<em>格式</em>参数必须为vmware-vmx。对于Bhyve管理程序，<em>格式</em>参数必须为bhyve-argv。</p>
<hr>
<p><strong>domxml-to-native</strong><br><strong>语法：</strong><br>domxml-to-native 格式 { [–xml] xml | –domain 域名或ID或UUID }<br>将文件<em>xml</em>转换为域XML格式，或将现有的<em>--domain</em>转换为名为<em>格式</em>的原生客户配置格式。<em>xml</em>和<em>--domain</em>参数是互斥的。有关<em>格式</em>参数的类型，请参阅domxml-from-native。</p>
<hr>
<p><strong>dump</strong><br><strong>语法：</strong><br>dump 域 核心文件路径 [–bypass-cache]<br>{ [–live] | [–crash] | [–reset] }<br>[–verbose] [–memory-only] [–format 字符串]<br>将域的核心转储到文件以进行分析。如果指定<em>--live</em>，域在核心转储完成之前继续运行，而不是提前暂停。如果指定<em>--crash</em>，域以崩溃状态停止，而不仅仅是保持在暂停状态。如果指定<em>--reset</em>，域在成功转储后重置。注意，这三个开关是互斥的。如果指定<em>--bypass-cache</em>，保存将避免文件系统缓存，尽管这可能会减慢操作速度。如果指定<em>--memory-only</em>，文件是elf文件，仅包含域的内存和CPU通用寄存器值。如果域直接使用主机设备，这将非常有用。<em>--format</em> <em>字符串</em>用于指定“memory-only”转储的格式，<em>字符串</em>可以是以下之一：elf、kdump-zlib（zlib压缩的kdump压缩格式）、kdump-lzo（lzo压缩的kdump压缩格式）、kdump-snappy（snappy压缩的kdump压缩格式）、win-dmp（Windows完整崩溃转储格式）。</p>
<p>可以使用domjobinfo virsh命令监视进度，并使用domjobabort命令（由另一个virsh实例发送）取消。另一个选项是向运行dump命令的virsh进程发送SIGINT（通常使用Ctrl-C）。<em>--verbose</em>显示转储的进度。</p>
<p>注意：某些管理程序可能需要用户手动确保<em>核心文件路径</em>参数指定的文件和路径具有适当的权限。</p>
<p>注意：旧kvmdump格式的崩溃转储正在过时，自其版本6.1.0以来无法由崩溃实用程序加载和处理。需要<em>--memory-only</em>选项以生成可由崩溃实用程序稍后处理的有效ELF文件。</p>
<hr>
<p><strong>dumpxml</strong><br><strong>语法：</strong><br>dumpxml [–inactive] [–security-info] [–update-cpu] [–migratable]<br>[–xpath 表达式] [–wrap] 域</p>
<p>将域信息作为XML转储输出到stdout，此格式可由create命令使用。可以使用影响XML转储的其他选项。<em>--inactive</em>告诉virsh转储将在域下次启动时使用的域配置，而不是当前域配置。使用<em>--security-info</em>还将包括XML转储中的安全敏感信息。<em>--update-cpu</em>根据主机CPU更新域CPU要求。使用<em>--migratable</em>可以请求适合迁移的XML，即与较旧版本的libvirt兼容，并可能使用内部运行时选项进行修改。此选项可能会自动启用其他选项（<em>--update-cpu</em>、<em>--security-info</em>，…）根据需要。</p>
<p>如果 <strong>--xpath</strong> 参数提供XPath表达式，则将对输出XML求值，并仅打印匹配的节点。默认行为是将每个匹配节点打印为独立文档，但是为了便于进一步处理，<strong>--wrap</strong>参数将使匹配节点包装在公共根节点中。</p>
<hr>
<p><strong>edit</strong><br><strong>语法：</strong><br>edit 域<br>编辑域的XML配置文件，这将影响客户机的下次启动。<br>这等效于：virsh dumpxml –inactive –security-info 域 &gt; 域.xml<br>vi 域.xml（或使用其他文本编辑器进行更改）<br>virsh define 域.xml<br>不同之处在于它进行了一些错误检查。<br>使用的编辑器可以由$VISUAL或$EDITOR环境变量提供，默认为vi。</p>
<hr>
<p><strong>emulatorpin</strong><br><strong>语法：</strong><br>emulatorpin 域 [CPU列表] [ [–live] [–config] | [–current]]<br>查询或更改域的模拟器线程到主机物理CPU的绑定。<br>有关<em>CPU列表</em>的信息，请参见vcpupin。<br>如果指定<em>--live</em>，则影响正在运行的客户机。如果指定<em>--config</em>，则影响持久客户机的下一次启动。如果指定<em>--current</em>，则根据客户机的当前状态等效于<em>--live</em>或<em>--config</em>。可以同时指定<em>--live</em>和<em>--config</em>标志（如果存在<em>CPU列表</em>），但<em>--current</em>是互斥的。如果未指定标志，行为因管理程序而异。</p>
<hr>
<p><strong>event</strong><br><strong>语法：</strong><br>event {[域] { 事件 | –all } [–loop] [–timeout 秒] [–timestamp] | –list}<br>等待一类域事件发生，并在事件发生时打印适当的详细信息。事件可以选择由<em>域</em>过滤。仅使用<em>--list</em>作为参数将提供此客户端已知的可能<em>事件</em>值的列表，尽管连接可能不允许注册所有这些事件。也可以使用<em>--all</em>代替<em>事件</em>一次注册所有可能的事件类型。</p>
<p>默认情况下，此命令是一次性的，一旦事件发生即返回成功；您可以发送SIGINT（通常通过Ctrl-C）立即退出。如果指定<em>--timeout</em>，则命令在<em>秒</em>后放弃等待事件。使用<em>--loop</em>，命令打印所有事件，直到超时或中断键。</p>
<p>当使用<em>--timestamp</em>时，将在事件之前打印人类可读的时间戳。</p>
<hr>
<p><strong>get-user-sshkeys</strong><br><strong>语法：</strong><br>get-user-sshkeys 域 用户<br>打印给定<em>用户</em>在客户<em>域</em>中的SSH授权密钥。请注意，文件中的条目具有*sshd(8)*定义的内部结构，virsh&#x2F;libvirt将密钥视为不透明字符串，即不解释它们。</p>
<hr>
<p><strong>guest-agent-timeout</strong><br><strong>语法：</strong><br>guest-agent-timeout 域 [–timeout 值]<br>设置等待客户代理命令响应的时长。默认情况下，代理命令无限期阻塞等待响应。值必须是正值（等待给定的秒数）或以下值之一：</p>
<ul>
<li>-2 - 无限期阻塞等待结果（当省略--timeout时使用），</li>
<li>-1 - 将超时重置为默认值（当前在libvirt守护程序中定义为5秒），</li>
<li>0 - 完全不等待，<br>在所有基于客户代理的API中，当发生超时时，如果实际命令已发送到客户代理，则返回的错误代码将为VIR_ERR_AGENT_COMMAND_TIMEOUT。</li>
</ul>
<hr>
<p><strong>guestinfo</strong><br><strong>语法：</strong><br>guestinfo 域 [–user] [–os] [–timezone] [–hostname] [–filesystem]<br>[–disk] [–interface]<br>从客户代理的角度打印有关客户的信息。请注意，此命令需要在域的客户操作系统中配置并运行客户代理。<br>当不带任何参数运行时，此命令打印客户代理当时支持的所有信息类型，省略不可用的类型。在这种情况下总是报告成功。</p>
<p>您可以通过指定一个或多个标志来限制返回的信息类型。可用的信息类型标志包括<em>--user</em>、<em>--os</em>、<em>--timezone</em>、<em>--hostname</em>、<em>--filesystem</em>、<em>--disk</em>、<em>--interface</em>和<em>--load</em>。如果明确请求的信息类型当时不受客户代理支持，则进程将提供退出代码1。</p>
<p>请注意，根据管理程序类型和在域内运行的客户代理的版本，可能不会返回以下所有信息。</p>
<p><em>--user</em>信息类型时，可能会返回以下字段：</p>
<ul>
<li>user.count - 此域上的活动用户数</li>
<li>user.&lt;num&gt;.name - 用户&lt;num&gt;的用户名</li>
<li>user.&lt;num&gt;.domain - 用户&lt;num&gt;的域（可能仅在某些客户类型上存在）</li>
<li>user.&lt;num&gt;.login-time - 用户&lt;num&gt;的登录时间（自纪元以来的毫秒数）</li>
</ul>
<p><em>--os</em>返回：</p>
<ul>
<li>os.id - 标识操作系统的字符串</li>
<li>os.name - 操作系统的名称</li>
<li>os.pretty-name - 操作系统的漂亮名称</li>
<li>os.version - 操作系统的版本</li>
<li>os.version-id - 操作系统的版本ID</li>
<li>os.kernel-release - 操作系统内核的发布</li>
<li>os.kernel-version - 操作系统内核的版本</li>
<li>os.machine - 机器硬件名称</li>
<li>os.variant - 操作系统的特定变体或版本</li>
<li>os.variant-id - 操作系统的特定变体或版本的ID</li>
</ul>
<p><em>--timezone</em>返回：</p>
<ul>
<li>timezone.name - 时区的名称</li>
<li>timezone.offset - 与UTC的偏移（秒）</li>
</ul>
<p><em>--hostname</em>返回：</p>
<ul>
<li>hostname - 域的主机名</li>
</ul>
<p><em>--filesystem</em>返回：</p>
<ul>
<li>fs.count - 此域上定义的文件系统数量</li>
<li>fs.&lt;num&gt;.mountpoint - 文件系统&lt;num&gt;的挂载点路径</li>
<li>fs.&lt;num&gt;.name - 客户中的设备名称（例如sda1）用于文件系统&lt;num&gt;</li>
<li>fs.&lt;num&gt;.fstype - 文件系统&lt;num&gt;的类型</li>
<li>fs.&lt;num&gt;.total-bytes - 文件系统&lt;num&gt;的总大小</li>
<li>fs.&lt;num&gt;.used-bytes - 文件系统&lt;num&gt;中使用的字节数</li>
<li>fs.&lt;num&gt;.disk.count - 文件系统&lt;num&gt;目标的磁盘数量</li>
<li>fs.&lt;num&gt;.disk.&lt;num&gt;.alias - 磁盘&lt;num&gt;的设备别名（例如sda）</li>
<li>fs.&lt;num&gt;.disk.&lt;num&gt;.serial - 磁盘&lt;num&gt;的序列号</li>
<li>fs.&lt;num&gt;.disk.&lt;num&gt;.device - 磁盘&lt;num&gt;的设备节点</li>
</ul>
<p><em>--disk</em>返回：</p>
<ul>
<li>disk.count - 此域上定义的磁盘数量</li>
<li>disk.&lt;num&gt;.name - 设备节点（Linux）或设备UNC（Windows）</li>
<li>disk.count - 该域上定义的磁盘数量</li>
<li>disk.<num>.name - 设备节点(Linux)或设备UNC路径(Windows)</li>
<li>disk.<num>.partition - 指示这是分区还是整块磁盘</li>
<li>disk.<num>.dependency.count - 设备依赖项的数量</li>
<li>disk.<num>.dependency.<num>.name - 依赖项名称</li>
<li>disk.<num>.serial - 可选的磁盘序列号</li>
<li>disk.<num>.alias - 磁盘的设备别名(例如sda)</li>
<li>disk.<num>.guest_alias - 客户机分配给磁盘的可选别名</li>
<li>disk.<num>.guest_bus - 客户机报告的总线类型</li>
</ul>
<p><em>--interface</em> 返回信息</p>
<ul>
<li>if.count - 该域上定义的接口数量</li>
<li>if.<num>.name - 客户机中的接口名称(例如eth0)</li>
<li>if.<num>.hwaddr - 客户机中的硬件地址</li>
<li>if.<num>.addr.count - 接口<num>的IP地址数量</li>
<li>if.<num>.addr.<num1>.type - 地址<num1>的IP地址类型(例如ipv4)</li>
<li>if.<num>.addr.<num1>.addr - 地址<num1>的IP地址</li>
<li>if.<num>.addr.<num1>.prefix - 地址<num1>的IP前缀</li>
</ul>
<p><em>--load</em> 返回信息</p>
<ul>
<li>load.1m - 客户机最近1分钟的平均负载</li>
<li>load.5m - 客户机最近5分钟的平均负载</li>
<li>load.15m - 客户机最近15分钟的平均负载</li>
</ul>
<hr>
<p><strong>guestvcpus</strong><br><strong>语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">guestvcpus domain [ [--enable] | [--disable]] [cpulist]</span><br></pre></td></tr></table></figure>
<p>从客户机角度查询或更改vCPU状态。当不带<em>cpulist</em>参数调用时，查询客户机可用的vCPU、它们的状态以及是否可以离线。</p>
<p>如果提供了<em>cpulist</em>，则必须同时提供*–enable<em>或</em>–disable*之一。然后将在域上执行所需操作。</p>
<p>有关<em>cpulist</em>的信息，请参阅vcpupin。</p>
<hr>
<p><strong>iothreadadd</strong><br><strong>语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iothreadadd domain iothread_id [ [--config] [--live] | [--current]]</span><br></pre></td></tr></table></figure>
<p>使用指定的<em>iothread_id</em>向域添加新的IOThread。如果<em>iothread_id</em>已存在，命令将失败。<em>iothread_id</em>必须大于零。</p>
<p>如果指定*–live<em>，则影响运行中的客户机。如果客户机未运行，则返回错误。如果指定</em>–config<em>，则影响持久客户机的下次启动。如果指定</em>–current<em>，则根据客户机当前状态等同于</em>–live<em>或</em>–config*。</p>
<hr>
<p><strong>iothreaddel</strong><br><strong>语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iothreaddel domain iothread_id [ [--config] [--live] | [--current]]</span><br></pre></td></tr></table></figure>
<p>使用指定的<em>iothread_id</em>从域中删除IOThread。如果IOThread当前已分配给磁盘资源(例如通过attach-disk命令)，则删除IOThread的尝试将失败。如果<em>iothread_id</em>不存在，将发生错误。</p>
<p>如果指定*–live<em>，则影响运行中的客户机。如果客户机未运行，则返回错误。如果指定</em>–config<em>，则影响持久客户机的下次启动。如果指定</em>–current<em>，则根据客户机当前状态等同于</em>–live<em>或</em>–config*。</p>
<hr>
<p><strong>iothreadinfo</strong><br><strong>语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iothreadinfo domain [ [--live] [--config] | [--current]]</span><br></pre></td></tr></table></figure>
<p>显示域的基本IOThread信息，包括每个IOThread的IOThread ID和CPU亲和性。</p>
<p>如果指定*–live<em>，则从运行中的客户机获取IOThread数据。如果客户机未运行，则返回错误。如果指定</em>–config<em>，则从持久客户机的下次启动获取IOThread数据。如果指定</em>–current<em>或未指定</em>–live<em>和</em>–config*，则根据客户机当前状态(可以是运行中或离线)获取IOThread数据。</p>
<hr>
<p><strong>iothreadpin</strong><br><strong>语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iothreadpin domain iothread cpulist [ [--live] [--config] | [--current]]</span><br></pre></td></tr></table></figure>
<p>更改域IOThread与主机物理CPU的绑定关系。要检索所有IOThread的列表，请使用iothreadinfo。要绑定<em>iothread</em>，请为IOThread ID指定所需的<em>cpulist</em>，如iothreadinfo输出中所列。</p>
<p><em>cpulist</em>是物理CPU编号的列表。其语法是逗号分隔的列表，也可以使用’-‘和’^’的特殊标记(例如’0-4’，’0-3,^2’)。’-‘表示范围，’^’表示排除。如果要重置iothreadpin设置，即将<em>iothread</em>绑定到所有物理CPU，只需将<em>cpulist</em>指定为’r’。</p>
<p>如果指定*–live<em>，则影响运行中的客户机。如果客户机未运行，则返回错误。如果指定</em>–config<em>，则影响持久客户机的下次启动。如果指定</em>–current<em>，则根据客户机当前状态等同于</em>–live<em>或</em>–config<em>。如果存在</em>cpulist<em>，则可以同时给出</em>–live<em>和</em>–config<em>标志，但</em>–current*是互斥的。如果未指定标志，则行为因hypervisor而异。</p>
<p>注意：表达式是按顺序计算的，因此”0-15,^8”与”9-14,0-7,15”相同，但与”^8,0-15”不同。</p>
<hr>
<p><strong>iothreadset</strong><br><strong>语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iothreadset domain iothread_id [ [--poll-max-ns ns] [--poll-grow factor]</span><br><span class="line">[--poll-shrink divisor] [--thread-pool-min value]</span><br><span class="line">[--thread-pool-max value]]</span><br><span class="line">[ [--config] [--live] | [--current]]</span><br></pre></td></tr></table></figure>
<p>使用指定的<em>iothread_id</em>修改域的现有iothread。*–poll-max-ns<em>提供IOThread允许的最大轮询间隔(纳秒)。如果提供0(零)，则禁用该IOThread的轮询。</em>–poll-grow<em>是调整当前轮询时间以达到最大轮询时间的因子。如果提供0(零)，则将使用默认因子。</em>–poll-shrink*是减少当前轮询时间以低于最大轮询间隔的商数。如果提供0(零)，则将使用默认商数。对于运行中的客户机，轮询值是纯动态的。保存、销毁、停止等操作将导致轮询值在下一次启动、恢复等时返回hypervisor默认值。</p>
<p><em>–thread-pool-min</em>和*–thread-pool-max<em>选项分别设置给定iothread工作池中线程数的下限和上限。对于非活动配置的更改，可以指定-1以从域配置中删除相应的边界。对于运行中客户机的更改，建议首先设置上限(</em>–thread-pool-max*)，然后才设置下限(<em>–thread-pool-min</em>)。允许下限与上限相同，但不允许上限为零值。</p>
<p>如果指定*–live<em>，则影响运行中的客户机。如果客户机未运行，则返回错误。如果指定</em>–current<em>或未指定</em>–live<em>，则视为指定了</em>–live*。(这里的”current”表示客户机当前的状态：运行中或离线。)</p>
<hr>
<p><strong>managedsave</strong><br><strong>语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">managedsave domain [--bypass-cache] [&#123;--running | --paused&#125;] [--verbose]</span><br></pre></td></tr></table></figure>
<p>保存并销毁(停止)运行中的域，以便以后可以从相同的状态重新启动。当下次为该域运行virsh start命令时，它将自动从此保存状态启动。如果指定*–bypass-cache*，保存将绕过文件系统缓存，尽管这可能会减慢操作速度。</p>
<p>可以使用domjobinfo virsh命令监视进度，并使用domjobabort命令(由另一个virsh实例发送)取消。另一个选项是向运行managedsave命令的virsh进程发送SIGINT(通常使用Ctrl-C)。*–verbose*显示保存进度。</p>
<p>通常，启动托管保存将根据保存时域的状态决定是运行还是暂停；传递*–running<em>或</em>–paused*标志将允许覆盖启动应使用的状态。</p>
<p>可以使用dominfo命令查询域当前是否有任何托管保存映像。</p>
<hr>
<p><strong>managedsave-define</strong><br><strong>语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">managedsave-define domain xml [&#123;--running | --paused&#125;]</span><br></pre></td></tr></table></figure>
<p>更新稍后启动<em>domain</em>时将使用的域XML。<em>xml</em>参数必须是包含替代XML的文件名，仅更改域XML中主机特定的部分。例如，它可以用于更改磁盘文件路径。</p>
<p>托管保存映像记录域应启动到运行状态还是暂停状态。通常，此命令不会更改记录的状态；传递*–running<em>或</em>–paused*标志将允许覆盖启动应使用的状态。</p>
<hr>
<p><strong>managedsave-dumpxml</strong><br><strong>语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">managedsave-dumpxml [--security-info] [--xpath EXPRESSION] [--wrap] domain</span><br></pre></td></tr></table></figure>
<p>提取使用managedsave命令创建保存状态文件<em>file</em>时生效的域XML。使用*–security-info*还将包括安全敏感信息。</p>
<p>如果 <strong>–xpath</strong> 参数提供XPath表达式，则将对输出XML求值并仅打印匹配的节点。默认行为是将每个匹配节点打印为独立文档，但是为了便于进一步处理，**–wrap**参数将使匹配节点包装在公共根节点中。</p>
<hr>
<p><strong>managedsave-edit</strong><br><strong>语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">managedsave-edit domain [&#123;--running | --paused&#125;]</span><br></pre></td></tr></table></figure>
<p>编辑与managedsave命令创建的<em>domain</em>保存状态文件关联的XML配置。</p>
<p>托管保存映像记录域应启动到运行状态还是暂停状态。通常，此命令不会更改记录的状态；传递*–running<em>或</em>–paused*标志将允许覆盖恢复应使用的状态。</p>
<p>这相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">virsh managedsave-dumpxml domain-name &gt; state-file.xml</span><br><span class="line">vi state-file.xml (或使用其他文本编辑器进行更改)</span><br><span class="line">virsh managedsave-define domain-name state-file-xml</span><br></pre></td></tr></table></figure>
<p>只是它进行了一些错误检查。</p>
<p>使用的编辑器可以由$VISUAL或$EDITOR环境变量提供，默认为vi。</p>
<hr>
<p><strong>managedsave-remove</strong><br><strong>语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">managedsave-remove domain</span><br></pre></td></tr></table></figure>
<p>删除域的managedsave状态文件(如果存在)。这确保域下次启动时将执行完整引导。</p>
<hr>
<p><strong>maxvcpus</strong><br><strong>语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxvcpus [type]</span><br></pre></td></tr></table></figure>
<p>提供此连接上客户机VM支持的虚拟CPU最大数量。如果提供，<em>type</em>参数必须是XML中<domain>元素的有效类型属性。</p>
<hr>
<p><strong>memtune</strong><br><strong>语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memtune domain [--hard-limit size] [--soft-limit size]</span><br><span class="line">[--swap-hard-limit size]</span><br><span class="line">[--min-guarantee size] [ [--config] [--live] | [--current]]</span><br></pre></td></tr></table></figure>
<p>允许您显示或设置域内存参数。不带标志时，显示当前设置；带标志时，如果hypervisor支持，则调整相应的限制。LXC和QEMU&#x2F;KVM支持*–hard-limit<em>、</em>–soft-limit<em>和</em>–swap-hard-limit<em>。</em>–min-guarantee*仅由ESX hypervisor支持。这些限制都是带单位的整数(参见上面的NOTES)，如果没有后缀，则默认为kibibytes(1024字节的块)。Libvirt向上舍入到最接近的kibibyte。一些hypervisor需要比KiB更大的粒度，不是偶数倍的请求将被向上舍入。例如，vSphere&#x2F;ESX将参数向上舍入到mebibytes(1024 kibibytes)。</p>
<p>如果指定*–live<em>，则影响运行中的客户机。如果指定</em>–config<em>，则影响持久客户机的下次启动。如果指定</em>–current<em>，则根据客户机当前状态等同于</em>–live<em>或</em>–config<em>。可以同时给出</em>–live<em>和</em>–config<em>标志，但</em>–current*是互斥的。如果未指定标志，则行为因hypervisor而异。</p>
<p>对于QEMU&#x2F;KVM，参数应用于整个QEMU进程。因此，在计算它们时，需要将客户机RAM、客户机视频RAM和QEMU本身的一些内存开销相加。最后一部分很难确定，因此需要猜测和尝试。</p>
<p>对于LXC，显示的hard_limit值是来自XML的当前内存设置或virsh setmem命令的结果。</p>
<ul>
<li><em>–hard-limit</em></li>
</ul>
<p>客户机可以使用的最大内存。</p>
<ul>
<li><em>–soft-limit</em></li>
</ul>
<p>在内存争用期间强制执行的内存限制。</p>
<ul>
<li><em>–swap-hard-limit</em></li>
</ul>
<p>客户机可以使用的内存加交换空间的最大值。这必须大于提供的hard-limit值。</p>
<ul>
<li><em>–min-guarantee</em></li>
</ul>
<p>客户机的保证最小内存分配。</p>
<p>将这些限制的值指定为-1表示无限制。</p>
<hr>
<p><strong>metadata</strong><br><strong>语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">metadata domain [ [--live] [--config] | [--current]]</span><br><span class="line">[--edit] [uri] [key] [set] [--remove]</span><br></pre></td></tr></table></figure>
<p>显示或修改域的自定义XML元数据。元数据是用户定义的XML，允许在域定义中存储任意XML数据。可以在域XML中存储多个单独的自定义元数据片段。这些片段由通过<em>uri</em>参数提供的私有XML命名空间标识。(另请参阅处理域文本元数据的desc。)</p>
<p>标志*–live<em>或</em>–config<em>选择此命令是处理域的实时定义还是持久定义。如果同时指定</em>–live<em>和</em>–config<em>，则在获取当前描述时</em>–config<em>选项优先，而在设置描述时同时更新实时配置和配置。</em>–current*是互斥的，如果未指定这些标志，则隐含。</p>
<p>标志*–remove<em>指定应删除由</em>uri*参数指定的元数据元素，而不是更新。</p>
<p>标志*–edit<em>指定应打开由</em>uri<em>参数标识的元数据的编辑器，并在之后保存内容。否则，可以通过</em>set*参数提供新内容。</p>
<p>当通过*–edit<em>或</em>set<em>设置元数据时，必须指定</em>key*参数，并用于前缀自定义元素以将它们绑定到私有命名空间。</p>
<p>如果未指定*–edit<em>和</em>set<em>，则显示与</em>uri*命名空间对应的XML元数据，而不是修改它。</p>
<hr>
<p><strong>migrate</strong><br><strong>语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">migrate [--live] [--offline] [--direct] [--p2p [--tunnelled]]</span><br><span class="line">[--persistent] [--undefinesource] [--suspend]</span><br><span class="line">[--copy-storage-all]</span><br><span class="line">[--copy-storage-inc] [--change-protection] [--unsafe]</span><br><span class="line">[--verbose]</span><br><span class="line">[--rdma-pin-all] [--abort-on-error] [--postcopy]</span><br><span class="line">[--postcopy-after-precopy] [--postcopy-resume] [--zerocopy]</span><br><span class="line">domain desturi [migrateuri] [graphicsuri] [listen-address] [dname]</span><br><span class="line">[--timeout seconds [--timeout-suspend | --timeout-postcopy]]</span><br><span class="line">[--xml file]</span><br><span class="line">[--migrate-disks disk-list] [--migrate-disks-detect-zeroes disk-list]</span><br><span class="line">[--disks-port port]</span><br><span class="line">[--compressed] [--comp-methods method-list]</span><br><span class="line">[--comp-mt-level] [--comp-mt-threads] [--comp-mt-dthreads]</span><br><span class="line">[--comp-xbzrle-cache] [--comp-zlib-level] [--comp-zstd-level]</span><br><span class="line">[--auto-converge] [auto-converge-initial]</span><br><span class="line">[auto-converge-increment] [--persistent-xml file] [--tls]</span><br><span class="line">[--postcopy-bandwidth bandwidth]</span><br><span class="line">[--parallel [--parallel-connections connections]]</span><br><span class="line">[--bandwidth bandwidth] [--tls-destination hostname]</span><br><span class="line">[--disks-uri URI] [--copy-storage-synchronous-writes]</span><br><span class="line">[--available-switchover-bandwidth bandwidth]</span><br></pre></td></tr></table></figure>
<p>将域迁移到另一主机。添加*–live<em>进行实时迁移；&lt;–p2p&gt;进行点对点迁移；</em>–direct<em>进行直接迁移；或</em>–tunnelled<em>进行隧道迁移。</em>–offline<em>迁移域定义而不在目标主机上启动域，也不在源主机上停止它。离线迁移可用于非活动域，并且必须与</em>–persistent*选项一起使用。</p>
<p><em>–persistent</em>使域在目标主机上持久化(参见下面与*–xml<em>一起使用时的特殊情况)，</em>–undefinesource<em>在源主机上取消定义域，</em>–suspend*使域在目标主机上暂停。</p>
<p><em>–copy-storage-all</em>表示使用完整磁盘复制的非共享存储迁移，*–copy-storage-inc<em>表示使用增量复制的非共享存储迁移(源和目标共享相同的基础映像)。在这两种情况下，磁盘映像必须存在于目标主机上，</em>–copy-storage-…<em>选项仅告诉libvirt将数据从源主机上的映像传输到目标主机上相同位置的映像。默认情况下，仅传输非共享非只读映像。使用</em>–migrate-disks<em>显式指定要通过逗号分隔的disk-list参数传输的磁盘目标列表。</em>–migrate-disks-detect-zeroes<em>选项接受逗号分隔的磁盘目标名称列表，为列出的迁移磁盘启用零块检测。这些块不会被传输或在目标上分配，有效地稀疏化磁盘，但以CPU开销为代价。用户必须确保在使用此选项之前，任何预先创建的存储源都被清除，从而读取全零，否则目标映像可能会损坏。使用</em>–copy-storage-synchronous-writes*标志时，磁盘数据迁移将同步处理客户机磁盘写入到原始源和目标，以确保磁盘迁移收敛，但可能会降低突发性能。</p>
<p><em>–change-protection</em>强制在迁移过程中不对域进行不兼容的配置更改；如果hypervisor支持，此标志会隐式启用，但如果hypervisor缺乏更改保护支持，可以显式使用此标志来拒绝迁移。</p>
<p><em>–verbose</em>显示迁移进度。</p>
<p><em>–abort-on-error</em>如果在迁移过程中发生软错误(例如I&#x2F;O错误)，则取消迁移。</p>
<p><em>–postcopy</em>在迁移中启用后复制逻辑，但实际上不启动后复制，即迁移以预复制模式启动。一旦迁移运行，用户可以从另一个virsh实例发送migrate-postcopy命令切换到后复制，或使用*–postcopy-after-precopy<em>与</em>–postcopy<em>一起让libvirt在预复制第一遍完成后自动切换到后复制。可以使用</em>–postcopy-bandwidth<em>限制后复制阶段消耗的最大带宽。可以使用</em>–bandwidth<em>限制预复制阶段消耗的最大带宽。如果在迁移处于后复制模式时主机之间的连接中断，则域无法在源主机或目标主机上恢复，migrate命令将报告错误，使域在两个主机上都处于活动状态。要从这种情况中恢复，请使用额外的</em>–postcopy-resume*标志重复原始migrate命令。</p>
<p><em>–auto-converge</em>强制在实时迁移期间收敛。可以使用<em>auto-converge-initial</em>设置初始客户机CPU限制率。如果初始限制率不足以确保收敛，则定期增加<em>auto-converge-increment</em>。</p>
<p><em>–rdma-pin-all</em>可以与RDMA迁移(即当<em>migrateuri</em>以rdma:&#x2F;&#x2F;开头时)一起使用，告诉hypervisor在迁移开始前一次性固定域的所有内存，而不是根据需要固定内存页。对于QEMU&#x2F;KVM，这需要使用hard_limit内存调优元素(在域XML中)并设置为域配置的最大内存加上QEMU进程本身消耗的任何内存。注意不要将内存限制设置得过高(从而允许域锁定主机的大部分内存)。这样做可能对域和主机本身都危险，因为主机的内核可能会耗尽内存。</p>
<p><em>–zerocopy</em>请求使用零复制机制迁移内存页。对于QEMU&#x2F;KVM，这意味着QEMU将被临时允许锁定主机内存中的所有客户机页，尽管同时只会锁定那些排队传输的页。</p>
<p>注意：各个hypervisor通常不支持所有可能的迁移类型。例如，QEMU不支持直接迁移。</p>
<p>在某些情况下，libvirt可能会拒绝迁移域，因为这样做可能会导致潜在问题，如数据损坏，因此迁移被认为是不安全的。对于QEMU域，如果域使用磁盘而没有显式将缓存模式设置为”none”，则可能会发生这种情况。除非磁盘映像存储在一致的集群文件系统(如GFS2或GPFS)上，否则迁移此类域是不安全的。如果您确定迁移是安全的，或者您只是不在乎，请使用*–unsafe*强制迁移。</p>
<p><em>dname</em>用于在迁移期间将域重命名为新名称，通常也可以省略。</p>
<p><em>–xml</em> file虽然通常不需要，但可以用于在目标上提供替代XML文件，以对域XML的任何主机特定部分提供更大范围的更改，例如考虑源和目标在访问底层存储时的命名差异。如果*–xml<em>与</em>–persistent<em>一起使用，通常需要通过</em>–persistent-xml*(见下文)提供持久XML定义，该定义以与传递给*–file*的XML相同的方式修复。</p>
<p>如果启用*–persistent<em>，可以使用</em>–persistent-xml* file提供替代XML文件，该文件将用作目标主机上的持久客户机定义。</p>
<p>如果启用*–live<em>，</em>–timeout* seconds告诉virsh在实时迁移超过该秒数时运行指定的操作。可以指定*–timeout-suspend<em>，域将在超时后暂停，迁移将离线完成；如果命令行上未指定</em>–timeout-``选项，则这是默认值。当使用**–timeout-postcopy<em>时，virsh将在超时后从预复制切换到后复制；迁移必须使用</em>–postcopy*选项启动才能工作。</p>
<p><em>–compressed</em>激活压缩，使用*–comp-methods<em>选择压缩方法。支持的方法有”mt”、”xbzrle”、”zlib”和”zstd”。支持的方法集及其组合取决于hypervisor和迁移选项。QEMU仅在使用</em>–parallel<em>时支持”zlib”和”zstd”方法，并且不能同时使用。当未指定方法时，将使用hypervisor默认方法。只要不使用</em>–parallel<em>，QEMU默认为”xbzrle”。对于</em>–parallel<em>迁移，QEMU不提供任何默认压缩方法，因此必须使用</em>–comp-method<em>显式指定。可以进一步调整压缩方法。</em>–comp-mt-level<em>设置”mt”方法的压缩级别。值范围为0到9，其中1是最大速度，9是最大压缩。</em>–comp-mt-threads<em>和</em>–comp-mt-dthreads<em>分别设置源上的压缩线程数和目标上的解压缩线程数。</em>–comp-xbzrle-cache<em>设置页面缓存大小(字节)。</em>–comp-zlib-level<em>设置使用”zlib”方法时的压缩级别。值范围为0到9，默认为1，其中0是无压缩，1是最大速度，9是最大压缩。</em>–comp-zstd-level*设置使用”zstd”方法时的压缩级别。值范围为0到20，默认为1，其中0是无压缩，1是最大速度，20是最大压缩。</p>
<p>提供*–tls<em>使迁移使用主机配置的TLS设置(参见&#x2F;etc&#x2F;libvirt&#x2F;qemu.conf中的migrate_tls_x509_cert_dir)以执行域的迁移。使用需要在源和目标上正确设置TLS。通常，目标主机的TLS证书必须与主机名匹配才能使TLS验证成功。当证书与目标主机名不匹配且已知预期证书的主机名时，可以在启动迁移时使用</em>–tls-destination<em>传递预期的</em>hostname*。</p>
<p><em>–parallel</em>选项将使迁移数据通过多个并行连接发送。可以使用*–parallel-connections*设置此类连接的数量。并行连接可能有助于饱和源和目标之间的网络链接，从而加快迁移速度。</p>
<p>可以通过中断virsh(通常使用Ctrl-C)或从另一个virsh实例发送domjobabort命令来取消正在运行的迁移。</p>
<p><em>desturi</em>和<em>migrateuri</em>参数可用于控制迁移使用的目标。<em>desturi</em>对于托管迁移很重要，但对于直接迁移未使用；<em>migrateuri</em>对于直接迁移是必需的，但对于托管迁移通常可以自动确定。</p>
<p>注意：普通迁移和点对点迁移的<em>desturi</em>参数有不同的语义：</p>
<ul>
<li><p>普通迁移：<em>desturi</em>是从客户端机器看到的目标主机的地址。</p>
</li>
<li><p>点对点迁移：<em>desturi</em>是从源机器看到的目标主机的地址。</p>
</li>
</ul>
<p>在特殊情况下，当您需要完全控制连接和&#x2F;或libvirt无法远程访问网络时，可以在URI中使用UNIX传输并指定查询中的套接字路径，例如对于qemu驱动程序，您可以使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu+unix:///system?socket=/path/to/socket</span><br></pre></td></tr></table></figure>

<p>当未指定<em>migrateuri</em>时，libvirt将自动确定hypervisor特定的URI。一些hypervisor(包括QEMU)具有可选的”migration_host”配置参数(当主机有多个网络接口时有用)。如果未指定此参数，libvirt通过查找目标主机的配置主机名来确定名称。</p>
<p>在以下几种情况下，指定<em>migrateuri</em>可能有帮助：</p>
<ul>
<li><p>配置的主机名不正确，或DNS有问题。如果主机的主机名无法解析以匹配其公共IP地址之一，则libvirt将生成不正确的URI。在这种情况下，应显式指定<em>migrateuri</em>，使用IP地址或正确的主机名。</p>
</li>
<li><p>主机有多个网络接口。如果主机有多个网络接口，可能希望出于安全或性能原因通过特定接口发送迁移数据流。在这种情况下，应显式指定<em>migrateuri</em>，使用与要使用的网络关联的IP地址。</p>
</li>
<li><p>防火墙限制了可用端口。当libvirt生成迁移URI时，它将使用hypervisor特定规则选择端口号。一些hypervisor只需要在防火墙中打开单个端口，而其他hypervisor则需要整个端口号范围。在后一种情况下，可以指定<em>migrateuri</em>以选择默认范围之外的特定端口号，以符合本地防火墙策略。</p>
</li>
<li><p><em>desturi</em>使用UNIX传输方法。在这种高级情况下，libvirt不应猜测<em>migrateuri</em>，而应使用UNIX套接字路径URI指定：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unix:///path/to/socket</span><br></pre></td></tr></table></figure></li>
</ul>
<p>有关迁移URI的更多详细信息，请参见<a target="_blank" rel="noopener" href="https://libvirt.org/migration.html#uris%E3%80%82">https://libvirt.org/migration.html#uris。</a></p>
<p>可选的<em>graphicsuri</em>覆盖用于在迁移结束时自动重新连接图形客户端的连接参数。如果省略，libvirt将基于目标主机IP地址计算参数。如果客户端无法直接访问虚拟化主机连接的网络，需要通过代理连接，则可以使用<em>graphicsuri</em>指定客户端应连接的地址。URI格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protocol://hostname[:port]/[?parameters]</span><br></pre></td></tr></table></figure>
<p>其中protocol是”spice”或”vnc”，parameters是由’&amp;’分隔的协议特定参数列表。当前识别的参数是”tlsPort”和”tlsSubject”。例如，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spice://target.host.com:1234/?tlsPort=4567</span><br></pre></td></tr></table></figure>

<p>可选的<em>listen-address</em>设置目标端hypervisor应绑定以进行传入迁移的监听地址。接受IPv4和IPv6地址以及主机名(解析在目标端完成)。一些hypervisor不支持指定监听地址，如果使用此参数将返回错误。如果<em>desturi</em>使用UNIX传输方法，则不能使用此参数。</p>
<p>可选的<em>disks-port</em>设置目标端hypervisor应绑定以进行磁盘传入通信的端口。目前仅QEMU支持。</p>
<p>也可以指定可选的<em>disks-uri</em>(与<em>disks-port</em>互斥)以指定迁移磁盘时远程hypervisor应绑定&#x2F;连接的内容。这可以是<em>tcp:&#x2F;&#x2F;address:port</em>以指定监听地址(覆盖磁盘迁移的<em>--migrate-uri</em>和<em>--listen-address</em>)和端口，或者如果您需要磁盘迁移通过具有指定路径的UNIX套接字进行，则可以是<em>unix:&#x2F;&#x2F;&#x2F;path&#x2F;to&#x2F;socket</em>。在这种情况下，您需要确保相同的套接字路径对源和目标hypervisor都可访问，并且连接到源上的套接字(在hypervisor在目标上创建后)实际上将连接到目标。如果您使用SELinux(至少在源主机上)，您需要确保源上的套接字对libvirtd&#x2F;QEMU可访问以进行连接。Libvirt无法更改现有套接字的上下文，因为它与套接字的文件表示不同，并且上下文由其创建者选择(通常使用*setsockcreatecon{,_raw}()*函数)。</p>
<p>可选的<em>--available-switchover-bandwidth</em>覆盖自动计算的带宽(MiB&#x2F;s)，该带宽用于(预复制)迁移的最后阶段，在此期间CPU停止，所有剩余内存和设备状态被传输。了解此带宽对于准确估计域停机时间和决定切换的正确时刻很重要。通常这将基于迁移使用的带宽进行估计，但这可能低于实际可用带宽。当迁移会反复迭代认为没有足够的带宽来遵守配置的最大停机时间时，使用此选项可能有助于迁移收敛。</p>
<hr>
<p><strong>migrate-compcache</strong><br><strong>语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">migrate-compcache domain [--size bytes]</span><br></pre></td></tr></table></figure>
<p>设置和&#x2F;或获取用于在实时迁移期间压缩重复传输内存页的缓存大小(字节)。不带<em>size</em>调用时，该命令仅打印压缩缓存的当前大小。指定<em>size</em>时，请求hypervisor将压缩缓存更改为<em>size</em>字节，然后打印当前大小(由于hypervisor的舍入，结果可能与请求的大小不同)。<em>size</em>选项应在域实时迁移时使用，作为对迁移进度和从domjobinfo获得的压缩缓存未命中数增加的反应。</p>
<hr>
<p><strong>migrate-getmaxdowntime</strong><br><strong>语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">migrate-getmaxdowntime domain</span><br></pre></td></tr></table></figure>
<p>获取正在实时迁移到另一主机的域的最大可容忍停机时间。这是实时迁移结束时允许客户机停机的毫秒数。</p>
<hr>
<p><strong>migrate-getspeed</strong><br><strong>语法：</strong><br>migrate-getspeed 域名 [–postcopy]<br>获取域名的最大迁移带宽（以MiB&#x2F;s为单位）。如果指定了<code>--postcopy</code>选项，则命令将获取在后复制迁移阶段允许的最大带宽。</p>
<hr>
<p><strong>migrate-postcopy</strong><br><strong>语法：</strong><br>migrate-postcopy 域名<br>将当前迁移从预复制切换到后复制。此操作仅支持以<code>--postcopy</code>选项启动的迁移。</p>
<hr>
<p><strong>migrate-setmaxdowntime</strong><br><strong>语法：</strong><br>migrate-setmaxdowntime 域名 停机时间<br>为正在实时迁移到另一主机的域名设置最大可容忍停机时间。<code>停机时间</code>是允许客户机在实时迁移结束时停止运行的毫秒数。</p>
<hr>
<p><strong>migrate-setspeed</strong><br><strong>语法：</strong><br>migrate-setspeed 域名 带宽 [–postcopy]<br>为正在迁移到另一主机的域名设置最大迁移带宽（以MiB&#x2F;s为单位）。<code>带宽</code>被解释为无符号长整型值。指定负值将提供一个基本无限制的值给虚拟机监控程序，虚拟机监控程序可以选择拒绝该值或将其转换为允许的最大值。如果指定了<code>--postcopy</code>选项，则命令将设置在后复制迁移阶段允许的最大带宽。</p>
<hr>
<p><strong>numatune</strong><br><strong>语法：</strong><br>numatune 域名 [–mode 模式] [–nodeset 节点集]<br>[ [–config] [–live] | [–current]]<br>设置或获取域名的NUMA参数，对应于域XML的<code>&lt;numatune&gt;</code>元素。不带标志时，显示当前设置。</p>
<p><code>模式</code>可以是<code>strict</code>、<code>interleave</code>、<code>preferred</code>或<code>restrictive</code>之一，或者是虚拟机监控程序支持的<code>virDomainNumatuneMemMode</code>枚举中的任何有效数字。对于运行中的域名，模式无法更改，节点集只能在域名以<code>restrictive</code>模式启动时更改。</p>
<p><code>节点集</code>是主机用于运行域名的NUMA节点列表。其语法为逗号分隔的列表，使用<code>-</code>表示范围，<code>^</code>表示排除节点。</p>
<p>如果指定<code>--live</code>，则设置运行中客户机的调度信息。如果指定<code>--config</code>，则影响持久客户机的下一次启动。如果指定<code>--current</code>，则根据客户机的当前状态等同于<code>--live</code>或<code>--config</code>。</p>
<p>对于Linux主机上的运行中客户机，更改域名的NUMA参数并不意味着客户机内存会立即移动到不同的节点集。内存迁移取决于客户机活动，空闲客户机的内存将在其之前的节点集中保留更长时间。VFIO设备的存在也会将部分客户机内存锁定在启动客户机时使用的节点集中，无论节点集如何更改。</p>
<hr>
<p><strong>perf</strong><br><strong>语法：</strong><br>perf 域名 [–enable 事件规范] [–disable 事件规范]<br>[ [–config] [–live] | [–current]]<br>获取当前性能事件设置或为客机域名启用&#x2F;禁用特定性能事件。</p>
<p>Perf是Linux中的性能分析工具，可以检测CPU性能计数器、跟踪点、kprobes和uprobes（动态跟踪）。Perf支持一系列可测量事件，可以测量来自不同来源的事件。例如，一些事件是纯内核计数器，称为软件事件，包括上下文切换、小故障等。目前仅QEMU&#x2F;KVM支持此命令。</p>
<p><code>事件规范</code>是一个或多个事件的逗号分隔列表。有效事件名称包括：</p>
<p><strong>有效性能事件名称</strong></p>
<ul>
<li>cmt - 监控平台上应用程序对缓存的使用情况。</li>
<li>mbmt - 监控一级缓存和另一级之间的总系统内存带宽。</li>
<li>mbml - 限制通过套接字上内存控制器的数据量（字节&#x2F;秒）。</li>
<li>cache_misses - 监控平台上应用程序的缓存未命中次数。</li>
<li>cache_references - 监控平台上应用程序的缓存命中次数。</li>
<li>instructions - 监控平台上应用程序执行的指令数。</li>
<li>cpu_cycles - 监控CPU周期数（总&#x2F;经过）。可与指令一起使用以获取每条指令的周期数。</li>
<li>branch_instructions - 监控平台上应用程序执行的分支指令数。</li>
<li>branch_misses - 监控平台上应用程序执行的分支未命中数。</li>
<li>bus_cycles - 监控平台上应用程序执行的总线周期数。</li>
<li>stalled_cycles_frontend - 监控平台上应用程序在指令处理器流水线前端停滞的CPU周期数。</li>
<li>stalled_cycles_backend - 监控平台上应用程序在指令处理器流水线后端停滞的CPU周期数。</li>
<li>ref_cpu_cycles - 监控不受CPU频率缩放影响的总CPU周期数。</li>
<li>cpu_clock - 监控平台上应用程序消耗的CPU时钟时间。</li>
<li>task_clock - 监控平台上应用程序消耗的任务时钟时间。</li>
<li>page_faults - 监控平台上应用程序的页面错误数。</li>
<li>context_switches - 监控平台上应用程序的上下文切换数。</li>
<li>cpu_migrations - 监控平台上应用程序的CPU迁移数。</li>
<li>page_faults_min - 监控平台上应用程序的小页面错误数。</li>
<li>page_faults_maj - 监控平台上应用程序的大页面错误数。</li>
<li>alignment_faults - 监控平台上应用程序的对齐错误数。</li>
<li>emulation_faults - 监控平台上应用程序的模拟错误数。</li>
</ul>
<p>注意：可以使用<code>domstats</code>命令通过<code>--perf</code>标志检索统计信息。</p>
<p>如果指定<code>--live</code>，则影响运行中的客户机。如果指定<code>--config</code>，则影响持久客户机的下一次启动。如果指定<code>--current</code>，则根据客户机的当前状态等同于<code>--live</code>或<code>--config</code>。</p>
<hr>
<p><strong>reboot</strong><br><strong>语法：</strong><br>reboot 域名 [–mode 模式列表]<br>重启域名。此操作类似于从控制台运行重启命令。命令在执行重启操作后立即返回，可能远早于域名实际重启。</p>
<p>域名重启的确切行为由其XML定义中的<code>on_reboot</code>参数设置。</p>
<p>默认情况下，虚拟机监控程序会尝试选择适当的关闭方法。要指定替代方法，<code>--mode</code>参数可以指定一个逗号分隔的列表，包括acpi、agent、initctl、signal和paravirt。驱动程序尝试每种模式的顺序未定义，与virsh指定的顺序无关。要严格控制顺序，请一次使用单一模式并重复命令。</p>
<hr>
<p><strong>reset</strong><br><strong>语法：</strong><br>reset 域名<br>立即重置域名，无需任何客户机关闭。重置模拟机器上的电源重置按钮，所有客户硬件看到RST线设置并重新初始化内部状态。<br>注意：无客户操作系统关闭的重置可能导致数据丢失。</p>
<hr>
<p><strong>restore</strong><br><strong>语法：</strong><br>restore 状态文件 [–bypass-cache] [–xml 文件]<br>[–running | –paused] [–reset-nvram]<br>[–parallel-channels]<br>从virsh保存的状态文件恢复域名。有关更多信息，请参阅<code>save</code>。</p>
<p>如果指定<code>--bypass-cache</code>，则恢复将绕过文件系统缓存。根据具体场景，这可能会减慢或加快操作。</p>
<p><code>--xml</code>文件通常省略，但可用于提供替代XML文件，仅更改域XML中主机特定部分。例如，可用于考虑在客户机保存后由于磁盘快照导致的底层存储文件命名差异。</p>
<p>通常，恢复保存的镜像将使用保存镜像中记录的状态来决定是运行还是暂停；传递<code>--running</code>或<code>--paused</code>标志可以覆盖恢复时应使用的状态。</p>
<p>如果指定<code>--reset-nvram</code>，则任何现有的NVRAM文件将被删除并从原始模板重新初始化。</p>
<p><code>--parallel-channels</code>选项可以指定从文件加载内存时使用的并行IO通道数。并行保存可以显著减少保存大型内存域所需的时间。</p>
<p>注意：为避免损坏域内文件系统内容，除非已将存储卷还原到创建状态文件时的内容，否则不应重复使用保存的状态文件进行第二次恢复。</p>
<hr>
<p><strong>resume</strong><br><strong>语法：</strong><br>resume 域名<br>将域名从暂停状态移出。这将允许先前暂停的域名现在有资格由底层虚拟机监控程序调度。</p>
<hr>
<p><strong>save</strong><br><strong>语法：</strong><br>save 域名 状态文件 [–bypass-cache] [–xml 文件]<br>[–image-format 格式] [–parallel-channels 通道]<br>[–running | –paused] [–verbose]<br>将运行中的域名（RAM，而非磁盘状态）保存到状态文件中，以便稍后恢复。保存后，域名将不再在系统上运行，因此为域名分配的内存将可供其他域名使用。<code>virsh restore</code>从此状态文件恢复。</p>
<p>如果指定<code>--bypass-cache</code>，则保存将绕过文件系统缓存。根据具体场景，这可能会减慢或加快操作。</p>
<p>可以使用<code>domjobinfo</code> virsh命令监视进度，并使用<code>domjobabort</code>命令（由另一个virsh实例发送）取消。另一种选择是向运行保存命令的virsh进程发送SIGINT（通常使用Ctrl-C）。<code>--verbose</code>显示保存的进度。</p>
<p>这大致相当于在运行中的计算机上执行休眠，具有所有相同的限制。恢复时，开放的网络连接可能会中断，因为TCP超时可能已过期。</p>
<p><code>--xml</code>文件通常省略，但可用于提供替代XML文件，仅更改域XML中主机特定部分。例如，可用于考虑在客户机保存后由于磁盘快照导致的底层存储文件命名差异。</p>
<p>通常，恢复保存的镜像将决定是运行还是暂停；传递<code>--running</code>或<code>--paused</code>标志可以覆盖恢复时应使用的状态。</p>
<p><code>--image-format</code>选项可以更改用于将数据保存到文件的默认图像格式。有关详细信息，请参阅qemu.conf配置文件。</p>
<p><code>--parallel-channels</code>选项可以指定将内存保存到文件时使用的并行IO通道数。使用并行IO通道需要使用稀疏图像保存格式。并行保存可以显著减少保存大型内存域所需的时间。</p>
<p>域保存状态文件假定磁盘映像在创建和恢复点之间保持不变。对于更完整的系统恢复点（磁盘状态与内存状态一起保存），请参阅快照系列命令。</p>
<hr>
<p><strong>save-image-define</strong><br><strong>语法：</strong><br>save-image-define 文件 xml [–running | –paused]<br>更新稍后在<code>restore</code>命令中使用<code>文件</code>时将使用的域XML。<code>xml</code>参数必须是包含替代XML的文件名，仅更改域XML中主机特定部分。例如，可用于考虑在客户机保存后由于磁盘快照导致的底层存储文件命名差异。</p>
<p>保存镜像记录域名应恢复到运行还是暂停状态。通常，此命令不会更改记录的状态；传递<code>--running</code>或<code>--paused</code>标志可以覆盖恢复时应使用的状态。</p>
<hr>
<p><strong>save-image-dumpxml</strong><br><strong>语法：</strong><br>save-image-dumpxml [–security-info] [–xpath 表达式]<br>[–wrap] 文件<br>提取在通过<code>save</code>命令创建保存状态文件<code>文件</code>时生效的域XML。使用<code>--security-info</code>还将包括安全敏感信息。</p>
<p>如果<code>--xpath</code>参数提供XPath表达式，则将对输出XML求值，并仅打印匹配的节点。默认行为是将每个匹配节点打印为独立文档，但为了便于进一步处理，<code>--wrap</code>参数将导致匹配节点包装在公共根节点中。</p>
<hr>
<p><strong>save-image-edit</strong><br><strong>语法：</strong><br>save-image-edit 文件 [–running | –paused]<br>编辑由<code>save</code>命令创建的保存状态文件<code>文件</code>关联的XML配置。</p>
<p>保存镜像记录域名应恢复到运行还是暂停状态。通常，此命令不会更改记录的状态；传递<code>--running</code>或<code>--paused</code>标志可以覆盖恢复时应使用的状态。</p>
<p>此命令等效于：</p>
<p>virsh save-image-dumpxml 状态文件 &gt; 状态文件.xml<br>vi 状态文件.xml（或使用其他文本编辑器进行更改）<br>virsh save-image-define 状态文件 状态文件.xml</p>
<p>但会进行一些错误检查。</p>
<p>使用的编辑器可以由<code>$VISUAL</code>或<code>$EDITOR</code>环境变量提供，默认为vi。</p>
<hr>
<p><strong>schedinfo</strong><br><strong>语法：</strong><br>schedinfo 域名 [ [–config] [–live] | [–current]]<br>[ [–set] 参数&#x3D;值]…<br>schedinfo [–weight 数字] [–cap 数字] 域名<br>显示（和设置）域调度器参数。每个虚拟机监控程序的可用参数如下：</p>
<p>LXC（posix调度器）：cpu_shares、vcpu_period、vcpu_quota<br>QEMU&#x2F;KVM（posix调度器）：cpu_shares、vcpu_period、vcpu_quota、emulator_period、emulator_quota、global_period、global_quota、iothread_period、iothread_quota<br>Xen（credit调度器）：weight、cap<br>ESX（分配调度器）：reservation、limit、shares</p>
<p>如果指定<code>--live</code>，则设置运行中客户机的调度信息。如果指定<code>--config</code>，则影响持久客户机的下一次启动。如果指定<code>--current</code>，则根据客户机的当前状态等同于<code>--live</code>或<code>--config</code>。</p>
<p>注意：<code>cpu_shares</code>参数在cgroups v1中的有效值范围为2-262144，在cgroups v2中为1-10000。</p>
<p>注意：<code>weight</code>和<code>cap</code>参数仅针对XEN_CREDIT调度器定义。</p>
<p>注意：<code>vcpu_period</code>、<code>emulator_period</code>和<code>iothread_period</code>参数的有效值范围为1000-1000000或0，<code>vcpu_quota</code>、<code>emulator_quota</code>和<code>iothread_quota</code>参数的有效值范围为1000-17592186044415或小于0。值为0等同于不指定该参数。</p>
<hr>
<p><strong>screenshot</strong><br><strong>语法：</strong><br>screenshot 域名 [图像文件路径] [–screen 屏幕ID]<br>捕获当前域名控制台的屏幕截图并存储到文件中。如果虚拟机监控程序支持域名的多个显示器，则<code>屏幕ID</code>允许指定要捕获的屏幕。它是屏幕的序号。对于多个显卡，头设备先枚举，例如两个显卡各有四个头设备，屏幕ID 5表示第二个显卡的第二个头设备。</p>
<hr>
<p><strong>send-key</strong><br><strong>语法：</strong><br>send-key 域名 [–codeset 代码集] [–holdtime 保持时间]<br>键码…<br>将<code>键码</code>序列解析为发送到<code>域名</code>的按键。每个<code>键码</code>可以是数值或对应代码集中的符号名称。如果指定<code>--holdtime</code>，则每个按键将保持指定的毫秒数。默认代码集为linux，但使用<code>--codeset</code>选项可以选择其他代码集。</p>
<p>如果指定多个键码，则它们将同时发送到客户机，并且可能以随机顺序接收。如果需要不同的按键，必须使用多个send-key调用。</p>
<p>支持的代码集包括：</p>
<ul>
<li>linux：数值由Linux通用输入事件子系统定义。符号名称与相应的Linux键常量宏名称匹配。</li>
<li>xt：数值由原始XT键盘控制器定义。不提供符号名称。</li>
<li>atset1：数值由AT键盘控制器集1（即XT兼容集）定义。不提供符号名称。</li>
<li>atset2：数值由AT键盘控制器集2定义。不提供符号名称。</li>
<li>atset3：数值由AT键盘控制器集3（即PS&#x2F;2兼容集）定义。不提供符号名称。</li>
<li>os_x：数值由macOS键盘输入子系统定义。符号名称与相应的macOS键常量宏名称匹配。</li>
<li>xt_kbd：数值由Linux KBD设备定义。这些是原始XT代码集的变体，但扩展键码的编码通常不同。不提供符号名称。</li>
<li>win32：数值由Win32键盘输入子系统定义。符号名称与相应的Win32键常量宏名称匹配。</li>
<li>usb：数值由USB HID规范定义。不提供符号名称。</li>
<li>qnum：数值由QNUM扩展定义，用于发送原始键码。这些是XT代码集的变体，但扩展键码的第二字节低位设置为1，而不是第一字节高位。不提供符号名称。</li>
</ul>
<p><strong>示例：</strong></p>
<p># 使用xt代码集发送三个按键’k’、’e’、’y’。这些按键同时按下，客户机可能以随机顺序接收。<br>virsh send-key dom –codeset xt 37 18 21  </p>
<p># 发送一个按键’right-ctrl+C’<br>virsh send-key dom KEY_RIGHTCTRL KEY_C  </p>
<p># 发送一个Tab键，保持1秒<br>virsh send-key –holdtime 1000 0xf  </p>
<hr>
<p><strong>send-process-signal</strong><br><strong>语法：</strong><br>send-process-signal 域名ID 进程ID 信号名<br>向虚拟域<code>域名ID</code>中运行的进程<code>进程ID</code>发送信号<code>信号名</code>。<code>进程ID</code>是虚拟域命名空间中的进程ID。</p>
<p><code>信号名</code>可以是整数信号常量号，或以下符号名称之一：</p>
<p>“nop”, “hup”, “int”, “quit”, “ill”,<br>“trap”, “abrt”, “bus”, “fpe”, “kill”,<br>“usr1”, “segv”, “usr2”, “pipe”, “alrm”,<br>“term”, “stkflt”, “chld”, “cont”, “stop”,<br>“tstp”, “ttin”, “ttou”, “urg”, “xcpu”,<br>“xfsz”, “vtalrm”, “prof”, “winch”, “poll”,<br>“pwr”, “sys”, “rt0”, “rt1”, “rt2”, “rt3”,<br>“rt4”, “rt5”, “rt6”, “rt7”, “rt8”, “rt9”,<br>“rt10”, “rt11”, “rt12”, “rt13”, “rt14”, “rt15”,<br>“rt16”, “rt17”, “rt18”, “rt19”, “rt20”, “rt21”,<br>“rt22”, “rt23”, “rt24”, “rt25”, “rt26”, “rt27”,<br>“rt28”, “rt29”, “rt30”, “rt31”, “rt32”</p>
<p>符号名称可以可选地以sig或sig_为前缀，并且可以是大写或小写。</p>
<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><strong>示例：</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">virsh send-process-signal myguest 1 15  </span><br><span class="line">virsh send-process-signal myguest 1 term  </span><br><span class="line">virsh send-process-signal myguest 1 sigterm  </span><br><span class="line">virsh send-process-signal myguest 1 SIG_HUP  </span><br></pre></td></tr></table></figure></h2><p><strong>set-lifecycle-action</strong><br><strong>语法：</strong><br>set-lifecycle-action 域名 类型 动作<br>[ [–config] [–live] | [–current]]<br>为指定的生命周期<code>类型</code>设置生命周期<code>动作</code>。有效类型为”poweroff”、”reboot”和”crash”，对于每种类型，有效动作为”destroy”、”restart”、”rename-restart”、”preserve”。对于类型”crash”，还支持附加动作”coredump-destroy”和”coredump-restart”。</p>
<hr>
<p><strong>set-user-password</strong><br><strong>语法：</strong><br>set-user-password 域名 用户 密码 [–encrypted]<br>设置客户域中<code>用户</code>帐户的密码。</p>
<p>如果指定<code>--encrypted</code>，则假定密码已按客户操作系统要求的方法加密。</p>
<p>对于QEMU&#x2F;KVM，这需要配置并运行客户代理。</p>
<hr>
<p><strong>set-user-sshkeys</strong><br><strong>语法：</strong><br>set-user-sshkeys 域名 用户 [–file 文件] [–reset | –remove]<br>从<code>文件</code>读取密钥并追加到客户<code>域名</code>中<code>用户</code>的SSH授权密钥文件中。<code>文件</code>中的密钥必须位于单独的行上，并且每行必须遵循<code>sshd(8)</code>定义的授权密钥格式。</p>
<p>如果指定<code>--reset</code>，则在追加新密钥之前清除客户授权密钥文件内容。作为一种特殊情况，如果提供<code>--reset</code>但未提供<code>文件</code>，则不添加新密钥，并清除授权密钥文件。</p>
<p>如果指定<code>--remove</code>，则从授权密钥文件中删除从<code>文件</code>读取的密钥，而不是添加新密钥。如果密钥不存在于文件中，不会视为错误。</p>
<hr>
<p><strong>setmaxmem</strong><br><strong>语法：</strong><br>setmaxmem 域名 大小 [ [–config] [–live] | [–current]]<br>更改客户域的最大内存分配限制。如果指定<code>--live</code>，则影响运行中的客户机。如果指定<code>--config</code>，则影响持久客户机的下一次启动。如果指定<code>--current</code>，则根据客户机的当前状态等同于<code>--live</code>或<code>--config</code>。</p>
<p><code>大小</code>是一个缩放整数（参见NOTES）；默认单位为KiB（1024字节块），除非提供后缀（旧选项名称<code>--kilobytes</code>作为已弃用的同义词）。Libvirt向上舍入到最接近的KiB。某些虚拟机监控程序需要比KiB更大的粒度，不是偶数的请求将向上舍入。例如，vSphere&#x2F;ESX将参数向上舍入到MiB（1024 KiB）。</p>
<hr>
<p><strong>setmem</strong><br><strong>语法：</strong><br>setmem 域名 大小 [ [–config] [–live] | [–current]]<br>更改客户域的内存分配。如果指定<code>--live</code>，则对运行中的客户机执行内存气球操作。如果指定<code>--config</code>，则影响持久客户机的下一次启动。如果指定<code>--current</code>，则根据客户机的当前状态等同于<code>--live</code>或<code>--config</code>。</p>
<p><code>大小</code>是一个缩放整数（参见NOTES）；默认单位为KiB（1024字节块），除非提供后缀（旧选项名称<code>--kilobytes</code>作为已弃用的同义词）。Libvirt向上舍入到最接近的KiB。某些虚拟机监控程序需要比KiB更大的粒度，不是偶数的请求将向上舍入。例如，vSphere&#x2F;ESX将参数向上舍入到MiB（1024 KiB）。</p>
<p>对于Xen，仅当域是半虚拟化或运行PV气球驱动程序时，才能调整运行中域的内存。</p>
<p>对于LXC，设置的值是cgroups的limit_in_bytes值或用户内存（包括文件缓存）的最大量。在容器内查看内存时，这是&#x2F;proc&#x2F;meminfo中的”MemTotal”值。从主机查看值时，使用virsh memtune命令。要查看当前使用的内存和允许设置的最大值，请使用virsh dominfo命令。</p>
<hr>
<p><strong>setvcpus</strong><br><strong>语法：</strong><br>setvcpus 域名 数量 [–maximum] [ [–config] [–live] | [–current] ]<br>[–guest] [–hotpluggable]<br>更改客户域中活动的虚拟CPU数量。默认情况下，此命令适用于活动客户域。要更改非活动客户域的设置，请使用<code>--config</code>标志。</p>
<p><code>数量</code>值可能受主机、虚拟机监控程序或客户域原始描述中的限制。对于Xen，仅当域是半虚拟化时才能调整运行中域的虚拟CPU。</p>
<p>如果指定<code>--config</code>标志，则更改将保存到客户域的存储XML配置中，并在下次启动客户域时生效。</p>
<p>如果指定<code>--live</code>，则客户域必须处于活动状态，并且更改立即生效。如果虚拟机监控程序支持，可以同时指定<code>--config</code>和<code>--live</code>标志。如果在客户机完成启动之前运行此命令，客户机可能无法处理更改。</p>
<p>如果指定<code>--current</code>，则根据客户机的当前状态等同于<code>--live</code>或<code>--config</code>。</p>
<p>未指定标志时，假定为<code>--live</code>，且客户域必须处于活动状态。在这种情况下，由虚拟机监控程序决定是否也假定<code>--config</code>标志，从而调整XML配置以使更改持久。</p>
<p>如果指定<code>--guest</code>，则CPU计数在客户机中修改，而不是在虚拟机监控程序中。此标志仅适用于活动域，并且可能需要在客户机中配置客户代理。</p>
<p>要允许将vcpu添加到持久定义中，以便在域启动后可以热拔插，必须指定<code>--hotpluggable</code>标志。支持vcpu拔插的活动域中添加到域的vcpu会自动标记为可热拔插。</p>
<p><code>--maximum</code>标志控制下次启动域时可以热插拔的虚拟CPU的最大数量。因此，它必须仅与<code>--config</code>标志一起使用，而不能与<code>--live</code>或<code>--current</code>标志一起使用。注意，如果为客机指定了处理器拓扑，则可能无法更改最大vcpu计数。</p>
<hr>
<p><strong>setvcpu</strong><br><strong>语法：</strong><br>setvcpu 域名 vcpu列表 [–enable] | [–disable]<br>[ [–live] [–config] | [–current] ]</p>
<p>使用热插拔机制更改单个vCPU的状态。</p>
<p>有关<code>vcpu列表</code>格式的信息，请参阅vcpupin。虚拟机监控程序驱动程序可能要求<code>vcpu列表</code>包含完全属于一个可热插拔实体的vCPU。这通常只是一个vCPU，但某些架构（如ppc64）要求一次指定完整核心。</p>
<p>注意：虚拟机监控程序可能拒绝禁用某些vcpu，例如vcpu 0或其他。</p>
<p>如果指定<code>--live</code>，则影响运行中的域。如果指定<code>--config</code>，则影响持久客户机的下一次启动。如果指定<code>--current</code>，则根据客户机的当前状态等同于<code>--live</code>或<code>--config</code>。这是默认行为。可以同时指定<code>--live</code>和<code>--config</code>标志，但<code>--current</code>是互斥的。</p>
<hr>
<p><strong>shutdown</strong><br><strong>语法：</strong><br>shutdown 域名 [–mode 模式列表]<br>优雅地关闭域名。此操作与域操作系统协调以执行优雅关闭，因此不能保证成功，并且可能需要可变长度的时间，具体取决于域中必须关闭的服务。</p>
<p>域名关闭的确切行为由其XML定义中的<code>on_poweroff</code>参数设置。</p>
<p>如果<code>域名</code>是临时的，则一旦客户机停止运行，任何快照和检查点的元数据将丢失，但底层内容仍然存在，并且具有相同名称和UUID的新域可以使用snapshot-create恢复快照元数据，使用checkpoint-create恢复检查点元数据。</p>
<p>默认情况下，虚拟机监控程序会尝试选择适当的关闭方法。要指定替代方法，<code>--mode</code>参数可以指定一个逗号分隔的列表，包括acpi、agent、initctl、signal和paravirt。驱动程序尝试每种模式的顺序未定义，与virsh指定的顺序无关。要严格控制顺序，请一次使用单一模式并重复命令。</p>
<hr>
<p><strong>start</strong><br><strong>语法：</strong><br>start 域名或UUID [–console] [–paused]<br>[–autodestroy] [–bypass-cache] [–force-boot]<br>[–pass-fds N,M,…] [–reset-nvram]</p>
<p>启动（先前定义的）非活动域，从最后一个managedsave状态恢复，或者如果没有managedsave状态，则通过全新启动。如果使用<code>--paused</code>选项且驱动程序支持，则域将暂停；否则将运行。如果请求<code>--console</code>，则在创建后附加到控制台。如果请求<code>--autodestroy</code>，则当virsh关闭其与libvirt的连接或以其他方式退出时，客户机将自动销毁。如果指定<code>--bypass-cache</code>且存在managedsave状态，则恢复将绕过文件系统缓存，尽管这可能会减慢操作。如果指定<code>--force-boot</code>，则丢弃任何managedsave状态并执行全新启动。</p>
<p>如果指定<code>--pass-fds</code>，则参数是逗号分隔的打开文件描述符列表，应传递到客户机中。文件描述符将在客户机中重新编号，从3开始。这仅支持基于容器的虚拟化。</p>
<p>如果指定<code>--reset-nvram</code>，则任何现有的NVRAM文件将被删除并从原始模板重新初始化。</p>
<hr>
<p><strong>suspend</strong><br><strong>语法：</strong><br>suspend 域名<br>暂停运行中的域。它保留在内存中，但不再被调度。</p>
<hr>
<p><strong>ttyconsole</strong><br><strong>语法：</strong><br>ttyconsole 域名<br>输出用于域TTY控制台的设备。如果信息不可用，进程将提供退出码1。</p>
<hr>
<p><strong>undefine</strong><br><strong>语法：</strong><br>undefine 域名 [–managed-save] [–snapshots-metadata]<br>[–checkpoints-metadata] [–nvram] [–keep-nvram]<br>[–storage 卷 | –remove-all-storage<br>[–delete-storage-volume-snapshots] –wipe-storage]<br>[–tpm] [–keep-tpm]<br>取消定义域。如果域正在运行，则将其转换为临时域，而不停止它。如果域处于非活动状态，则删除域配置。</p>
<p><code>--managed-save</code>标志确保任何托管保存映像（参见managedsave命令）也被清理。没有此标志，尝试取消定义具有托管保存映像的域将失败。</p>
<p><code>--snapshots-metadata</code>标志确保在取消定义非活动域时清理任何快照（参见snapshot-list命令）。没有此标志，尝试取消定义具有快照元数据的非活动域将失败。如果域处于活动状态，则忽略此标志。</p>
<p><code>--checkpoints-metadata</code>标志确保在取消定义非活动域时清理任何检查点（参见checkpoint-list命令）。没有此标志，尝试取消定义具有检查点元数据的非活动域将失败。如果域处于活动状态，则忽略此标志。</p>
<p><code>--nvram</code>和<code>--keep-nvram</code>分别指定删除或保留nvram（&#x2F;domain&#x2F;os&#x2F;nvram&#x2F;）文件。如果域具有nvram文件且省略标志，则取消定义将失败。</p>
<p><code>--storage</code>标志接受参数卷，这是逗号分隔的卷目标名称或存储卷源路径列表，将与未定义的域一起删除。卷只能在非活动域上取消定义和删除。仅在域未定义后尝试删除卷；如果无法删除所有请求的卷，则错误消息指示仍保留的内容。如果卷路径未在域定义中找到，则视为卷已成功删除。只有由libvirt在存储池中管理的卷可以这种方式删除。请注意，这仅删除支持链的顶层映像，任何支持的存储将保留，因为它们可能共享。（参见domblklist以获取与域关联的目标名称列表）。示例：–storage vda,&#x2F;path&#x2F;to&#x2F;storage.img</p>
<p><code>--remove-all-storage</code>标志指定应删除域的所有存储卷，就像通过<code>--storage</code>指定一样。</p>
<p><code>--delete-storage-volume-snapshots</code>（以前为<code>--delete-snapshots</code>）标志指定也应删除与存储卷关联的任何快照。需要提供<code>--remove-all-storage</code>标志。并非所有存储驱动程序都支持此选项，目前仅rbd。在同时删除由不支持此标志的存储驱动程序处理的卷时使用此选项将导致失败。</p>
<p><code>--wipe-storage</code>标志指定在删除之前应擦除存储卷。</p>
<p><code>--tpm</code>和<code>--keep-tpm</code>分别指定删除或保留TPM的持久状态目录结构和文件。如果省略标志，则域XML中TPM模拟器定义中的persistent_state属性确定是否保留TPM状态。</p>
<p>注意：对于非活动域，必须使用域名或UUID作为<code>域名</code>。</p>
<hr>
<p><strong>vcpucount</strong><br><strong>语法：</strong><br>vcpucount 域名 [–maximum | –active] [–config | –live | –current] [–guest]<br>打印有关给定<code>域名</code>的虚拟CPU计数的信息。如果未指定标志，则以表格形式列出所有可能的计数；否则，输出仅限于请求的数值。由于历史原因，表格在可以通过<code>--active</code>标志单独查询的行上标记为”current”，而不是与<code>--current</code>标志相关。</p>
<p><code>--maximum</code>请求有关域可以通过setvcpus添加的vcpu最大上限的信息，而<code>--active</code>显示当前使用情况；这两个标志不能同时指定。<code>--config</code>需要持久客户机，并请求有关下次启动域时的信息，<code>--live</code>需要运行中的域并列出当前值，<code>--current</code>根据域的当前状态查询（如果运行中则为<code>--live</code>，如果非活动则为<code>--config</code>）；这三个标志互斥。</p>
<p>如果指定<code>--guest</code>，则从客户机的角度报告CPU计数。此标志仅适用于活动域，并且可能需要在客户机中配置客户代理。</p>
<hr>
<p><strong>vcpuinfo</strong><br><strong>语法：</strong><br>vcpuinfo 域名 [–pretty]<br>返回有关域虚拟CPU的基本信息，如vCPU数量、运行时间、与物理处理器的关联性。</p>
<p>使用<code>--pretty</code>时，CPU关联性显示为范围。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">virsh vcpuinfo fedora  </span><br><span class="line">VCPU: 0  </span><br><span class="line">CPU: 0  </span><br><span class="line">State: running  </span><br><span class="line">CPU time: 7,0s  </span><br><span class="line">CPU Affinity: yyyy  </span><br><span class="line">VCPU: 1  </span><br><span class="line">CPU: 1  </span><br><span class="line">State: running  </span><br><span class="line">CPU time: 0,7s  </span><br><span class="line">CPU Affinity: yyyy  </span><br></pre></td></tr></table></figure>
<p><strong>状态</strong></p>
<p>State字段显示虚拟CPU的当前操作状态：</p>
<ul>
<li>offline：虚拟CPU离线且不被域使用。并非所有虚拟机监控程序都支持此状态。</li>
<li>running：虚拟CPU可供域使用且正在运行。</li>
<li>blocked：虚拟CPU可供域使用但正在等待资源。并非所有虚拟机监控程序都支持此状态，在这种情况下可能报告为<em>running</em>。</li>
<li>no state：无法确定虚拟CPU状态。如果虚拟机监控程序比virsh新，则可能发生这种情况。</li>
<li>N&#x2F;A：没有关于虚拟CPU状态的信息可用。如果域未运行或虚拟机监控程序未报告虚拟CPU状态，则可能是这种情况。</li>
</ul>
<hr>
<p><strong>vcpupin</strong><br><strong>语法：</strong><br>vcpupin 域名 [vcpu] [cpulist] [ [–live] [–config] | [–current]]</p>
<p>查询或更改域VCPU与主机物理CPU的固定。要固定单个<code>vcpu</code>，指定<code>cpulist</code>；否则，可以查询一个<code>vcpu</code>或省略<code>vcpu</code>以一次列出所有。</p>
<p><code>cpulist</code>是物理CPU编号列表。其语法为逗号分隔的列表，也可以使用<code>-</code>和<code>^</code>的特殊标记（例如<code>0-4</code>、<code>0-3,^2</code>）。<code>-</code>表示范围，<code>^</code>表示排除。要将<code>vcpu</code>固定到所有物理CPU，指定<code>r</code>作为<code>cpulist</code>。如果指定<code>--live</code>，则影响运行中的客户机。如果指定<code>--config</code>，则影响持久客户机的下一次启动。如果指定<code>--current</code>，则根据客户机的当前状态等同于<code>--live</code>或<code>--config</code>。如果存在<code>cpulist</code>，则可以同时指定<code>--live</code>和<code>--config</code>标志，但<code>--current</code>是互斥的。如果未指定标志，则行为因虚拟机监控程序而异。</p>
<p>注意：表达式按顺序求值，因此”0-15,^8”与”9-14,0-7,15”相同，但与”^8,0-15”不同。</p>
<hr>
<p><strong>vncdisplay</strong><br><strong>语法：</strong><br>vncdisplay 域名</p>
<p>输出VNC显示的IP地址和端口号。如果信息不可用，进程将提供退出码1。</p>
<hr>
<h1 id="6-设备命令"><a href="#6-设备命令" class="headerlink" title="6 设备命令"></a>6 <strong>设备命令</strong></h1><p>以下命令用于操作与域关联的设备。<em>domain</em>可以指定为短整数、名称或完整的UUID。要更好地理解命令选项允许的值，请阅读文档 <a target="_blank" rel="noopener" href="https://libvirt.org/formatdomain.html">https://libvirt.org/formatdomain.html</a> 中关于设备部分的格式，以获取最准确的取值范围。</p>
<p><strong>attach-device</strong><br><strong>语法：</strong><br>attach-device domain FILE [ [ [–live] [–config] | [–current]] | [–persistent]]<br>将一个设备附加到域，使用XML文件中的设备定义（如&lt;disk&gt;或&lt;interface&gt;作为顶级元素）。有关libvirt设备XML格式的详细信息，请参阅 <a target="_blank" rel="noopener" href="https://libvirt.org/formatdomain.html#elementsDevices">https://libvirt.org/formatdomain.html#elementsDevices</a> 。如果指定<em>--config</em>，则命令会修改持久化客户机配置，设备附加操作将在下次libvirt启动域时生效。对于cdrom和floppy设备，此命令仅替换现有设备中的介质；建议使用update-device命令完成此操作。对于透传主机设备，如果PCI设备未使用托管模式，还需使用nodedev-detach命令。</p>
<p>如果指定<em>--live</em>，则影响正在运行的域。如果指定<em>--config</em>，则影响持久化客户机的下次启动。如果指定<em>--current</em>，则等同于<em>--live</em>或<em>--config</em>，具体取决于客户机的当前状态。<em>--live</em>和<em>--config</em>可以同时指定，但<em>--current</em>是互斥的。如果未指定任何标志，则使用遗留API，其行为取决于管理程序驱动。</p>
<p>出于兼容性考虑，<em>--persistent</em>对于离线域的行为类似于<em>--config</em>，对于运行中的域则类似于<em>--live</em> <em>--config</em>。</p>
<p>注意：使用部分设备定义XML文件可能导致意外结果，因为某些字段可能自动生成，从而匹配到非预期的设备。</p>
<hr>
<p><strong>attach-disk</strong><br><strong>语法：</strong><br>attach-disk domain source target [ [ [–live] [–config] |<br>   [–current]] | [–persistent]] [–targetbus bus]<br>   [–driver driver] [–subdriver subdriver] [–iothread iothread]<br>   [–cache cache] [–io io] [–type type] [–alias alias]<br>   [–mode mode] [–sourcetype sourcetype]<br>   [–source-protocol protocol] [–source-host-name hostname:port]<br>   [–source-host-transport transport] [–source-host-socket socket]<br>   [–serial serial] [–wwn wwn] [–rawio] [–address address]<br>   [–multifunction] [–print-xml] [–throttle-groups groups]</p>
<p>将新磁盘设备附加到域。<em>source</em>是文件或设备的路径，除非指定<em>--source-protocol</em>，此时<em>source</em>是网络磁盘的名称。<em>target</em>控制磁盘暴露给客户机操作系统的总线或设备，表示“逻辑”设备名称；可选的<em>targetbus</em>属性指定模拟的磁盘设备类型，可能的值取决于驱动，典型值包括<em>ide</em>、<em>scsi</em>、<em>virtio</em>、<em>xen</em>、<em>usb</em>、<em>sata</em>或<em>sd</em>。如果省略，总线类型将从设备名称的样式推断（例如，名为’sda’的设备通常通过SCSI总线导出）。<em>driver</em>可以是Xen管理程序的<em>file</em>、<em>tap</em>或<em>phy</em>，具体取决于访问类型；或QEMU模拟器的<em>qemu</em>。可以通过<em>subdriver</em>传递更多驱动细节。对于Xen，<em>subdriver</em>可以是<em>aio</em>；对于QEMU，<em>subdriver</em>应匹配磁盘源的格式，如<em>raw</em>或<em>qcow2</em>。如果未指定<em>subdriver</em>，则使用管理程序默认值。但默认值可能不正确，尤其是QEMU出于安全原因未配置为检测磁盘格式。<em>type</em>可以指定<em>lun</em>、<em>cdrom</em>或<em>floppy</em>作为磁盘默认值的替代，但此用法仅替换现有虚拟cdrom或floppy设备中的介质；建议改用update-device命令。<em>alias</em>可设置用户提供的别名。<em>mode</em>可指定两种特定模式<em>readonly</em>或<em>shareable</em>。<em>sourcetype</em>可指定源的类型（block|file|network）。<em>cache</em>可以是“default”、“none”、“writethrough”、“writeback”、“directsync”或“unsafe”之一。<em>io</em>控制I&#x2F;O的特定策略；QEMU客户机支持“threads”、“native”和“io_uring”。<em>iothread</em>是域IOThreads范围内可附加此磁盘的编号（仅限QEMU）。<em>serial</em>是磁盘设备的序列号。<em>wwn</em>是磁盘设备的WWN。<em>rawio</em>表示磁盘需要rawio能力。<em>address</em>是磁盘设备的地址，格式为pci:domain.bus.slot.function、scsi:controller.bus.unit、ide:controller.bus.unit、usb:bus.port、sata:controller.bus.unit或ccw:cssid.ssid.devno。Virtio-ccw设备的cssid必须设置为0xfe。<em>multifunction</em>表示指定的PCI地址是多功能PCI设备地址。<em>throttle-groups</em>是应用的节流组的逗号分隔列表。</p>
<p>还支持使用网络磁盘。如前所述，用户可以提供<em>--source-protocol</em>，此时<em>source</em>参数将被解释为源名称。如果用户打算提供网络磁盘或主机信息，则必须提供<em>--source-protocol</em>。主机信息可以使用标签<em>--source-host-name</em>、<em>--source-host-transport</em>和<em>--source-host-socket</em>提供，分别表示主机的名称、主机的传输方法和主机使用的套接字。<em>--source-host-socket</em>和<em>--source-host-name</em>不能同时提供，如果用户想提供<em>--source-host-socket</em>，则必须提供<em>--source-host-transport</em>。<em>--source-host-name</em>参数支持host:port语法，如果用户还想提供端口。</p>
<p>如果指定<em>--print-xml</em>，则打印将要附加的磁盘的XML，而不是实际附加磁盘。</p>
<p>如果指定<em>--live</em>，则影响正在运行的域。如果指定<em>--config</em>，则影响持久化客户机的下次启动。如果指定<em>--current</em>，则等同于<em>--live</em>或<em>--config</em>，具体取决于客户机的当前状态。<em>--live</em>和<em>--config</em>可以同时指定，但<em>--current</em>是互斥的。如果未指定任何标志，则使用遗留API，其行为取决于管理程序驱动。</p>
<p>出于兼容性考虑，<em>--persistent</em>对于离线域的行为类似于<em>--config</em>，对于运行中的域则类似于<em>--live</em> <em>--config</em>。同样，<em>--shareable</em>是<em>--mode shareable</em>的别名。</p>
<hr>
<p><strong>attach-interface</strong><br><strong>语法：</strong><br>attach-interface domain type source [ [ [–live]<br>   [–config] | [–current]] | [–persistent]]<br>   [–target target] [–mac mac] [–script script] [–model model]<br>   [–inbound average,peak,burst,floor] [–outbound average,peak,burst]<br>   [–alias alias] [–managed] [–print-xml]<br>   [–source-mode mode]</p>
<p>将新网络接口附加到域。<br>type可以是以下之一：<br><em>network</em>表示通过libvirt虚拟网络连接，<br><em>bridge</em>表示通过主机上的桥接设备连接，<br><em>direct</em>表示直接连接到主机的网络接口或桥接，<br><em>hostdev</em>表示使用主机上的PCI设备透传连接，<br><em>vhostuser</em>表示使用virtio传输协议连接。</p>
<p>source表示连接的源。源取决于接口类型：<br><em>network</em>虚拟网络的名称，<br><em>bridge</em>桥接设备的名称，<br><em>direct</em>主机接口或桥接的名称，<br><em>hostdev</em>主机接口的PCI地址，格式为domain:bus:slot.function，<br><em>vhostuser</em>UNIX套接字的路径（控制平面）。<br>--target用于指定用于将域连接到源的tap&#x2F;macvtap设备。以’vnet’开头的名称被视为自动生成，并在每次附加接口时被清除&#x2F;重新生成。<br>--mac指定网络接口的MAC地址；如果未提供MAC地址，将自动生成一个新地址（如果命令行中给出“--config”，则存储在持久化配置中）。<br>--script用于指定附加到桥接时调用的自定义脚本路径——这将替代默认脚本，而不是附加到默认脚本。此选项仅适用于<em>bridge</em>类型的接口和Xen域。<br>--model指定呈现给域的网络设备模型。<br>alias可设置用户提供的别名。<br>--inbound和--outbound控制接口的带宽。至少必须指定<em>average</em>、<em>floor</em>对中的一个。其他两个<em>peak</em>和<em>burst</em>是可选的，因此“average,peak”、“average,,burst”、“average,,,floor”、“average”和“,,,floor”也是合法的。<em>average</em>、<em>floor</em>和<em>peak</em>的值以千字节每秒表示，而<em>burst</em>以单次突发中的千字节数表示，如<a target="_blank" rel="noopener" href="https://libvirt.org/formatnetwork.html#quality-of-service">https://libvirt.org/formatnetwork.html#quality-of-service</a> 中所述。<br>--managed仅适用于<em>hostdev</em>类型，并告诉libvirt接口应被管理，这意味着libvirt会将其从主机分离并重新附加。<br>--source-mode对于<em>vhostuser</em>接口是必需的，接受值<em>server</em>和<em>client</em>，分别控制管理程序是等待其他进程连接还是发起连接。<br>如果指定--print-xml，则打印将要附加的接口的XML，而不是实际附加接口。<br>如果指定--live，则影响正在运行的域。如果指定--config，则影响持久化客户机的下次启动。如果指定--current，则影响域的当前状态（可以是运行中或离线）。--live和--config可以同时指定，但--current是互斥的。如果未指定任何标志，则使用遗留API，其行为取决于管理程序驱动。<br>出于兼容性考虑，--persistent对于离线域的行为类似于--config，对于运行中的域则类似于--live --config。<br>注意：可选的target值是节点上创建的作为后端设备的名称。如果未提供，将自动创建名为“vnetN”或“vifN”的设备。</p>
<hr>
<p><strong>detach-device</strong><br><strong>语法：</strong><br>detach-device domain FILE [ [ [–live] [–config] | [–current]] | [–persistent]]</p>
<p>从域中分离设备，使用与attach-device命令相同的XML描述。对于透传主机设备，如果设备未使用托管模式，还需使用nodedev-reattach命令。</p>
<p>注意：提供的设备XML描述应与其在域XML中的定义一样具体。用于匹配设备的属性集是驱动内部的。使用部分定义或尝试分离域XML中不存在但与现有设备共享某些特定属性的设备可能导致意外结果。</p>
<p>特性：设备拔出在大多数情况下是异步的，并且需要客户机配合。这意味着客户机可以任意拒绝或延迟拔出。由于此命令中使用的libvirt API设计为同步的，即使设备尚未拔出，它也会在超时后返回成功，以允许与域的进一步交互（例如，如果客户机无响应）。需要确保设备已拔出的调用者可以使用libvirt事件（参见virsh event）在设备移除时收到通知。注意，事件可能在命令返回之前到达。</p>
<p>如果指定<em>--live</em>，则影响正在运行的域。如果指定<em>--config</em>，则影响持久化客户机的下次启动。如果指定<em>--current</em>，则等同于<em>--live</em>或<em>--config</em>，具体取决于客户机的当前状态。<em>--live</em>和<em>--config</em>可以同时指定，但<em>--current</em>是互斥的。如果未指定任何标志，则使用遗留API，其行为取决于管理程序驱动。</p>
<p>出于兼容性考虑，<em>--persistent</em>对于离线域的行为类似于<em>--config</em>，对于运行中的域则类似于<em>--live</em> <em>--config</em>。</p>
<p>注意，旧版本的virsh使用<em>--config</em>作为<em>--persistent</em>的别名。</p>
<hr>
<p><strong>detach-device-alias</strong><br><strong>语法：</strong><br>detach-device-alias domain alias [ [ [–live] [–config] | [–current]]]</p>
<p>从<em>domain</em>中分离具有给定<em>alias</em>的设备。此命令在拔出请求发送到管理程序后成功返回。设备的实际移除通过libvirt事件异步通知（参见virsh event）。</p>
<p>如果指定<em>--live</em>，则影响正在运行的域。如果指定<em>--config</em>，则影响持久化客户机的下次启动。如果指定<em>--current</em>，则等同于<em>--live</em>或<em>--config</em>，具体取决于客户机的当前状态。<em>--live</em>和<em>--config</em>可以同时指定，但<em>--current</em>是互斥的。</p>
<hr>
<p><strong>detach-disk</strong><br><strong>语法：</strong><br>detach-disk domain target [ [ [–live] [–config] | [–current]] | [–persistent]] [–print-xml]<br>从域中分离磁盘设备。<em>target</em>是域中看到的设备。<br>如果指定<em>--live</em>，则影响正在运行的域。如果指定<em>--config</em>，则影响持久化客户机的下次启动。如果指定<em>--current</em>，则等同于<em>--live</em>或<em>--config</em>，具体取决于客户机的当前状态。<em>--live</em>和<em>--config</em>可以同时指定，但<em>--current</em>是互斥的。如果未指定任何标志，则使用遗留API，其行为取决于管理程序驱动。</p>
<p>出于兼容性考虑，<em>--persistent</em>对于离线域的行为类似于<em>--config</em>，对于运行中的域则类似于<em>--live</em> <em>--config</em>。</p>
<p>注意，旧版本的virsh使用<em>--config</em>作为<em>--persistent</em>的别名。</p>
<p>如果指定--print-xml，则打印用于分离磁盘的XML，而不是实际分离磁盘。</p>
<p>有关已知特性，请参阅detach-device的文档。</p>
<hr>
<p><strong>detach-interface</strong><br><strong>语法：</strong><br>detach-interface domain type [–mac mac] [ [ [–live] [–config] | [–current]] | [–persistent]] [–print-xml]</p>
<p>从域中分离网络接口。<em>type</em>可以是<em>network</em>表示物理网络设备，或<em>bridge</em>表示桥接到设备。如果域上有多个接口，建议使用<em>mac</em>选项区分它们。</p>
<p>如果指定<em>--live</em>，则影响正在运行的域。如果指定<em>--config</em>，则影响持久化客户机的下次启动。如果指定<em>--current</em>，则等同于<em>--live</em>或<em>--config</em>，具体取决于客户机的当前状态。<em>--live</em>和<em>--config</em>可以同时指定，但<em>--current</em>是互斥的。如果未指定任何标志，则使用遗留API，其行为取决于管理程序驱动。</p>
<p>出于兼容性考虑，<em>--persistent</em>对于离线域的行为类似于<em>--config</em>，对于运行中的域则类似于<em>--live</em> <em>--config</em>。</p>
<p>注意，旧版本的virsh使用<em>--config</em>作为<em>--persistent</em>的别名。</p>
<p>如果指定<em>--print-xml</em>，则打印用于分离接口的XML，而不是实际分离接口。</p>
<p>有关已知特性，请参阅detach-device的文档。</p>
<hr>
<p><strong>update-device</strong><br><strong>语法：</strong><br>update-device domain file [–force] [ [ [–live] [–config] | [–current]] | [–persistent] ]<br>根据XML <em>file</em>中的设备定义更新与<em>domain</em>关联的设备的特性。<em>--force</em>选项可用于强制更新设备，例如，即使CD-ROM在域中被锁定&#x2F;挂载，也可以弹出它。有关libvirt设备XML格式的详细信息，请参阅 <a target="_blank" rel="noopener" href="https://libvirt.org/formatdomain.html#elementsDevices%E3%80%82">https://libvirt.org/formatdomain.html#elementsDevices。</a></p>
<p>如果指定<em>--live</em>，则影响正在运行的域。如果指定<em>--config</em>，则影响持久化客户机的下次启动。如果指定<em>--current</em>，则等同于<em>--live</em>或<em>--config</em>，具体取决于客户机的当前状态。<em>--live</em>和<em>--config</em>可以同时指定，但<em>--current</em>是互斥的。未指定任何标志等同于指定<em>--current</em>。</p>
<p>出于兼容性考虑，<em>--persistent</em>对于离线域的行为类似于<em>--config</em>，对于运行中的域则类似于<em>--live</em> <em>--config</em>。</p>
<p>注意，旧版本的virsh使用<em>--config</em>作为<em>--persistent</em>的别名。</p>
<p>注意：使用部分设备定义XML文件可能导致意外结果，因为某些字段可能自动生成，从而匹配到非预期的设备。</p>
<hr>
<p><strong>update-memory-device</strong><br><strong>语法：</strong><br>update-memory-device domain [–print-xml] [ [–alias alias] | [–node node] ] [ [–live] [–config] | [–current] ] [–requested-size size]<br>此命令查找给定<em>domain</em>中的&lt;memory&#x2F;&gt;设备，更改请求的值，并将更新的设备XML传递给守护进程。如果指定<em>--print-xml</em>，则不更改设备，而是将更新的设备XML打印到stdout。如果<em>domain</em>中有多个&lt;memory&#x2F;&gt;设备，请使用<em>--alias</em>或<em>--node</em>选择所需的设备。</p>
<p>如果指定<em>--live</em>，则影响正在运行的域。如果指定<em>--config</em>，则影响持久化客户机的下次启动。如果指定<em>--current</em>，则等同于<em>--live</em>或<em>--config</em>，具体取决于客户机的当前状态。<em>--live</em>和<em>--config</em>可以同时指定，但<em>--current</em>是互斥的。未指定任何标志等同于指定<em>--current</em>。</p>
<p>如果指定<em>--requested-size</em>，则将内存目标下的&lt;requested&#x2F;&gt;更改为请求的<em>size</em>（作为比例整数，参见上面的NOTES）。如果没有提供后缀，则默认为kibibytes。此选项仅适用于virtio-mem内存设备模型。</p>
<hr>
<p><strong>change-media</strong><br><strong>语法：</strong><br>change-media domain path [–eject] [–insert] [–update] [source] [–force] [ [–live] [–config] | [–current] ] [–print-xml] [–block]</p>
<p>更改CDROM或软盘驱动器的介质。<em>path</em>可以是完全限定的路径或磁盘设备的唯一目标名称（&lt;target dev&#x3D;’hdc’&gt;）。<em>source</em>指定要插入或更新的介质的路径。<em>--block</em>标志允许在CDROM或软盘驱动器使用块设备作为介质（而不是文件）时设置后备类型。</p>
<p><em>--eject</em>表示将弹出介质。<em>--insert</em>表示将插入介质。必须指定<em>source</em>。如果设备有源（例如&lt;source file&#x3D;’media’&gt;），且未指定<em>source</em>，则<em>--update</em>等同于<em>--eject</em>。如果设备没有源，且指定了<em>source</em>，则<em>--update</em>等同于<em>--insert</em>。如果设备有源，且指定了<em>source</em>，则<em>--update</em>的行为类似于<em>--eject</em>和<em>--insert</em>的组合。如果未指定<em>--eject</em>、<em>--insert</em>和<em>--update</em>，则默认使用<em>--update</em>。<em>--force</em>选项可用于强制更改介质。如果指定<em>--live</em>，则修改运行中客户机的实时配置。如果指定<em>--config</em>，则修改持久化配置，效果在客户机下次启动时生效。<em>--current</em>可以是<em>live</em>或<em>config</em>，具体取决于管理程序的实现。<em>--live</em>和<em>--config</em>可以同时指定，但<em>--current</em>是互斥的。如果未指定任何标志，行为因管理程序而异。如果指定<em>--print-xml</em>，则打印用于更改介质的XML，而不是实际更改介质。</p>
<hr>
<p><strong>dom-fd-associate</strong><br><strong>语法：</strong><br>dom-fd-associate domain –name FDGROUPNAME –pass-fds M,N,…. [–seclabel-writable] [–seclabel-restore]</p>
<p>将<em>--pass-fds</em>参数描述的一个或多个fd作为<em>--name</em>关联到<em>domain</em>。传递的fd组的生命周期与连接相同，因此退出virsh后会取消注册它们。</p>
<p>默认情况下，如果需要，会应用安全标签，但为了避免不必要地保持打开状态，使用后不会恢复它们。可以通过使用<em>--seclabel-restore</em>标志请求尽力恢复安全标签。</p>
<hr>
<h1 id="7-节点设备命令"><a href="#7-节点设备命令" class="headerlink" title="7 节点设备命令"></a>7 <strong>节点设备命令</strong></h1><p>以下命令操作主机设备，这些设备旨在通过域&lt;devices&gt;部分中的&lt;hostdev&gt;元素传递给客户机域。节点设备键通常由总线名称后跟其地址指定，所有组件之间使用下划线分隔，例如pci_0000_00_02_1、usb_1_5_3或net_eth1_00_27_13_6a_fe_00。nodedev-list提供了libvirt已知的所有主机设备的完整列表，尽管这包括无法分配给客户机的设备（例如，尝试分离控制主机硬盘控制器的PCI设备，客户机的磁盘映像位于该硬盘上，可能导致主机系统锁定或重启）。</p>
<p>有关节点设备定义的更多信息，请参阅：<a target="_blank" rel="noopener" href="https://libvirt.org/formatnode.html%E3%80%82">https://libvirt.org/formatnode.html。</a></p>
<p>透传设备不能同时被主机及其客户机域使用，也不能被多个活动客户机同时使用。如果PCI设备的&lt;hostdev&gt;描述包含属性managed&#x3D;’yes’，并且管理程序驱动支持它，则设备处于托管模式，尝试在活动客户机中使用该透传设备将自动表现为在适当的时间调用nodedev-detach（客户机启动、设备热插拔）和nodedev-reattach（客户机停止、设备热拔出）。如果PCI设备未标记为托管，则必须手动分离才能供客户机使用，并手动重新附加才能返回主机。此外，如果设备是手动分离的，则即使客户机在托管模式下使用该设备，主机也无法重新获得控制权，除非有匹配的reattach操作。</p>
<hr>
<p><strong>nodedev-create</strong><br><strong>语法：</strong><br>nodedev-create FILE [–validate]<br>在主机节点上创建一个设备，然后可以将其分配给虚拟机。通常，libvirt能够自动确定哪些主机节点可用，但此命令允许注册libvirt未自动检测到的主机硬件。<em>file</em>包含节点设备的顶级&lt;device&gt;描述的XML。<br>如果指定<em>--validate</em>，则根据内部RNG模式验证XML文档的格式。</p>
<hr>
<p><strong>nodedev-update</strong><br><strong>语法：</strong><br>nodedev-update device FILE [ [–live] [–config] | [–current] ]<br>更新主机上的设备。<em>device</em>可以是设备名称或“wwnn,wwpn”格式的wwn对（目前仅适用于vHBA）。<em>file</em>包含节点设备的顶级&lt;device&gt;描述的XML。<em>--current</em>可以是<em>live</em>或<em>config</em>，具体取决于管理程序的实现。<em>--live</em>和<em>--config</em>可以同时指定，但<em>--current</em>是互斥的。如果未指定任何标志，行为因管理程序而异。</p>
<hr>
<p><strong>nodedev-destroy</strong><br><strong>语法：</strong><br>nodedev-destroy device<br>销毁（停止）主机上的设备。<em>device</em>可以是设备名称或“wwnn,wwpn”格式的wwn对（目前仅适用于vHBA）。注意，这会使libvirt停止管理主机设备，甚至可能使该设备在物理主机上不可用，直到重新启动。</p>
<hr>
<p><strong>nodedev-define</strong><br><strong>语法：</strong><br>nodedev-define FILE [–validate]<br>从XML <em>FILE</em>定义非活动持久化设备或修改现有持久化设备。<br>如果指定<em>--validate</em>，则根据内部RNG模式验证XML文档的格式。</p>
<hr>
<p><strong>nodedev-undefine</strong><br><strong>语法：</strong><br>nodedev-undefine device<br>取消持久化设备的配置。如果设备处于活动状态，则使其变为临时设备。</p>
<hr>
<p><strong>nodedev-start</strong><br><strong>语法：</strong><br>nodedev-start device<br>启动（先前定义的）非活动设备。</p>
<hr>
<p><strong>nodedev-detach</strong><br><strong>语法：</strong><br>nodedev-detach nodedev [–driver backend_driver]<br>将<em>nodedev</em>从主机驱动分离，并绑定到一个特殊驱动，该驱动提供管理程序将设备分配给虚拟机（使用域XML定义中的&lt;hostdev&gt;）所需的API。此操作通过nodedev-reattach反转，并由管理程序驱动对托管设备（其XML定义中具有“managed&#x3D;’yes’”的设备）自动完成。</p>
<p>不同的管理程序期望被分配的设备绑定到不同的驱动。例如，QEMU的“vfio”后端要求设备绑定到驱动“vfio-pci”或“VFIO变体”驱动（这是一个支持vfio-pci提供的完整API以及其他API以支持实时迁移等功能的驱动）。<em>--driver</em>参数可用于指定设备应绑定到的特定驱动（例如，设备特定的VFIO变体驱动）。当省略<em>--driver</em>时，使用管理程序的默认驱动（QEMU为“vfio-pci”，Xen为“pciback”）。</p>
<hr>
<p><strong>nodedev-dumpxml</strong><br><strong>语法：</strong><br>nodedev-dumpxml [–inactive] [–xpath EXPRESSION] [–wrap] device<br>转储给定节点设备的&lt;device&gt; XML表示，包括设备名称、拥有设备的总线、供应商和产品ID以及libvirt可用的任何设备功能（例如是否支持设备重置）。<em>device</em>可以是设备名称或“wwnn,wwpn”格式的wwn对（仅适用于HBA）。可以使用影响XML转储的附加选项。<em>--inactive</em>告诉virsh转储节点设备下次启动时将使用的配置，而不是当前节点设备配置。</p>
<p>如果 <strong>--xpath</strong> 参数提供了XPath表达式，则将对输出XML求值，并仅打印匹配的节点。默认行为是将每个匹配节点打印为独立文档，但为了方便进一步处理，<strong>--wrap</strong>参数将使匹配节点包装在公共根节点中。</p>
<hr>
<p><strong>nodedev-info</strong><br><strong>语法：</strong><br>nodedev-info device<br>返回关于<em>device</em>对象的基本信息。</p>
<hr>
<p><strong>nodedev-list</strong><br><strong>语法：</strong><br>nodedev-list [–cap capability] [–tree] [–inactive | –all] [–persistent | –transient]<br>列出节点上libvirt已知的所有可用设备。<em>cap</em>用于按功能类型过滤列表，类型必须用逗号分隔，例如--cap pci,scsi。有效的功能类型包括’system’、’pci’、’usb_device’、’usb’、’net’、’scsi_host’、’scsi_target’、’scsi’、’storage’、’fc_host’、’vports’、’scsi_generic’、’drm’、’mdev’、’mdev_types’、’ccw’、’ccwgroup’、’ccwgroup_member’、’css’、’ap_card’、’ap_queue’、’ap_matrix’。默认情况下，仅列出活动设备。<em>--inactive</em>用于仅列出非活动设备，<em>--all</em>用于列出活动和非活动设备。<em>--persistent</em>用于仅列出持久化设备，<em>--transient</em>用于仅列出临时设备。不提供<em>--persistent</em>或<em>--transient</em>将列出所有设备，除非另有过滤。<em>--transient</em>与<em>--persistent</em>和<em>--inactive</em>互斥。如果使用<em>--tree</em>，则输出格式化为表示每个节点父节点的树。<em>--tree</em>与除<em>--all</em>之外的所有其他选项互斥。</p>
<hr>
<p><strong>nodedev-reattach</strong><br><strong>语法：</strong><br>nodedev-reattach nodedev<br>声明<em>nodedev</em>不再被任何客户机使用，主机可以恢复设备的正常使用。对于托管模式的PCI设备和USB设备，此操作是自动完成的，但必须显式调用以匹配任何显式的nodedev-detach。</p>
<hr>
<p><strong>nodedev-reset</strong><br><strong>语法：</strong><br>nodedev-reset nodedev<br>触发<em>nodedev</em>的设备重置，在将节点设备在客户机透传和主机之间传输之前非常有用。Libvirt通常会在需要时隐式执行此操作，但此命令允许在需要时显式重置。</p>
<hr>
<p><strong>nodedev-event</strong><br><strong>语法：</strong><br>nodedev-event { [nodedev ] event [–loop] [–timeout seconds] [–timestamp] | –list}<br>等待一类节点设备事件发生，并在事件发生时打印适当的详细信息。事件可以选择由<em>nodedev</em>过滤。仅使用<em>--list</em>作为参数将提供此客户端已知的可能<em>event</em>值列表，尽管连接可能不允许注册所有这些事件。</p>
<p>默认情况下，此命令是一次性的，一旦事件发生即返回成功；您可以发送SIGINT（通常通过Ctrl-C）立即退出。如果指定<em>--timeout</em>，则命令在<em>seconds</em>后放弃等待事件。使用<em>--loop</em>，命令将打印所有事件，直到超时或中断键。</p>
<p>当使用<em>--timestamp</em>时，将在事件之前打印人类可读的时间戳。</p>
<hr>
<p><strong>nodedev-autostart</strong><br><strong>语法：</strong><br>nodedev-autostart [–disable ] device<br>配置设备在主机启动或父设备可用时自动启动。使用<em>--disable</em>，设备将设置为手动模式，不再由主机自动启动。此命令仅支持持久化定义的介导设备。</p>
<hr>
<h1 id="8-虚拟网络命令"><a href="#8-虚拟网络命令" class="headerlink" title="8 虚拟网络命令"></a>8 <strong>虚拟网络命令</strong></h1><p>以下命令用于操作网络。Libvirt具备定义虚拟网络的能力，这些虚拟网络可被域（domain）使用并与实际网络设备连接。关于此功能的详细信息，请参阅文档：<a target="_blank" rel="noopener" href="https://libvirt.org/formatnetwork.html">https://libvirt.org/formatnetwork.html</a> 。许多虚拟网络命令与域命令类似，但虚拟网络的命名方式是通过其名称或UUID。</p>
<hr>
<p><strong>net-autostart</strong><br><strong>语法：</strong><br>net-autostart 网络 [--disable]<br>配置虚拟网络在启动时自动启动。使用<em>--disable</em>选项可禁用自动启动功能。</p>
<hr>
<p><strong>net-create</strong><br><strong>语法：</strong><br>net-create 文件 [--validate]<br>根据XML<em>文件</em>创建一个临时（transient）虚拟网络并实例化（启动）该网络。关于libvirt使用的XML网络格式描述，请参阅文档：<a target="_blank" rel="noopener" href="https://libvirt.org/formatnetwork.html%E3%80%82">https://libvirt.org/formatnetwork.html。</a></p>
<p>可选地，可以通过<em>--validate</em>验证输入XML文件的格式是否符合内部RNG模式。</p>
<hr>
<p><strong>net-define</strong><br><strong>语法：</strong><br>net-define 文件 [--validate]<br>根据XML<em>文件</em>定义一个非活动的持久虚拟网络或修改现有的持久网络。可选地，可以通过<em>--validate</em>验证输入XML文件的格式是否符合内部RNG模式。</p>
<hr>
<p><strong>net-desc</strong><br><strong>语法：</strong><br>net-desc 网络 [ [–live] [–config] | [–current] ] [–title] [–edit] [–new-desc 新描述或标题消息]</p>
<p>显示或修改网络的描述和标题。这些值是用户字段，允许存储任意文本数据以便轻松识别网络。标题应简短，但未强制要求。（另请参阅net-metadata，该命令用于操作基于XML的网络元数据。）</p>
<p>标志<em>--live</em>或<em>--config</em>选择此命令是作用于网络的实时定义还是持久定义。如果同时指定<em>--live</em>和<em>--config</em>，则在获取当前描述时，<em>--config</em>选项优先；而在设置描述时，实时配置和持久配置均会更新。<em>--current</em>是独占选项，如果未指定任何标志，则默认为此选项。</p>
<p>标志<em>--edit</em>指定打开包含当前描述或标题的编辑器，并在编辑后保存内容。</p>
<p>标志<em>--title</em>选择操作标题字段而非描述字段。</p>
<p>如果未指定<em>--edit</em>和<em>--new-desc</em>，则显示备注或描述而非修改。</p>
<hr>
<p><strong>net-destroy</strong><br><strong>语法：</strong><br>net-destroy 网络<br>立即销毁（停止）指定的临时或持久虚拟网络，网络通过名称或UUID指定。</p>
<hr>
<p><strong>net-dumpxml</strong><br><strong>语法：</strong><br>net-dumpxml [–inactive] [–xpath 表达式] [–wrap] 网络<br>将虚拟网络信息以XML格式输出到标准输出。如果指定<em>--inactive</em>，则物理功能不会扩展为其关联的虚拟功能。</p>
<p>如果提供 <strong>--xpath</strong> 参数和XPath表达式，则会对输出XML进行评估，并仅打印匹配的节点。默认行为是将每个匹配节点作为独立文档打印，但为了方便进一步处理，<strong>--wrap</strong>参数会将匹配节点包装在公共根节点中。</p>
<hr>
<p><strong>net-edit</strong><br><strong>语法：</strong><br>net-edit 网络<br>编辑网络的XML配置文件。</p>
<p>此命令等效于：</p>
<p>virsh net-dumpxml --inactive 网络 &gt; 网络.xml<br>vi 网络.xml（或使用其他文本编辑器修改）<br>virsh net-define 网络.xml  </p>
<p>不同之处在于它会进行一些错误检查。</p>
<p>使用的编辑器可通过环境变量$VISUAL或$EDITOR指定，默认为vi。</p>
<hr>
<p><strong>net-event</strong><br><strong>语法：</strong><br>net-event {[网络] 事件 [–loop] [–timeout 秒数] [–timestamp] | –list}<br>等待一类网络事件发生，并在事件发生时打印相关详细信息。事件可以通过<em>网络</em>进行筛选。仅使用<em>--list</em>作为参数时，将列出此客户端已知的可能<em>事件</em>值，但连接可能不允许注册所有这些事件。</p>
<p>默认情况下，此命令是一次性的，事件发生后即返回成功；可通过发送SIGINT（通常为Ctrl-C）立即退出。如果指定<em>--timeout</em>，则命令在<em>秒数</em>后放弃等待事件。使用<em>--loop</em>时，命令会打印所有事件，直到超时或中断。</p>
<p>当使用<em>--timestamp</em>时，会在事件前打印人类可读的时间戳。</p>
<hr>
<p><strong>net-info</strong><br><strong>语法：</strong><br>net-info 网络<br>返回关于<em>网络</em>对象的基本信息。</p>
<hr>
<p><strong>net-list</strong><br><strong>语法：</strong><br>net-list [–inactive | –all]<br>{ [–table] | –name | –uuid }<br>[–persistent] [–transient]<br>[–autostart] [–no-autostart]<br>[–title]</p>
<p>返回活动网络的列表。如果指定<em>--all</em>，则还包括已定义但非活动的网络；如果指定<em>--inactive</em>，则仅列出非活动网络。还可以通过<em>--persistent</em>筛选持久网络，<em>--transient</em>筛选临时网络，<em>--autostart</em>筛选启用自动启动的网络，<em>--no-autostart</em>筛选禁用自动启动的网络。</p>
<p>如果指定<em>--name</em>，则打印网络名称，每行一个。如果指定<em>--uuid</em>，则打印网络UUID而非名称。标志<em>--table</em>指定使用传统的表格格式输出，这是默认行为。这些选项互斥。</p>
<p>如果指定<em>--title</em>，则会在额外列中打印简短的网络描述（标题）。此标志仅适用于默认的<em>--table</em>输出。</p>
<p>注意：在与旧服务器通信时，此命令被迫使用一系列API调用，存在竞争条件，可能导致池未被列出或多次出现，如果在调用期间池状态发生变化。新服务器无此问题。</p>
<hr>
<p><strong>net-metadata</strong><br><strong>语法：</strong><br>net-metadata 网络 [ [–live] [–config] | [–current] ]<br>[–edit] [uri] [key] [set] [–remove]</p>
<p>显示或修改网络的自定义XML元数据。元数据是用户定义的XML，允许在网络定义中存储任意XML数据。可以在网络XML中存储多个独立的自定义元数据片段，这些片段通过<em>uri</em>参数提供的私有XML命名空间标识。（另请参阅net-desc，该命令用于操作网络的文本元数据，如标题和描述。）</p>
<p>标志<em>--live</em>或<em>--config</em>选择此命令是作用于网络的实时定义还是持久定义。如果同时指定<em>--live</em>和<em>--config</em>，则在获取当前描述时，<em>--config</em>选项优先；而在设置描述时，实时配置和持久配置均会更新。<em>--current</em>是独占选项，如果未指定任何标志，则默认为此选项。</p>
<p>标志<em>--remove</em>指定通过<em>uri</em>参数标识的元数据元素应被删除而非更新。</p>
<p>标志<em>--edit</em>指定打开包含通过<em>uri</em>参数标识的元数据的编辑器，并在编辑后保存内容。否则，可以通过<em>set</em>参数提供新内容。</p>
<p>通过<em>--edit</em>或<em>set</em>设置元数据时，必须指定<em>key</em>参数，用于将自定义元素前缀绑定到私有命名空间。</p>
<p>如果未指定<em>--edit</em>和<em>set</em>，则显示与<em>uri</em>命名空间对应的XML元数据而非修改。</p>
<hr>
<p><strong>net-name</strong><br><strong>语法：</strong><br>net-name 网络-UUID<br>将网络UUID转换为网络名称。</p>
<hr>
<p><strong>net-start</strong><br><strong>语法：</strong><br>net-start 网络<br>启动一个（先前定义的）非活动网络。</p>
<hr>
<p><strong>net-undefine</strong><br><strong>语法：</strong><br>net-undefine 网络<br>取消持久网络的配置定义。如果网络处于活动状态，则将其转为临时网络。</p>
<hr>
<p><strong>net-uuid</strong><br><strong>语法：</strong><br>net-uuid 网络名称<br>将网络名称转换为网络UUID。</p>
<hr>
<p><strong>net-update</strong><br><strong>语法：</strong><br>net-update 网络 命令 部分 xml<br>[–parent-index 索引 ] [ [–live] [ –config ] | [ –current ] ]</p>
<p>更新现有网络定义的指定部分，更改可立即生效，无需销毁和重新启动网络。</p>
<p><em>命令</em>可以是“add-first”、“add-last”、“add”（add-last的同义词）、“delete”或“modify”。</p>
<p><em>部分</em>可以是“bridge”、“domain”、“ip”、“ip-dhcp-host”、“ip-dhcp-range”、“forward”、“forward-interface”、“forward-pf”、“portgroup”、“dns-host”、“dns-txt”或“dns-srv”，每个部分通过XML元素层次结构的连接命名。例如，“ip-dhcp-host”会更改网络XML中&lt;ip&gt;元素内&lt;dhcp&gt;元素内的&lt;host&gt;元素。</p>
<p><em>xml</em>可以是完整XML元素的文本（例如“&lt;host mac&#x3D;’00:11:22:33:44:55’ ip&#x3D;’1.2.3.4’&#x2F;&gt;”），或包含完整XML元素的文件名。通过查看提供的文本的第一个字符来区分：如果是“&lt;”，则为XML文本；否则为包含XML文本的文件名。</p>
<p><em>--parent-index</em>选项用于指定父元素的索引（从0开始）。例如，dhcp &lt;host&gt;元素可能位于网络中的多个&lt;ip&gt;元素之一；如果未提供父索引，则会选择“最合适”的&lt;ip&gt;元素（通常是已包含&lt;dhcp&gt;元素的唯一一个），但如果指定<em>--parent-index</em>，则会修改该特定&lt;ip&gt;实例。</p>
<p>如果指定<em>--live</em>，则影响运行中的网络；如果指定<em>--config</em>，则影响持久网络的下次启动；如果指定<em>--current</em>，则等同于<em>--live</em>或<em>--config</em>，具体取决于网络的当前状态。可以同时指定<em>--live</em>和<em>--config</em>，但<em>--current</em>是独占的。未指定任何标志等同于指定<em>--current</em>。</p>
<hr>
<p><strong>net-dhcp-leases</strong><br><strong>语法：</strong><br>net-dhcp-leases 网络 [mac]<br>获取连接到指定虚拟<em>网络</em>的所有网络接口的DHCP租约列表，如果指定<em>mac</em>，则仅输出该接口的信息。</p>
<hr>
<h1 id="9-网络端口命令"><a href="#9-网络端口命令" class="headerlink" title="9 网络端口命令"></a>9 <strong>网络端口命令</strong></h1><p>以下命令用于操作网络端口。当虚拟机添加虚拟网络接口时，Libvirt虚拟网络会创建端口。通常无需使用这些命令，因为虚拟机生命周期中的相关操作由管理程序驱动自动完成。这些命令主要用于调试问题或从错误&#x2F;残留状态中恢复。</p>
<p><strong>net-port-list</strong><br><strong>语法：</strong><br>net-port-list { [--table] | --uuid } 网络<br>列出网络中记录的所有端口。<br>如果指定<em>--uuid</em>，则打印端口的UUID而非表格。标志<em>--table</em>指定使用传统的表格格式输出，此为默认行为。这些选项互斥。</p>
<hr>
<p><strong>net-port-create</strong><br><strong>语法：</strong><br>net-port-create 网络 文件 [--validate]<br>根据端口描述分配新网络端口并预留资源。可选地，可通过<em>--validate</em>验证输入XML文件的格式是否符合内部RNG模式。</p>
<hr>
<p><strong>net-port-dumpxml</strong><br><strong>语法：</strong><br>net-port-dumpxml [--xpath 表达式] [--wrap] 网络 端口<br>将端口信息以XML格式输出到标准输出。<br>如果提供 <strong>--xpath</strong> 参数和XPath表达式，则会对输出XML进行评估，仅打印匹配的节点。默认行为是将每个匹配节点作为独立文档打印，但<strong>--wrap</strong>参数会将匹配节点包装在公共根节点中以便后续处理。</p>
<hr>
<p><strong>net-port-delete</strong><br><strong>语法：</strong><br>net-port-delete 网络 端口<br>删除端口记录并释放其资源。</p>
<hr>
<h1 id="10-接口命令"><a href="#10-接口命令" class="headerlink" title="10 接口命令"></a>10 <strong>接口命令</strong></h1><p>以下命令用于操作主机接口。这些接口通常可被域（domain）的&lt;interface&gt;元素按名称引用（如系统创建的桥接接口），但主机接口无需与任何特定虚拟机配置绑定。</p>
<p>许多主机接口命令与域命令类似，接口可通过名称或MAC地址指定。但仅当MAC地址唯一时才能作为<em>iface</em>参数使用（若接口与桥接设备MAC地址相同，则会导致歧义错误，此时必须改用名称）。</p>
<p><strong>iface-bridge</strong><br><strong>语法：</strong><br>iface-bridge 接口 桥接 [--no-stp] [延迟] [--no-start]<br>创建名为<em>桥接</em>的桥接设备，并将现有网络设备<em>接口</em>附加到该桥接。新桥接默认立即启动，启用STP且延迟为0秒；可通过<em>--no-stp</em>、<em>--no-start</em>和<em>延迟</em>（整数秒）调整设置。<em>接口</em>的所有IP配置将迁移至新桥接设备。</p>
<p>（撤销操作请参阅iface-unbridge。）</p>
<hr>
<p><strong>iface-define</strong><br><strong>语法：</strong><br>iface-define 文件 [--validate]<br>根据XML<em>文件</em>定义非活动的持久主机接口或修改现有持久接口。可选地，可通过<em>--validate</em>验证输入XML文件的格式是否符合内部RNG模式。</p>
<hr>
<p><strong>iface-destroy</strong><br><strong>语法：</strong><br>iface-destroy 接口<br>立即销毁（停止）主机接口（如通过”if-down”禁用接口）。</p>
<hr>
<p><strong>iface-dumpxml</strong><br><strong>语法：</strong><br>iface-dumpxml [--inactive] [--xpath 表达式] [--wrap] 接口<br>将接口信息以XML格式输出到标准输出。若指定<em>--inactive</em>，则输出反映接口下次启动时将使用的持久状态。</p>
<p>若提供 <strong>--xpath</strong>参数和XPath表达式，则会对输出XML进行评估，仅打印匹配的节点。<strong>--wrap</strong>参数会将匹配节点包装在公共根节点中。</p>
<hr>
<p><strong>iface-edit</strong><br><strong>语法：</strong><br>iface-edit 接口<br>编辑主机接口的XML配置文件。<br>此命令等效于：<br>virsh iface-dumpxml 接口 &gt; 接口.xml<br>vi 接口.xml（或使用其他编辑器修改）<br>virsh iface-define 接口.xml  </p>
<p>不同之处在于它会进行错误检查。使用的编辑器由$VISUAL或$EDITOR环境变量指定，默认为vi。</p>
<hr>
<p><strong>iface-list</strong><br><strong>语法：</strong><br>iface-list [--inactive | --all]<br>返回活动接口列表。若指定<em>--all</em>，则包括已定义但非活动的接口；若指定<em>--inactive</em>，则仅列出非活动接口。</p>
<hr>
<p><strong>iface-name</strong><br><strong>语法：</strong><br>iface-name 接口<br>将主机接口的MAC地址转换为接口名称（仅当MAC地址唯一时有效）。</p>
<p><em>接口</em>参数为MAC地址。</p>
<hr>
<p><strong>iface-mac</strong><br><strong>语法：</strong><br>iface-mac 接口<br>将主机接口名称转换为MAC地址。</p>
<p><em>接口</em>参数为接口名称。</p>
<hr>
<p><strong>iface-start</strong><br><strong>语法：</strong><br>iface-start 接口<br>启动已定义的主机接口（如通过”if-up”）。</p>
<hr>
<p><strong>iface-unbridge</strong><br><strong>语法：</strong><br>iface-unbridge 桥接 [--no-start]<br>拆除名为<em>桥接</em>的桥接设备，释放底层接口并恢复其正常用途，同时将所有IP配置从桥接设备移回底层接口。除非指定<em>--no-start</em>，否则将重启底层接口（此选项仅为对称设计，通常不建议使用）。</p>
<p>（创建桥接请参阅iface-bridge。）</p>
<hr>
<p><strong>iface-undefine</strong><br><strong>语法：</strong><br>iface-undefine 接口<br>取消非活动主机接口的配置定义。</p>
<hr>
<p><strong>iface-begin</strong><br><strong>语法：</strong><br>iface-begin<br>创建当前主机接口设置的快照，后续可提交（<em>iface-commit</em>）或回滚（<em>iface-rollback</em>）。若快照已存在，则命令将失败直至前一个快照被提交或回滚。若在快照创建后、提交&#x2F;回滚前通过非libvirt API修改接口设置，将导致未定义行为。</p>
<hr>
<p><strong>iface-commit</strong><br><strong>语法：</strong><br>iface-commit<br>确认自上次<em>iface-begin</em>后的所有更改有效，并删除回滚点。若无快照则命令失败。</p>
<hr>
<p><strong>iface-rollback</strong><br><strong>语法：</strong><br>iface-rollback<br>将主机接口设置回滚至上一次<em>iface-begin</em>的状态。若无快照则命令失败。主机重启也会隐式触发回滚。</p>
<hr>
<h1 id="11-存储池命令"><a href="#11-存储池命令" class="headerlink" title="11 存储池命令"></a>11 <strong>存储池命令</strong></h1><p>以下命令用于操作存储池。Libvirt 能够管理多种存储解决方案，包括文件、原始分区和特定域格式的存储，这些存储为虚拟机内的设备提供存储卷。有关此功能的更多详细信息，请参阅文档：<a target="_blank" rel="noopener" href="https://libvirt.org/formatstorage.html">https://libvirt.org/formatstorage.html</a> 。许多存储池命令与用于域的类似。</p>
<p><strong>find-storage-pool-sources</strong><br><strong>语法：</strong><br>find-storage-pool-sources 类型 [srcSpec]<br>返回描述所有可能可用存储池源的 XML，这些源可用于创建或定义指定<em>类型</em>的存储池。如果提供了 srcSpec，则它是一个包含 XML 的文件，用于进一步限制对存储池的查询。</p>
<p>并非所有存储池都支持这种发现方式。此外，对于支持发现的存储池，仅需要特定的 XML 元素来返回有效数据，而其他元素甚至某些元素的属性会被忽略，因为它们不是基于搜索条件查找存储池所必需的。以下列出了支持的<em>类型</em>选项以及用于执行搜索的最小 XML 元素。</p>
<ul>
<li>对于 <code>netfs</code> 或 <code>gluster</code> 存储池，最小需要的 XML 是带有描述 IP 地址或主机名的 <code>name</code> 属性的 <code>&lt;host&gt;</code> 元素，用于查找存储池。<code>port</code> 属性将被忽略，<code>srcSpec</code> 中提供的任何其他 XML 元素也会被忽略。</li>
<li>对于 <code>logical</code> 存储池，<code>srcSpec</code> 文件的内容会被忽略，但如果提供了该文件，则文件必须至少存在。</li>
<li>对于 <code>iscsi</code> 或 <code>iscsi-direct</code> 存储池，最小需要的 XML 是带有描述 IP 地址或主机名的 <code>name</code> 属性的 <code>&lt;host&gt;</code> 元素（iSCSI 服务器地址）。可选地，可以提供 <code>port</code> 属性（默认为 3260）。此外，可以提供一个带有 <code>name</code> 属性的 <code>&lt;initiator&gt;</code> XML 元素，以进一步将 iSCSI 目标搜索限制为特定发起者（用于多 IQN iSCSI 存储池）。</li>
</ul>
<hr>
<p><strong>find-pool-sources-as</strong><br><strong>语法：</strong><br>find-storage-pool-sources-as 类型 [主机] [端口] [发起者]<br>此命令选项用于替代 <code>find-storage-pool-sources</code> 的 <code>srcSpec</code> XML 文件，通过可选参数生成查询 XML 文件。该命令将返回与 <code>find-storage-pool-sources</code> 相同的输出 XML。</p>
<ul>
<li>使用 <code>主机</code> 指定用于网络存储（如 <code>netfs</code>、<code>gluster</code> 和 <code>iscsi</code> 类型存储池）的特定主机。</li>
<li>使用 <code>端口</code> 进一步限制网络端口（如果特定存储后端需要，如 <code>iscsi</code>）。</li>
<li>使用 <code>发起者</code> 进一步将 <code>iscsi</code> 类型存储池的搜索限制为特定目标发起者。</li>
</ul>
<hr>
<p><strong>pool-autostart</strong><br><strong>语法：</strong><br>pool-autostart 池名或 UUID [–disable]<br>配置<em>池</em>是否应在启动时自动启动。</p>
<hr>
<p><strong>pool-build</strong><br><strong>语法：</strong><br>pool-build 池名或 UUID [–overwrite] [–no-overwrite]<br>构建指定的存储池。<br>选项 <code>--overwrite</code> 和 <code>--no-overwrite</code> 仅适用于文件系统、磁盘或逻辑存储池的 <code>pool-build</code> 操作。</p>
<ul>
<li>对于文件系统存储池，如果未指定任何标志，则 <code>pool-build</code> 仅创建目标路径目录，不会尝试在目标卷设备上运行 <code>mkfs</code>。如果指定 <code>--no-overwrite</code>，则会探测目标设备上是否已存在文件系统，如果存在则返回错误，否则使用 <code>mkfs</code> 格式化目标设备。如果指定 <code>--overwrite</code>，则始终执行 <code>mkfs</code>，并无条件覆盖目标设备上的任何现有数据。</li>
<li>对于磁盘存储池，如果未指定任何标志或指定 <code>--no-overwrite</code>，<code>pool-build</code> 将在尝试在目标卷设备上写入新标签之前检查目标卷设备上是否存在文件系统或分区。如果目标卷设备已有标签，则命令将失败。如果指定 <code>--overwrite</code>，则在写入新标签之前不会检查目标卷设备。标签写入使用存储池源格式类型，如果未指定则使用 <code>dos</code>。</li>
<li>对于逻辑存储池，如果未指定任何标志或指定 <code>--no-overwrite</code>，<code>pool-build</code> 将在尝试初始化和格式化每个设备以供逻辑存储池使用之前检查目标卷设备上是否存在文件系统或分区。如果任何目标卷设备已有标签，则命令将失败。如果指定 <code>--overwrite</code>，则在初始化和格式化每个设备之前不会进行检查。所有目标卷设备通过 <code>pvcreate</code> 正确格式化后，将使用所有设备创建卷组。</li>
</ul>
<hr>
<p><strong>pool-create</strong><br><strong>语法：</strong><br>pool-create 文件 [–build] [ [–overwrite] | [–no-overwrite]]<br>从 XML <em>文件</em>创建并启动存储池对象。</p>
<p>[<code>--build</code>] [ [<code>--overwrite</code>] | [<code>--no-overwrite</code>]] 在创建后执行 <code>pool-build</code>，以避免后续需要单独运行构建命令。<code>--overwrite</code> 和 <code>--no-overwrite</code> 标志的规则与 <code>pool-build</code> 相同。如果仅提供 <code>--build</code>，则调用 <code>pool-build</code> 时不带任何标志。</p>
<hr>
<p><strong>pool-create-as</strong><br><strong>语法：</strong><br>pool-create-as 名称 类型<br>[–source-host 主机名] [–source-path 路径] [–source-dev 路径]<br>[–source-name 名称] [–target 路径] [–source-format 格式]<br>[–source-initiator 发起者-IQN]<br>[–auth-type 认证类型 –auth-username 用户名<br>[–secret-usage 用途 | –secret-uuid UUID]]<br>[–source-protocol-ver 版本]<br>[ [–adapter-name 名称] | [–adapter-wwnn WWNN –adapter-wwpn WWPN<br>[–adapter-parent 父设备 |<br>–adapter-parent-wwnn 父设备-WWNN –adapter-parent-wwpn 父设备-WWPN |<br>–adapter-parent-fabric-wwn 父设备-光纤-WWN] ] ]<br>[–build] [ [–overwrite] | [–no-overwrite] ] [–print-xml]</p>
<p>从原始参数创建并启动存储池对象<em>名称</em>。如果指定 <code>--print-xml</code>，则打印存储池对象的 XML 而不创建存储池。否则，存储池具有指定的<em>类型</em>。当使用 <code>pool-create-as</code> 创建 <code>disk</code> 类型的存储池时，将在 <code>--source-dev</code> 路径上找到的现有分区用于填充磁盘存储池。因此，建议使用 <code>pool-define-as</code> 和带有 <code>--overwrite</code> 的 <code>pool-build</code> 来正确初始化磁盘存储池。</p>
<ul>
<li>[<code>--source-host</code> 主机名] 为从远程服务器支持的存储池（类型为 <code>netfs</code>、<code>iscsi</code>、<code>rbd</code>、<code>sheepdog</code>、<code>gluster</code>）提供源主机名。</li>
<li>[<code>--source-path</code> 路径] 为目录支持的存储池（类型为 <code>dir</code>）提供源目录路径。</li>
<li>[<code>--source-dev</code> 路径] 为物理设备支持的存储池（类型为 <code>fs</code>、<code>logical</code>、<code>disk</code>、<code>iscsi</code>、<code>zfs</code>）提供源路径。</li>
<li>[<code>--source-name</code> 名称] 为从命名元素支持的存储池（类型为 <code>logical</code>、<code>rbd</code>、<code>sheepdog</code>、<code>gluster</code>）提供源名称。</li>
<li>[<code>--target</code> 路径] 是存储池映射到主机文件系统的路径。</li>
<li>[<code>--source-format</code> 格式] 提供有关存储池格式的信息（类型为 <code>fs</code>、<code>netfs</code>、<code>disk</code>、<code>logical</code>）。</li>
<li>[<code>--source-initiator</code> 发起者-IQN] 为存储池的 iSCSI 连接提供发起者 IQN（类型为 <code>iscsi-direct</code>）。</li>
<li>[<code>--auth-type</code> 认证类型 <code>--auth-username</code> 用户名 [<code>--secret-usage</code> 用途 | <code>--secret-uuid</code> UUID]] 提供生成存储池认证凭据所需的元素。<code>authtype</code> 为 <code>iscsi</code> 类型存储池的 <code>chap</code> 或 <code>rbd</code> 类型存储池的 <code>ceph</code>。可以提供 <code>usage</code> 或 <code>uuid</code> 值，但不能同时提供。</li>
<li>[<code>--source-protocol-ver</code> 版本] 提供用于通过 NFS 挂载选项 <code>nfsvers=n</code> 联系服务器 NFS 服务的 NFS 协议版本号。<code>ver</code> 值应为无符号整数。</li>
<li>[<code>--adapter-name</code> 名称] 定义用于 <code>scsi_host</code> 适配器类型存储池的 <code>scsi_hostN</code> 适配器名称。</li>
<li>[<code>--adapter-wwnn</code> WWNN <code>--adapter-wwpn</code> WWPN [<code>--adapter-parent</code> 父设备 | <code>--adapter-parent-wwnn</code> 父设备-WWNN <code>--adapter-parent-wwpn</code> 父设备-WWPN | <code>--adapter-parent-fabric-wwn</code> 父设备-光纤-WWN]]] 定义用于 <code>fc_host</code> 适配器类型存储池的 WWNN 和 WWPN。可选地提供父 <code>scsi_hostN</code> 节点设备以用于 vHBA，可以通过父设备名称、父设备-WWNN 和父设备-WWPN 或父设备-光纤-WWN 指定。父设备名称可能在重新启动后因硬件环境变化而更改，因此提供父设备-WWNN 和父设备-WWPN 可确保即使 <code>scsi_hostN</code> 节点设备更改，也能使用相同的物理 HBA。使用父设备-光纤-WWN 允许更灵活地选择同一存储光纤上的 HBA 以定义存储池。</li>
<li>[<code>--build</code>] [ [<code>--overwrite</code>] | [<code>--no-overwrite</code>]] 在创建后执行 <code>pool-build</code>，以确保存储池环境处于预期状态，而无需在启动前运行构建命令。<code>--overwrite</code> 和 <code>--no-overwrite</code> 标志的规则与 <code>pool-build</code> 相同。如果仅提供 <code>--build</code>，则调用 <code>pool-build</code> 时不带任何标志。</li>
</ul>
<p>对于 <code>logical</code> 存储池，仅需要提供 [<code>--name</code>]。如果提供了 [<code>--source-name</code>]，则必须与卷组名称匹配。如果未提供，则将从 [<code>--name</code>] 生成一个名称。如果提供了 [<code>--target</code>]，则会被忽略，并使用 [<code>--source-name</code>]（或从 [<code>--name</code>] 生成）生成目标源。</p>
<hr>
<p><strong>pool-define</strong><br><strong>语法：</strong><br>pool-define 文件 [–validate]<br>从 XML <em>文件</em>定义非活动的持久存储池或修改现有的持久存储池。可选地，可以使用 <code>--validate</code> 验证输入 XML 文件的格式是否符合内部 RNG 模式。</p>
<hr>
<p><strong>pool-define-as</strong><br><strong>语法：</strong><br>pool-define-as 名称 类型<br>[–source-host 主机名] [–source-path 路径] [–source-dev 路径]<br>[–source-name 名称] [–target 路径] [–source-format 格式]<br>[–source-initiator 发起者-IQN]<br>[–auth-type 认证类型 –auth-username 用户名<br>[–secret-usage 用途 | –secret-uuid UUID]]<br>[–source-protocol-ver 版本]<br>[ [–adapter-name 名称] | [–adapter-wwnn WWNN –adapter-wwpn WWPN<br>[–adapter-parent 父设备] ] ] [–print-xml]<br>从原始参数创建但不启动存储池对象<em>名称</em>。如果指定 <code>--print-xml</code>，则打印存储池对象的 XML 而不定义存储池。否则，存储池具有指定的<em>类型</em>。</p>
<p>使用与 <code>pool-create-as</code> 相同的参数，但不包括 <code>--build</code>、<code>--overwrite</code> 和 <code>--no-overwrite</code> 选项。</p>
<hr>
<p><strong>pool-destroy</strong><br><strong>语法：</strong><br>pool-destroy 池名或 UUID<br>销毁（停止）指定的存储池对象。Libvirt 将不再管理存储池对象描述的存储，但存储池中的原始数据不会被更改，稍后可以通过 <code>pool-create</code> 恢复。</p>
<hr>
<p><strong>pool-delete</strong><br><strong>语法：</strong><br>pool-delete 池名或 UUID<br>销毁指定存储池对象使用的资源。此操作不可恢复。执行此命令后，存储池对象仍将存在，可用于创建新的存储卷。</p>
<hr>
<p><strong>pool-dumpxml</strong><br><strong>语法：</strong><br>pool-dumpxml [–inactive] [–xpath 表达式] [–wrap] 池名或 UUID<br>返回存储池对象的 XML 信息。<code>--inactive</code> 指示 virsh 转储将在下次启动存储池时使用的配置，而不是当前存储池配置。</p>
<p>如果提供了 <code>--xpath</code> 参数（XPath 表达式），则将对输出 XML 求值并仅打印匹配的节点。默认行为是将每个匹配节点打印为独立文档，但为了便于进一步处理，<code>--wrap</code> 参数将导致匹配节点包装在公共根节点中。</p>
<hr>
<p><strong>pool-edit</strong><br><strong>语法：</strong><br>pool-edit 池名或 UUID<br>编辑存储池的 XML 配置文件。<br>这相当于：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">virsh pool-dumpxml 池名 &gt; 池名.xml  </span><br><span class="line">vi 池名.xml（或使用其他文本编辑器进行更改）  </span><br><span class="line">virsh pool-define 池名.xml</span><br></pre></td></tr></table></figure>

<p>不同之处在于它会进行一些错误检查。</p>
<p>使用的编辑器可以通过环境变量 <code>$VISUAL</code> 或 <code>$EDITOR</code> 指定，默认为 <code>vi</code>。</p>
<hr>
<p><strong>pool-info</strong><br><strong>语法：</strong><br>pool-info [–bytes] 池名或 UUID<br>返回存储池对象的基本信息。如果指定 <code>--bytes</code>，则基本信息的大小不会转换为人类友好的单位。</p>
<hr>
<p><strong>pool-list</strong><br><strong>语法：</strong><br>pool-list [–inactive] [–all]<br>[–persistent] [–transient]<br>[–autostart] [–no-autostart]<br>[ [–details] [–uuid]<br>[–name] [类型] ]<br>列出 libvirt 已知的存储池对象。默认情况下，仅列出活动存储池；<code>--inactive</code> 仅列出非活动存储池，<code>--all</code> 列出所有存储池。</p>
<p>此外，还有几组过滤标志。<code>--persistent</code> 用于列出持久存储池，<code>--transient</code> 用于列出临时存储池。<code>--autostart</code> 列出自动启动的存储池，<code>--no-autostart</code> 列出禁用自动启动的存储池。如果指定 <code>--uuid</code>，则仅打印存储池的 UUID。如果指定 <code>--name</code>，则仅打印存储池的名称。如果同时指定 <code>--name</code> 和 <code>--uuid</code>，则存储池的 UUID 和名称将并排打印，不带任何标题。选项 <code>--details</code> 与 <code>--uuid</code> 和 <code>--name</code> 互斥。</p>
<p>还可以使用 <code>类型</code> 列出指定类型的存储池，存储池类型必须用逗号分隔，例如 <code>--type dir,disk</code>。有效的存储池类型包括 <code>dir</code>、<code>fs</code>、<code>netfs</code>、<code>logical</code>、<code>disk</code>、<code>iscsi</code>、<code>scsi</code>、<code>mpath</code>、<code>rbd</code>、<code>sheepdog</code>、<code>gluster</code>、<code>zfs</code>、<code>vstorage</code> 和 <code>iscsi-direct</code>。</p>
<p><code>--details</code> 选项指示 virsh 额外显示存储池持久性和容量相关信息（如果可用）。</p>
<p>注意：在与旧服务器通信时，此命令被迫使用一系列具有固有竞争的 API 调用，如果在调用之间存储池状态更改，则存储池可能不会被列出或可能多次出现。新服务器没有此问题。</p>
<hr>
<p><strong>pool-name</strong><br><strong>语法：</strong><br>pool-name UUID<br>将 <code>UUID</code> 转换为存储池名称。</p>
<hr>
<p><strong>pool-refresh</strong><br><strong>语法：</strong><br>pool-refresh 池名或 UUID<br>刷新存储池中包含的卷列表。</p>
<hr>
<p><strong>pool-start</strong><br><strong>语法：</strong><br>pool-start 池名或 UUID [–build] [ [–overwrite] | [–no-overwrite]]<br>启动之前定义但未激活的存储池。</p>
<p>[<code>--build</code>] [ [<code>--overwrite</code>] | [<code>--no-overwrite</code>]] 在 <code>pool-start</code> 之前执行 <code>pool-build</code>，以确保存储池环境处于预期状态，而无需在启动前运行构建命令。<code>--overwrite</code> 和 <code>--no-overwrite</code> 标志的规则与 <code>pool-build</code> 相同。如果仅提供 <code>--build</code>，则调用 <code>pool-build</code> 时不带任何标志。</p>
<p>注意：依赖于远程资源（如 <code>iscsi</code> 或（v）HBA 支持的 <code>scsi</code> 存储池）的存储池可能需要多次刷新才能检测到所有卷（参见 <code>pool-refresh</code>）。这是因为相应的卷设备可能在初始存储池启动或当前刷新尝试期间不在主机的文件系统中。刷新重试的次数取决于网络连接和主机导出相应设备所需的时间。</p>
<hr>
<p><strong>pool-undefine</strong><br><strong>语法：</strong><br>pool-undefine 池名或 UUID<br>取消定义非活动存储池的配置。</p>
<hr>
<p><strong>pool-uuid</strong><br><strong>语法：</strong><br>pool-uuid 池名<br>返回命名存储池的 UUID。</p>
<p><strong>pool-event</strong><br><strong>语法：</strong><br>pool-event {[池名] 事件 [–loop] [–timeout 秒] [–timestamp] | –list}<br>等待一类存储池事件发生，并在事件发生时打印适当的详细信息。事件可以选择通过 <code>池名</code> 过滤。仅使用 <code>--list</code> 作为参数将提供此客户端已知的可能 <code>事件</code> 值列表，尽管连接可能不允许注册所有这些事件。</p>
<p>默认情况下，此命令是一次性的，一旦事件发生即返回成功；可以通过发送 SIGINT（通常通过 Ctrl-C）立即退出。如果指定 <code>--timeout</code>，则命令在 <code>秒</code> 后放弃等待事件。使用 <code>--loop</code> 时，命令将打印所有事件，直到超时或中断。</p>
<p>当使用 <code>--timestamp</code> 时，将在事件之前打印人类可读的时间戳。</p>
<hr>
<h1 id="12-卷命令"><a href="#12-卷命令" class="headerlink" title="12 卷命令"></a>12 <strong>卷命令</strong></h1><p><strong>vol-create</strong><br><strong>语法：</strong><br>vol-create 池名或UUID 文件 [–prealloc-metadata] [–validate]<br>从XML <code>&lt;文件&gt;</code> 创建卷。<br><em>池名或UUID</em> 是创建卷的存储池的名称或UUID。</p>
<p><em>文件</em> 是包含卷定义的XML <code>&lt;文件&gt;</code>。创建XML文件的简单方法是使用 <code>vol-dumpxml</code> 命令获取现有卷的定义。</p>
<p>[<code>--prealloc-metadata</code>] 预分配元数据（适用于不支持完全分配的qcow2镜像）。此选项创建一个带有元数据的稀疏镜像文件，与没有预分配的镜像相比性能更高，初始磁盘空间使用量仅略有增加。</p>
<p>如果指定 <code>--validate</code>，则根据内部RNG模式验证XML文档的格式。</p>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">virsh vol-dumpxml --pool storagepool1 appvolume1 &gt; newvolume.xml  </span><br><span class="line">vi newvolume.xml（或使用其他文本编辑器进行更改）  </span><br><span class="line">virsh vol-create differentstoragepool newvolume.xml</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>vol-create-from</strong><br><strong>语法：</strong><br>vol-create-from pool-or-uuid FILE vol-name-or-key-or-path<br>   [–inputpool pool-or-uuid]  [–prealloc-metadata] [–reflink] [–validate]<br>使用另一个卷作为输入创建卷。</p>
<p><em>池名或UUID</em> 是创建卷的存储池的名称或UUID。</p>
<p><em>文件</em> 是包含卷定义的XML <code>&lt;文件&gt;</code>。</p>
<p><em>卷名或键或路径</em> 是源卷的名称、键或路径。</p>
<p><code>--inputpool</code> <em>池名或UUID</em> 是源卷所在的存储池的名称或UUID。</p>
<p>[<code>--prealloc-metadata</code>] 预分配元数据（适用于不支持完全分配的qcow2镜像）。此选项创建一个带有元数据的稀疏镜像文件，与没有预分配的镜像相比性能更高，初始磁盘空间使用量仅略有增加。</p>
<p>当指定 <code>--reflink</code> 时，执行COW轻量级复制，仅在修改时复制数据块。如果无法执行，则复制失败。</p>
<p>如果指定 <code>--validate</code>，则根据内部RNG模式验证XML文档的格式。</p>
<hr>
<p><strong>vol-create-as</strong><br><strong>语法：</strong><br>vol-create-as pool-or-uuid name capacity [–allocation size] [–format string]<br>   [–backing-vol vol-name-or-key-or-path]<br>   [–backing-vol-format string] [–prealloc-metadata] [–print-xml]</p>
<p>从一组参数创建卷，除非指定 <code>--print-xml</code>，此时仅打印卷对象的XML而不实际创建对象。</p>
<p><em>池名或UUID</em> 是创建卷的存储池的名称或UUID。</p>
<p><em>名称</em> 是新卷的名称。对于磁盘存储池，此名称必须与从存储池源设备路径和下一个可用分区确定的分区名称匹配。例如，源设备路径为 <code>/dev/sdb</code> 且磁盘上没有分区时，名称必须为 <code>sdb1</code>，下一个名称为 <code>sdb2</code>，依此类推。</p>
<p><em>容量</em> 是要创建的卷的大小，为带缩放的整数（参见上文NOTES），如果没有后缀则默认为字节。</p>
<p><code>--allocation</code> <em>大小</em> 是卷中初始分配的大小，同样为带缩放的整数，默认为字节。</p>
<p><code>--format</code> <em>字符串</em> 用于基于文件的存储池，指定要使用的卷文件格式：raw、bochs、qcow、qcow2、vmdk、qed。对于磁盘存储池，使用 <code>extended</code> 创建扩展分区（其他值会进行有效性检查，但在重启libvirtd或刷新存储池时不会保留）。</p>
<p><code>--backing-vol</code> <em>卷名或键或路径</em> 是如果要为现有卷创建快照，则使用的源后备卷。</p>
<p><code>--backing-vol-format</code> <em>字符串</em> 是快照后备卷的格式：raw、bochs、qcow、qcow2、qed、vmdk、host_device。但这些格式适用于基于文件的存储池。</p>
<p>[<code>--prealloc-metadata</code>] 预分配元数据（适用于不支持完全分配的qcow2镜像）。此选项创建一个带有元数据的稀疏镜像文件，与没有预分配的镜像相比性能更高，初始磁盘空间使用量仅略有增加。</p>
<hr>
<p><strong>vol-clone</strong><br><strong>语法：</strong><br>vol-clone vol-name-or-key-or-path name<br>   [–pool pool-or-uuid] [–prealloc-metadata] [–reflink] [–print-xml]</p>
<p>在父存储池中克隆现有卷。功能较弱但更易输入的 <code>vol-create-from</code> 版本。</p>
<p><em>卷名或键或路径</em> 是源卷的名称、键或路径。</p>
<p><em>名称</em> 是新卷的名称。</p>
<p><code>--pool</code> <em>池名或UUID</em> 是包含源卷并将包含新卷的存储池的名称或UUID。如果提供的是源卷名称而非键或路径，则需要提供存储池以找到要克隆的卷；否则，将使用通过键或路径找到的第一个卷。</p>
<p>[<code>--prealloc-metadata</code>] 预分配元数据（适用于不支持完全分配的qcow2镜像）。此选项创建一个带有元数据的稀疏镜像文件，与没有预分配的镜像相比性能更高，初始磁盘空间使用量仅略有增加。</p>
<p>当指定 <code>--reflink</code> 时，执行COW轻量级复制，仅在修改时复制数据块。如果无法执行，则复制失败。</p>
<p>如果指定 <code>--print-xml</code>，则打印用于克隆卷的XML。</p>
<hr>
<p><strong>vol-delete</strong><br><strong>语法：</strong><br>vol-delete vol-name-or-key-or-path [–pool pool-or-uuid] [–delete-snapshots]<br>删除指定卷。</p>
<p><em>卷名或键或路径</em> 是要删除的卷的名称、键或路径。</p>
<p>[<code>--pool</code> <em>池名或UUID</em>] 是卷所在的存储池的名称或UUID。如果提供的是卷名称而非键或路径，则需要提供存储池以找到要删除的卷；否则，将使用通过键或路径找到的第一个卷。</p>
<p><code>--delete-snapshots</code> 标志指定应同时删除与存储卷关联的任何快照。并非所有存储驱动都支持此选项，目前仅支持rbd。</p>
<hr>
<p><strong>vol-upload</strong><br><strong>语法：</strong><br>vol-upload vol-name-or-key-or-path local-file<br>   [–pool pool-or-uuid] [–offset bytes]<br>   [–length bytes] [–sparse]</p>
<p>将<em>本地文件</em>的内容上传到存储卷。</p>
<p><em>卷名或键或路径</em> 是上传<em>本地文件</em>的卷的名称、键或路径。</p>
<p><code>--pool</code> <em>池名或UUID</em> 是卷所在的存储池的名称或UUID。如果提供的是卷名称而非键或路径，则需要提供存储池以找到要上传的卷；否则，将使用通过键或路径找到的第一个卷。</p>
<p><code>--offset</code> 是存储卷中开始写入数据的位置。值必须为0或更大。</p>
<p><code>--length</code> 是要上传的数据量的上限。负值解释为无符号长整型值，实质上包括从偏移量到卷末尾的所有内容。</p>
<p>如果指定 <code>--sparse</code>，此命令将保留卷的稀疏性。</p>
<p>如果<em>本地文件</em>大于指定的<em>长度</em>，则会发生错误。</p>
<p>有关尝试上传时由于存储池刷新可能导致的目标卷和存储池更改的详细信息，请参阅libvirt virStorageVolUpload API的描述。</p>
<hr>
<p><strong>vol-download</strong><br><strong>语法：</strong><br>vol-download vol-name-or-key-or-path local-file<br>   [–pool pool-or-uuid] [–offset bytes] [–length bytes]<br>   [–sparse]</p>
<p>将存储卷的内容下载到<em>本地文件</em>。</p>
<p><em>卷名或键或路径</em> 是下载到<em>本地文件</em>的卷的名称、键或路径。</p>
<p><code>--pool</code> <em>池名或UUID</em> 是卷所在的存储池的名称或UUID。如果提供的是卷名称而非键或路径，则需要提供存储池以找到要上传的卷；否则，将使用通过键或路径找到的第一个卷。</p>
<p><code>--offset</code> 是存储卷中开始读取数据的位置。值必须为0或更大。</p>
<p><code>--length</code> 是要下载的数据量的上限。负值解释为无符号长整型值，实质上包括从偏移量到卷末尾的所有内容。</p>
<p>如果指定 <code>--sparse</code>，此命令将保留卷的稀疏性。</p>
<hr>
<p><strong>vol-wipe</strong><br><strong>语法：</strong><br>vol-wipe vol-name-or-key-or-path [–pool pool-or-uuid] [–algorithm algorithm]  </p>
<p>擦除卷，确保卷上先前的数据无法被未来读取访问。<em>卷名或键或路径</em> 是要擦除的卷的名称、键或路径。可以选择不同的擦除算法，而不是用零重写卷。</p>
<p><code>--pool</code> <em>池名或UUID</em> 是卷所在的存储池的名称或UUID。如果提供的是卷名称而非键或路径，则需要提供存储池以找到要擦除的卷；否则，将使用通过键或路径找到的第一个卷。</p>
<p>使用 <code>--algorithm</code> 从以下算法列表中选择，以定义擦除使用的算法。</p>
<p>支持的算法：</p>
<ul>
<li><code>zero</code> - 1次全零写入  </li>
<li><code>nnsa</code> - 4次NNSA Policy Letter NAP-14.1-C (XVI-8)擦除可移动和不可移动硬盘：随机x2，0x00，验证。  </li>
<li><code>dod</code> - 4次DoD 5220.22-M第8-306节擦除可移动和不可移动硬盘：随机，0x00，0xff，验证。  </li>
<li><code>bsi</code> - 德国信息安全中心 （<a target="_blank" rel="noopener" href="https://www.bsi.bund.de)/">https://www.bsi.bund.de）</a> 推荐的9次方法：0xff, 0xfe, 0xfd, 0xfb, 0xf7, 0xef, 0xdf, 0xbf, 0x7f。  </li>
<li><code>gutmann</code> - Gutmann论文中描述的经典35次序列。  </li>
<li><code>schneier</code> - Bruce Schneier在《应用密码学》（1996）中描述的7次方法：0x00, 0xff, 随机x5。  </li>
<li><code>pfitzner7</code> - Roy Pfitzner的7次随机方法：随机x7。  </li>
<li><code>pfitzner33</code> - Roy Pfitzner的33次随机方法：随机x33。  </li>
<li><code>random</code> - 1次随机模式。  </li>
<li><code>trim</code> - 1次使用TRIM或DISCARD修剪卷</li>
</ul>
<p>注意：<code>scrub</code> 二进制文件将用于处理 <code>nnsa</code>、<code>dod</code>、<code>bsi</code>、<code>gutmann</code>、<code>schneier</code>、<code>pfitzner7</code> 和 <code>pfitzner33</code> 算法。算法的可用性可能受主机上安装的 <code>scrub</code> 二进制文件版本的限制。<code>zero</code> 算法会将零写入整个卷。对于某些卷（如稀疏卷或rbd卷），这可能导致卷完全填满零，使其看起来完全满。作为替代方案，<code>trim</code> 算法不会覆盖卷中的所有数据，而是期望存储驱动能够丢弃卷中的所有字节。由存储驱动决定如何处理丢弃操作。并非所有存储驱动或卷类型都支持 <code>trim</code>。</p>
<hr>
<p><strong>vol-dumpxml</strong><br><strong>语法：</strong><br>vol-dumpxml [–pool pool-or-uuid] [–xpath EXPRESSION] [–wrap] vol-name-or-key-or-path</p>
<p>将卷信息以XML格式输出到标准输出。</p>
<p><em>卷名或键或路径</em> 是要输出XML的卷的名称、键或路径。</p>
<p><code>--pool</code> <em>池名或UUID</em> 是卷所在的存储池的名称或UUID。如果提供的是卷名称而非键或路径，则需要提供存储池以找到要上传的卷；否则，将使用通过键或路径找到的第一个卷。</p>
<p>如果 <code>--xpath</code> 参数提供XPath表达式，则将对输出XML求值并仅打印匹配的节点。默认行为是将每个匹配节点打印为独立文档，但为了便于进一步处理，<code>--wrap</code> 参数将导致匹配节点包装在公共根节点中。</p>
<hr>
<p><strong>vol-info</strong><br><strong>语法：</strong><br>vol-info vol-name-or-key-or-path [–pool pool-or-uuid] [–bytes] [–physical]<br>返回给定存储卷的基本信息。</p>
<p><em>卷名或键或路径</em> 是要返回信息的卷的名称、键或路径。</p>
<p><code>--pool</code> <em>池名或UUID</em> 是卷所在的存储池的名称或UUID。如果提供的是卷名称而非键或路径，则需要提供存储池以找到要上传的卷；否则，将使用通过键或路径找到的第一个卷。</p>
<p>如果指定 <code>--bytes</code>，则大小不会转换为人类友好单位。</p>
<p>如果指定 <code>--physical</code>，则返回并显示主机物理大小而非分配值。某些文件类型（如qcow2）的物理值可能与分配值不同（更大）。此外，稀疏文件的物理值和分配值会不同。</p>
<hr>
<p><strong>vol-list</strong><br><strong>语法：</strong><br>vol-list [–pool pool-or-uuid] [–details]<br>返回给定存储池中的卷列表。</p>
<p><code>--pool</code> <em>池名或UUID</em> 是存储池的名称或UUID。</p>
<p><code>--details</code> 选项指示virsh额外显示卷类型和容量相关信息（如果可用）。</p>
<hr>
<p><strong>vol-pool</strong><br><strong>语法：</strong><br>vol-pool vol-key-or-path [–uuid]<br>返回给定卷的存储池名称或UUID。默认返回存储池名称。</p>
<p><em>卷键或路径</em> 是要返回存储池信息的卷的键或路径。</p>
<p>如果指定 <code>--uuid</code> 选项，则返回存储池UUID。</p>
<hr>
<p><strong>vol-path</strong><br><strong>语法：</strong><br>vol-path vol-name-or-key [–pool pool-or-uuid]<br>返回给定卷的路径。</p>
<p><em>卷名或键</em> 是要返回路径的卷的名称或键。</p>
<p><code>--pool</code> <em>池名或UUID</em> 是卷所在的存储池的名称或UUID。如果提供的是卷名称而非键，则需要提供存储池以找到要上传的卷；否则，将使用通过键找到的第一个卷。</p>
<hr>
<p><strong>vol-name</strong><br><strong>语法：</strong><br>vol-name vol-key-or-path<br>返回给定卷的名称。</p>
<p><em>卷键或路径</em> 是要返回名称的卷的键或路径。</p>
<hr>
<p><strong>vol-key</strong><br><strong>语法：</strong><br>vol-key vol-name-or-path [–pool pool-or-uuid]<br>返回给定卷的卷键。</p>
<p><em>卷名或路径</em> 是要返回卷键的卷的名称或路径。</p>
<p><code>--pool</code> <em>池名或UUID</em> 是卷所在的存储池的名称或UUID。如果提供的是卷名称而非路径，则需要提供存储池以找到要上传的卷；否则，将使用通过路径找到的第一个卷。</p>
<hr>
<p><strong>vol-resize</strong><br><strong>语法：</strong><br>vol-resize vol-name-or-path capacity [–pool pool-or-uuid] [–allocate] [–delta] [–shrink]</p>
<p>调整给定卷的容量（以字节为单位）。</p>
<p><em>卷名或键或路径</em> 是要调整大小的卷的名称、键或路径。</p>
<p><em>容量</em> 是卷的带缩放整数（参见上文NOTES），如果没有后缀则默认为字节。</p>
<p><code>--pool</code> <em>池名或UUID</em> 是卷所在的存储池的名称或UUID。如果提供的是卷名称而非键或路径，则需要提供存储池以找到要上传的卷；否则，将使用通过键或路径找到的第一个卷。</p>
<p>除非指定 <code>--allocate</code>，否则新<em>容量</em>可能是稀疏的。</p>
<p>通常，<em>容量</em>是新大小，但如果存在 <code>--delta</code>，则将其添加到现有大小。</p>
<p>除非存在 <code>--shrink</code>，否则尝试缩小卷将失败。除非提供 <code>--shrink</code>，否则<em>容量</em>不能为负，但不需要负号。</p>
<p>此命令仅适用于未被活动客户机使用的存储卷；有关实时调整大小，请参阅 <code>blockresize</code>。</p>
<hr>
<h1 id="13-密钥命令"><a href="#13-密钥命令" class="headerlink" title="13 密钥命令"></a>13 <strong>密钥命令</strong></h1><p>以下命令操作“密钥”（例如密码、口令和加密密钥）。Libvirt可以独立于其使用存储密钥，其他对象（例如卷或域）可以引用密钥进行加密或其他用途。密钥使用UUID标识。有关用于表示密钥属性的XML格式的文档，请参阅 <a target="_blank" rel="noopener" href="https://libvirt.org/formatsecret.html%E3%80%82">https://libvirt.org/formatsecret.html。</a></p>
<p><strong>secret-define</strong><br><strong>语法：</strong><br>secret-define file [–validate]<br>创建具有<em>文件</em>中指定属性的密钥，无关联密钥值。如果<em>文件</em>未指定UUID，则自动选择一个。如果<em>文件</em>指定现有密钥的UUID，则替换其属性为<em>文件</em>中定义的属性，不影响密钥值。</p>
<p>可选地，可以使用 <code>--validate</code> 根据内部RNG模式验证输入XML文件的格式。</p>
<hr>
<p><strong>secret-dumpxml</strong><br><strong>语法：</strong><br>secret-dumpxml [–xpath EXPRESSION] [–wrap] secret<br>将<em>密钥</em>（由其UUID指定）的属性以XML格式输出到标准输出。</p>
<p>如果 <code>--xpath</code> 参数提供XPath表达式，则将对输出XML求值并仅打印匹配的节点。默认行为是将每个匹配节点打印为独立文档，但为了便于进一步处理，<code>--wrap</code> 参数将导致匹配节点包装在公共根节点中。</p>
<hr>
<p><strong>secret-event</strong><br><strong>语法：</strong><br>secret-event {[secret] event [–loop] [–timeout seconds] [–timestamp] | –list}<br>等待一类密钥事件发生，并在事件发生时打印适当的详细信息。事件可以选择通过<em>密钥</em>过滤。仅使用 <code>--list</code> 作为参数将提供此客户端已知的可能<em>事件</em>值列表，尽管连接可能不允许注册所有这些事件。</p>
<p>默认情况下，此命令是一次性的，一旦事件发生即返回成功；可以通过发送SIGINT（通常通过Ctrl-C）立即退出。如果指定 <code>--timeout</code>，则命令在<em>秒</em>后放弃等待事件。使用 <code>--loop</code> 时，命令将打印所有事件，直到超时或中断。</p>
<p>当使用 <code>--timestamp</code> 时，将在事件之前打印人类可读的时间戳。</p>
<hr>
<p><strong>secret-set-value</strong><br><strong>语法：</strong><br>secret-set-value secret (–file filename [–plain] | –interactive | base64)<br>将与<em>密钥</em>（由其UUID指定）关联的值设置为Base64编码值<em>base64</em>或文件<em>文件名</em>的Base64编码内容。与 <code>--file</code> 一起使用 <code>--plain</code> 标志允许直接将文件内容用作密钥值。</p>
<p>如果使用 <code>--interactive</code> 标志，则从终端读取密钥值作为密码。</p>
<p>注意，<code>--file</code>、<code>--interactive</code> 和 <code>base64</code> 选项互斥。</p>
<p>通过命令行传递 <code>base64</code> 选项的密钥是不安全的且已弃用。请改用 <code>--file</code> 选项。</p>
<hr>
<p><strong>secret-get-value</strong><br><strong>语法：</strong><br>secret-get-value [–plain] secret<br>将关联到<em>密钥</em>（由其UUID指定）的值输出到标准输出，使用Base64编码。</p>
<p>如果使用 <code>--plain</code> 标志，则值不以Base64编码，而是原始打印。注意，除非virsh以安静模式启动（<code>virsh -q</code>），否则它会在命令末尾打印换行符。此换行符不是密钥的一部分。</p>
<hr>
<p><strong>secret-undefine</strong><br><strong>语法：</strong><br>secret-undefine secret<br>删除<em>密钥</em>（由其UUID指定），包括关联的值（如果有）。</p>
<hr>
<p><strong>secret-list</strong><br><strong>语法：</strong><br>secret-list [–ephemeral] [–no-ephemeral]<br>   [–private] [–no-private]</p>
<p>返回密钥列表。您还可以通过 <code>--ephemeral</code> 过滤返回的临时密钥，<code>--no-ephemeral</code> 过滤非临时密钥，<code>--private</code> 过滤私有密钥，<code>--no-private</code> 过滤非私有密钥。</p>
<hr>
<h1 id="14-快照命令"><a href="#14-快照命令" class="headerlink" title="14 快照命令"></a>14 <strong>快照命令</strong></h1><p>以下命令用于操作域快照。快照会保存域在某个时间点的磁盘、内存和设备状态，供未来使用。快照有许多用途，从保存操作系统镜像的”干净”副本，到在执行可能具有破坏性的操作前保存域的状态。快照通过唯一名称标识。关于用于表示快照属性的XML格式文档，请参阅<a target="_blank" rel="noopener" href="https://libvirt.org/formatsnapshot.html%E3%80%82">https://libvirt.org/formatsnapshot.html。</a></p>
<p><strong>snapshot-create</strong><br><strong>语法：</strong><br>snapshot-create 域 [xml文件] {[–redefine [–current]] | [–no-metadata] [–halt] [–disk-only] [–reuse-external] [–quiesce] [–atomic] [–live]} [–validate]<br>为域<em>域</em>创建一个快照，属性由<em>xml文件</em>指定。可选地，可以传递*–validate<em>选项来验证输入XML文件的格式是否符合内部RNG模式（与使用virt-xml-validate(1)工具相同）。通常，域快照唯一可设置的属性是<name>和<description>元素，如果给出</em>–disk-only<em>，还包括<disks>；其余字段会被忽略，由libvirt自动填充。如果完全省略</em>xmlfile*，那么libvirt将为所有字段选择值。新快照将成为当前快照，如snapshot-current所列。</p>
<p>如果指定*–halt*，创建快照后域将处于非活动状态。</p>
<p>如果指定*–disk-only<em>，快照将只包含磁盘内容，而不是通常包含虚拟机状态的完整系统快照。磁盘快照比完整系统快照捕获得更快，但恢复到磁盘快照可能需要fsck或日志重放，因为它就像电源线突然拔出时的磁盘状态；同时使用</em>–halt<em>和</em>–disk-only*会丢失当时未刷新到磁盘的任何数据。</p>
<p>如果指定*–redefine<em>，那么snapshot-dumpxml生成的所有XML元素都有效；这可以用于将快照层次结构从一台机器迁移到另一台机器，为临时域重新创建层次结构（临时域消失后又以相同名称和UUID重新创建），或者对快照元数据进行微小修改（例如快照中嵌入的域XML的主机特定方面）。使用此标志时，</em>xmlfile<em>参数是必需的，除非同时给出</em>–current*标志，否则域的当前快照不会被更改。</p>
<p>如果指定*–no-metadata<em>，那么会创建快照数据，但会立即丢弃任何元数据（即libvirt不会将快照视为当前快照，除非以后使用</em>–redefine*让libvirt再次了解元数据，否则无法恢复到该快照）。</p>
<p>如果指定*–reuse-external*，并且快照XML请求使用现有文件作为外部快照的目标，那么目标必须存在并且预先创建了正确的格式和元数据。然后文件会被重用；否则会拒绝快照以避免丢失现有文件的内容。</p>
<p>如果指定*–quiesce<em>，libvirt将尝试使用客户代理来冻结和解冻域的挂载文件系统。但是，如果域没有客户代理，快照创建将失败。目前，这需要同时传递</em>–disk-only*。</p>
<p>如果指定*–atomic*，libvirt将保证快照要么成功，要么失败且不做任何更改；并非所有虚拟机监控程序都支持这一点。如果不指定此标志，那么一些虚拟机监控程序可能会在部分执行操作后失败，必须使用dumpxml来查看是否发生了任何部分更改。</p>
<p>如果指定*–live*，libvirt会在客户运行时拍摄快照。同时捕获磁盘快照和域内存快照。这会增加外部快照的内存映像大小。目前仅支持完整系统的外部快照。</p>
<p>快照元数据的存在会阻止尝试取消定义持久客户。但是，对于临时域，当域停止运行时（无论是通过destroy等命令还是内部客户操作），快照元数据会静默丢失。</p>
<p>目前，无法在具有检查点的域中创建快照，尽管此限制将在未来版本中取消。</p>
<hr>
<p><strong>snapshot-create-as</strong><br><strong>语法：</strong><br>snapshot-create-as 域 { [–print-xml] [–no-metadata] [–halt] [–reuse-external]} [名称] [描述] [–disk-only [–quiesce]] [–atomic] [–validate] [ [–live] [–memspec 内存规格]] [–diskspec 磁盘规格]…<br>为域<em>域</em>创建一个具有给定<name>和<description>的快照；如果省略任一值，libvirt将选择一个值。如果指定*–print-xml<em>，则输出适合</em>snapshot-create<em>的XML，而不是实际创建快照。否则，如果指定</em>–halt<em>，创建快照后域将处于非活动状态，如果指定</em>–disk-only*，快照将不包含虚拟机状态。</p>
<p><em>–memspec</em>选项可用于控制系统快照是内部还是外部。*–memspec<em>标志是必需的，后跟内存规格，格式为[file&#x3D;]名称[,snapshot&#x3D;类型]，其中类型可以是no、internal或external。要在file&#x3D;名称中包含字面逗号，用第二个逗号转义。</em>–memspec<em>不能与</em>–disk-only*一起使用。</p>
<p><em>–diskspec</em>选项可用于控制*–disk-only<em>和外部完整系统快照如何创建外部文件。此选项可以出现多次，根据域xml中<disk>元素的数量。每个<diskspec>的格式为磁盘[,snapshot&#x3D;类型][,driver&#x3D;类型][,stype&#x3D;类型][,file&#x3D;名称]。必须为块设备支持的磁盘提供</em>diskspec*，因为libvirt不会为这些设备自动生成文件名。可选的stype参数允许控制源文件的类型。支持的值为’file’（默认）和’block’。要从外部快照中排除磁盘，使用–diskspec 磁盘,snapshot&#x3D;no。</p>
<p>要在磁盘或file&#x3D;名称中包含字面逗号，用第二个逗号转义。除非同时存在<em>域</em>、<em>名称</em>和<em>描述</em>，否则必须在每个diskspec前加上字面的*–diskspec*。例如，diskspec为”vda,snapshot&#x3D;external,file&#x3D;&#x2F;path&#x2F;to,,new”会生成以下XML：</p>
<disk name='vda' snapshot='external'>
<source file='/path/to,new'/>
</disk>

<p>如果指定*–reuse-external<em>，并且域XML或</em>diskspec*选项请求使用现有文件作为外部快照的目标，那么目标必须存在并且预先创建了正确的格式和元数据。然后文件会被重用；否则会拒绝快照以避免丢失现有文件的内容。</p>
<p>如果指定*–quiesce<em>，libvirt将尝试使用客户代理来冻结和解冻域的挂载文件系统。但是，如果域没有客户代理，快照创建将失败。目前，这需要同时传递</em>–disk-only*。</p>
<p>如果指定*–no-metadata*，那么会创建快照数据，但会立即丢弃任何元数据（即libvirt不会将快照视为当前快照，除非以后使用snapshot-create让libvirt再次了解元数据，否则无法恢复到该快照）。</p>
<p>如果指定*–atomic*，libvirt将保证快照要么成功，要么失败且不做任何更改；并非所有虚拟机监控程序都支持这一点。如果不指定此标志，那么一些虚拟机监控程序可能会在部分执行操作后失败，必须使用dumpxml来查看是否发生了任何部分更改。</p>
<p>如果指定*–live*，libvirt会在客户运行时拍摄快照。这会增加外部快照的内存映像大小。目前仅支持外部完整系统快照。</p>
<p>目前，无法在具有检查点的域中创建快照，尽管此限制将在未来版本中取消。</p>
<p>可选地，可以传递*–validate*选项来验证此命令内部生成的XML文档是否符合内部RNG模式。</p>
<hr>
<p><strong>snapshot-current</strong><br><strong>语法：</strong><br>snapshot-current 域 {[–name] | [–security-info] | [快照名称]}<br>不带<em>快照名称</em>时，这将输出域当前快照的XML（如果有）。如果指定*–name<em>，则只输出当前快照名称而不是完整的xml。否则，使用</em>–security-info*还会在XML中包含安全敏感信息。</p>
<p>使用<em>快照名称</em>时，这是请求使现有的命名快照成为当前快照，而不恢复域。</p>
<hr>
<p><strong>snapshot-edit</strong><br><strong>语法：</strong><br>snapshot-edit 域 [快照名称] [–current] {[–rename] | [–clone]}<br>编辑域<em>快照名称</em>的XML配置文件。如果同时指定<em>快照名称</em>和*–current<em>，还会强制将编辑后的快照设为当前快照。如果省略</em>快照名称<em>，那么必须提供</em>–current*来编辑当前快照。</p>
<p>这相当于：</p>
<p>virsh snapshot-dumpxml dom name &gt; snapshot.xml<br>vi snapshot.xml（或用其他文本编辑器进行更改）<br>virsh snapshot-create dom snapshot.xml –redefine [–current]</p>
<p>只是它会进行一些错误检查。</p>
<p>使用的编辑器可以由$VISUAL或$EDITOR环境变量提供，默认为vi。</p>
<p>如果指定*–rename<em>，那么编辑可以更改快照名称。如果指定</em>–clone*，那么更改快照名称将创建快照元数据的克隆。如果都不指定，那么编辑不能更改快照名称。注意更改快照名称必须小心，因为某些快照的内容，如单个qcow2文件中的内部快照，只能通过原始名称访问。</p>
<hr>
<p><strong>snapshot-info</strong><br><strong>语法：</strong><br>snapshot-info 域 {快照 | –current}<br>输出命名&lt;快照&gt;或使用*–current*的当前快照的基本信息。</p>
<hr>
<p><strong>snapshot-list</strong><br><strong>语法：</strong><br>snapshot-list 域 [–metadata] [–no-metadata] [{–parent | –roots | [{–tree | –name}]}] [–topological] [{–from 快照 | –current} [–descendants]] [–leaves] [–no-leaves] [–inactive] [–active] [–disk-only] [–internal] [–external]<br>列出给定域的所有可用快照，默认显示快照名称、创建时间和域状态的列。</p>
<p>通常，表格形式的输出按快照名称排序；使用*–topological*则会排序，使得没有子快照在其祖先之前列出（尽管可能有多个满足此属性的排序）。</p>
<p>如果指定*–parent<em>，则在输出表中添加一列，给出每个快照的父快照名称。如果指定</em>–roots<em>，列表将过滤为只有没有父快照的快照。如果指定</em>–tree*，输出将以树形格式显示，只列出快照名称。这三个选项是互斥的。</p>
<p>如果指定*–name<em>，则只打印快照名称，如果同时使用</em>–parent<em>，则附加制表符分隔的父快照名称。此选项与</em>–tree*互斥。</p>
<p>如果提供*–from<em>，则过滤列表为给定快照的子快照；或者如果提供</em>–current<em>，则从当前快照开始。单独使用或与</em>–parent<em>一起使用时，除非同时存在</em>–descendants<em>，否则列表仅限于直接子快照。与</em>–tree<em>一起使用时，隐含</em>–descendants<em>的使用。此选项与</em>–roots<em>不兼容。注意</em>–from<em>或</em>–current<em>的起点不包括在列表中，除非同时存在</em>–tree*选项。</p>
<p>如果指定*–leaves<em>，列表将过滤为只有没有子快照的快照。同样，如果指定</em>–no-leaves<em>，列表将过滤为只有有子快照的快照。（注意同时省略这两个选项不进行过滤，而同时提供这两个选项将根据服务器是否识别标志而产生相同列表或出错）。过滤选项与</em>–tree*不兼容。</p>
<p>如果指定*–metadata<em>，列表将过滤为只有涉及libvirt元数据的快照，从而会阻止取消定义持久客户，或者在临时域销毁时丢失。同样，如果指定</em>–no-metadata*，列表将过滤为只有无需libvirt元数据存在的快照。</p>
<p>如果指定*–inactive<em>，列表将过滤为域关闭时拍摄的快照。如果指定</em>–active<em>，列表将过滤为域运行时拍摄的快照，并且快照包含恢复到该运行状态的内存状态。如果指定</em>–disk-only*，列表将过滤为域运行时拍摄的快照，但快照只包含磁盘状态。</p>
<p>如果指定*–internal<em>，列表将过滤为使用现有磁盘映像内部存储的快照。如果指定</em>–external*，列表将过滤为使用外部文件存储磁盘映像或内存状态的快照。</p>
<hr>
<p><strong>snapshot-dumpxml</strong><br><strong>语法：</strong><br>snapshot-dumpxml [–security-info] [–xpath 表达式] [–wrap] 域 快照<br>输出域的快照<em>快照</em>的XML。使用*–security-info*还会包含安全敏感信息。使用snapshot-current可以轻松访问当前快照的XML。</p>
<p>如果 <strong>–xpath</strong>参数提供XPath表达式，它将对输出XML求值，并且只打印匹配的节点。默认行为是将每个匹配节点打印为独立文档，但是为了便于进一步处理，**–wrap**参数将导致匹配节点包装在公共根节点中。</p>
<hr>
<p><strong>snapshot-parent</strong><br><strong>语法：</strong><br>snapshot-parent 域 {快照 | –current}<br>输出给定<em>快照</em>的父快照名称（如果有），或使用*–current*的当前快照。</p>
<hr>
<p><strong>snapshot-revert</strong><br><strong>语法：</strong><br>snapshot-revert 域 {快照 | –current} [{–running | –paused}] [–force] [–reset-nvram]<br>将给定域恢复到<em>快照</em>指定的快照，或使用*–current*的当前快照。请注意，这是一个破坏性操作；自上次快照以来的任何域更改都将丢失。还要注意，snapshot-revert完成后域的状态将是原始快照拍摄时的域状态。</p>
<p>通常，恢复到快照会使域处于创建快照时的状态，除了没有虚拟机状态的磁盘快照会使域处于非活动状态。传递*–running<em>或</em>–paused*标志将执行额外的状态更改（如启动非活动域或暂停运行域）。由于临时域不能处于非活动状态，因此在恢复到临时域的磁盘快照时必须使用这些标志之一。</p>
<p>自libvirt 7.10.0起，VM进程总是会重新启动，因此以下段落不再有效。如果快照元数据缺少完整的VM XML，则不再可能恢复到这样的快照。</p>
<p>有许多情况下，快照恢复涉及额外风险，需要使用*–force*继续：</p>
<ul>
<li>一种是快照缺少恢复配置的完整域信息的情况（如libvirt 0.9.5之前创建的快照）；由于libvirt无法证明当前配置与快照时使用的配置匹配，提供*–force*向libvirt保证快照与当前配置兼容（如果不兼容，域可能会运行失败）。</li>
<li>另一种是从运行域恢复到活动状态的情况，需要创建新的虚拟机监控程序而不是重用现有的虚拟机监控程序，因为它意味着诸如中断现有VNC或Spice连接等缺点；当活动快照使用明显不兼容的配置时，或者与非活动快照结合使用*–start<em>或</em>–pause*标志时，会发生这种情况。</li>
<li>此外，libvirt会拒绝在有托管保存状态时恢复非活动QEMU域的快照。这是因为这些快照不包含内存状态，因此不会替换现有的内存状态。这最终会在运行系统下切换磁盘，并且由于运行时交换内容不匹配，可能会导致大量文件系统损坏或崩溃。</li>
</ul>
<p>如果指定*–reset-nvram*，任何现有的NVRAM文件将被删除并从其原始模板重新初始化。</p>
<hr>
<p><strong>snapshot-delete</strong><br><strong>语法：</strong><br>snapshot-delete 域 {快照 | –current} [–metadata] [{–children | –children-only}]<br>删除域名为<em>快照</em>的快照，或使用*–current<em>的当前快照。如果此快照有子快照，此快照的更改将合并到子快照中。如果传递</em>–children<em>，则删除此快照及其任何子快照。如果传递</em>–children-only*，则删除此快照的任何子快照，但保留此快照完整。这两个标志是互斥的。</p>
<p>如果指定*–metadata*，则只删除libvirt维护的快照元数据，而保留快照内容供外部工具访问；否则删除快照还会删除该时间点的数据内容。</p>
<hr>
<h1 id="15-检查点命令"><a href="#15-检查点命令" class="headerlink" title="15 检查点命令"></a>15 <strong>检查点命令</strong></h1><p>以下命令用于操作域检查点。检查点作为时间点标识客户机磁盘在该时间点后发生了哪些变化，从而可以执行增量和差异备份。检查点通过唯一名称标识。关于用于表示检查点属性的XML格式文档，请参阅<a target="_blank" rel="noopener" href="https://libvirt.org/formatcheckpoint.html%E3%80%82">https://libvirt.org/formatcheckpoint.html。</a></p>
<p><strong>checkpoint-create</strong><br><strong>语法：</strong><br>checkpoint-create 域 [xml文件] { –redefine [–redefine-validate] | [–quiesce] }<br>为域<em>域</em>创建一个检查点，属性由<em>xml文件</em>描述一个<domaincheckpoint>顶级元素指定。输入XML文件的格式将根据内部RNG模式进行验证（与使用virt-xml-validate(1)工具相同）。如果完全省略<em>xmlfile</em>，那么libvirt将基于当前时间创建一个检查点名称。</p>
<p>如果指定*–redefine<em>，那么checkpoint-dumpxml生成的所有XML元素都有效；这可以用于将检查点层次结构从一台机器迁移到另一台机器，为临时域重新创建层次结构（临时域消失后又以相同名称和UUID重新创建），或者对检查点元数据进行微小修改（例如检查点中嵌入的域XML的主机特定方面）。使用此标志时，</em>xmlfile*参数是必需的。</p>
<p>如果同时指定*–redefine-validate<em>和</em>–redefine*，虚拟机监控程序将对存储在检查点XML之外的其他位置的检查点相关元数据进行验证。注意某些虚拟机监控程序可能要求域处于运行状态才能执行验证。</p>
<p>如果指定*–quiesce*，libvirt将尝试使用客户代理来冻结和解冻域的挂载文件系统。但是，如果域没有客户代理，检查点创建将失败。</p>
<p>检查点元数据的存在会阻止尝试取消定义持久客户。但是，对于临时域，当域停止运行时（无论是通过destroy等命令还是内部客户操作），检查点元数据会静默丢失。</p>
<p>目前，无法在具有快照的域中创建检查点，尽管此限制将在未来版本中取消。</p>
<hr>
<p><strong>checkpoint-create-as</strong><br><strong>语法：</strong><br>checkpoint-create-as 域 [–print-xml] [名称] [描述] [–quiesce] [–diskspec 磁盘规格]…<br>为域<em>域</em>创建一个具有给定<name>和<description>的检查点；如果省略任一值，libvirt将选择一个值。如果指定*–print-xml<em>，则输出适合</em>checkpoint-create*的XML，而不是实际创建检查点。</p>
<p><em>–diskspec</em>选项可用于控制哪些客户磁盘参与检查点。此选项可以出现多次，根据域xml中<disk>元素的数量。每个<diskspec>的格式为磁盘[,checkpoint&#x3D;类型][,bitmap&#x3D;名称]。除非同时存在<em>域</em>、<em>名称</em>和<em>描述</em>，否则必须在每个diskspec前加上字面的*–diskspec*。例如，diskspec为”vda,checkpoint&#x3D;bitmap,bitmap&#x3D;map1”会生成以下XML：</p>
<disk name='vda' checkpoint='bitmap' bitmap='map1'/>

<p>如果指定*–quiesce*，libvirt将尝试使用客户代理来冻结和解冻域的挂载文件系统。但是，如果域没有客户代理，检查点创建将失败。</p>
<p>目前，无法在具有快照的域中创建检查点，尽管此限制将在未来版本中取消。</p>
<hr>
<p><strong>checkpoint-edit</strong><br><strong>语法：</strong><br>checkpoint-edit 域 检查点名称<br>编辑域<em>检查点名称</em>的XML配置文件。</p>
<p>这相当于：</p>
<p>virsh checkpoint-dumpxml dom 名称 &gt; checkpoint.xml<br>vi checkpoint.xml（或用其他文本编辑器进行更改）<br>virsh checkpoint-create dom checkpoint.xml –redefine</p>
<p>只是它会进行一些错误检查，包括编辑不应尝试更改检查点名称。</p>
<p>使用的编辑器可以由$VISUAL或$EDITOR环境变量提供，默认为vi。</p>
<hr>
<p><strong>checkpoint-info</strong><br><strong>语法：</strong><br>checkpoint-info 域 检查点<br>输出命名&lt;检查点&gt;的基本信息。</p>
<hr>
<p><strong>checkpoint-list</strong><br><strong>语法：</strong><br>checkpoint-list 域 [{–parent | –roots | [{–tree | –name}]}] [–topological] [[–from] 检查点 | [–descendants]] [–leaves] [–no-leaves]<br>列出给定域的所有可用检查点，默认显示检查点名称和创建时间的列。</p>
<p>通常，表格形式的输出按检查点名称排序；使用*–topological*则会排序，使得没有子检查点在其祖先之前列出（尽管可能有多个满足此属性的排序）。</p>
<p>如果指定*–parent<em>，则在输出表中添加一列，给出每个检查点的父检查点名称。如果指定</em>–roots<em>，列表将过滤为只有没有父检查点的检查点。如果指定</em>–tree*，输出将以树形格式显示，只列出检查点名称。这三个选项是互斥的。</p>
<p>如果指定*–name<em>，则只打印检查点名称，如果同时使用</em>–parent<em>，则附加制表符分隔的父检查点名称。此选项与</em>–tree*互斥。</p>
<p>如果提供*–from<em>，则过滤列表为给定检查点的子检查点。单独使用或与</em>–parent<em>一起使用时，除非同时存在</em>–descendants<em>，否则列表仅限于直接子检查点。与</em>–tree<em>一起使用时，隐含</em>–descendants<em>的使用。此选项与</em>–roots<em>不兼容。注意</em>–from<em>的起点不包括在列表中，除非同时存在</em>–tree*选项。</p>
<p>如果指定*–leaves<em>，列表将过滤为只有没有子检查点的检查点。同样，如果指定</em>–no-leaves<em>，列表将过滤为只有有子检查点的检查点。（注意同时省略这两个选项不进行过滤，而同时提供这两个选项将根据服务器是否识别标志而产生相同列表或出错）。过滤选项与</em>–tree*不兼容。</p>
<hr>
<p><strong>checkpoint-dumpxml</strong><br><strong>语法：</strong><br>checkpoint-dumpxml [–security-info] [–no-domain] [–size] [–xpath 表达式] [–wrap] 域 检查点<br>输出域名为<em>检查点</em>的检查点XML。使用*–security-info*还会包含安全敏感信息。</p>
<p>使用*–size<em>将添加XML指示自创建检查点以来客户数据已更改的当前字节大小（尽管请记住在检查大小和实际创建备份之间的客户活动可能导致备份需要稍多空间）。注意某些虚拟机监控程序可能要求在使用</em>–size<em>时</em>域*处于运行状态。</p>
<p>使用*–no-domain*将从输出中省略<domain>元素以获得更紧凑的视图。</p>
<p>如果 <strong>–xpath</strong>参数提供XPath表达式，它将对输出XML求值，并且只打印匹配的节点。默认行为是将每个匹配节点打印为独立文档，但是为了便于进一步处理，**–wrap**参数将导致匹配节点包装在公共根节点中。</p>
<hr>
<p><strong>checkpoint-parent</strong><br><strong>语法：</strong><br>checkpoint-parent 域 检查点<br>输出给定<em>检查点</em>的父检查点名称（如果有）。</p>
<hr>
<p><strong>checkpoint-delete</strong><br><strong>语法：</strong><br>checkpoint-delete 域 检查点 [–metadata] [{–children | –children-only}]<br>删除域名为<em>检查点</em>的检查点。自检查点以来磁盘哪些部分发生更改的记录将合并到父检查点（如果有）。如果传递*–children<em>，则删除此检查点及其任何子检查点。如果传递</em>–children-only*，则删除此检查点的任何子检查点，但保留此检查点完整。这两个标志是互斥的。</p>
<p>如果指定*–metadata*，则只删除libvirt维护的检查点元数据，而保留检查点内容供外部工具访问；否则删除检查点还会移除从该时间点执行增量备份的能力。</p>
<hr>
<h1 id="16-网络过滤器命令"><a href="#16-网络过滤器命令" class="headerlink" title="16 网络过滤器命令"></a>16 <strong>网络过滤器命令</strong></h1><p>以下命令用于操作网络过滤器。网络过滤器允许过滤来自虚拟机和发往虚拟机的网络流量。单个网络流量过滤器以XML编写，可能包含对其他网络过滤器的引用、描述流量过滤规则或两者兼有。网络过滤器由虚拟机从其接口描述中引用。一个网络过滤器可以被多个虚拟机的接口引用。</p>
<p><strong>nwfilter-define</strong><br><strong>语法：</strong><br>nwfilter-define xml文件 [–validate]<br>使新的网络过滤器为libvirt所知。如果已存在同名网络过滤器，将被新XML替换。任何引用此网络过滤器的运行虚拟机将调整其网络流量规则。如果任何运行虚拟机无法实例化网络流量过滤规则，则新XML将被拒绝。</p>
<p>可选地，可以使用*–validate*验证输入XML文件的格式是否符合内部RNG模式。</p>
<hr>
<p><strong>nwfilter-undefine</strong><br><strong>语法：</strong><br>nwfilter-undefine 网络过滤器名称<br>删除网络过滤器。如果任何运行虚拟机当前正在使用此网络过滤器，删除将失败。</p>
<hr>
<p><strong>nwfilter-list</strong><br><strong>语法：</strong><br>nwfilter-list<br>列出所有可用的网络过滤器。</p>
<hr>
<p><strong>nwfilter-dumpxml</strong><br><strong>语法：</strong><br>nwfilter-dumpxml [–xpath 表达式] [–wrap] 网络过滤器名称<br>输出网络过滤器XML。</p>
<p>如果 <strong>–xpath</strong> 参数提供XPath表达式，它将对输出XML求值，并且只打印匹配的节点。默认行为是将每个匹配节点打印为独立文档，但是为了便于进一步处理，**–wrap**参数将导致匹配节点包装在公共根节点中。</p>
<hr>
<p><strong>nwfilter-edit</strong><br><strong>语法：</strong><br>nwfilter-edit 网络过滤器名称<br>编辑网络过滤器的XML。</p>
<p>这相当于：</p>
<p>virsh nwfilter-dumpxml myfilter &gt; myfilter.xml<br>vi myfilter.xml（或用其他文本编辑器进行更改）<br>virsh nwfilter-define myfilter.xml<br>只是它会进行一些错误检查。新网络过滤器可能会由于与<em>nwfilter-define</em>中提到的相同原因被拒绝。</p>
<p>使用的编辑器可以由$VISUAL或$EDITOR环境变量提供，默认为vi。</p>
<hr>
<h1 id="17-网络过滤器绑定命令"><a href="#17-网络过滤器绑定命令" class="headerlink" title="17 网络过滤器绑定命令"></a>17 <strong>网络过滤器绑定命令</strong></h1><p>以下命令用于操作网络过滤器绑定。网络过滤器绑定跟踪网络端口与网络过滤器之间的关联。通常绑定由虚拟机监控程序驱动程序在客户机上添加&#x2F;删除NIC时自动管理。</p>
<p>但是，如果管理员为非客户机使用创建&#x2F;删除TAP设备，网络过滤器绑定命令提供了一种直接使用网络过滤器的方式。</p>
<p><strong>nwfilter-binding-create</strong><br><strong>语法：</strong><br>nwfilter-binding-create xml文件 [–validate]<br>将网络端口与网络过滤器关联。网络过滤器后端将立即尝试在端口上实例化过滤规则。此命令可用于为当前运行但未为特定网络端口定义过滤器的客户机关联过滤器。由于绑定通常由虚拟机监控程序自动管理，使用此命令为网络端口定义过滤器然后启动客户机可能会阻止客户机启动，如果它尝试使用网络端口并发现已定义过滤器。</p>
<p>可选地，可以使用*–validate*验证输入XML文件的格式是否符合内部RNG模式。</p>
<hr>
<p><strong>nwfilter-binding-delete</strong><br><strong>语法：</strong><br>nwfilter-binding-delete 端口名称<br>解除网络端口与网络过滤器的关联。网络过滤器后端将立即拆除端口上存在的过滤规则。此命令可用于在客户机运行时移除网络端口绑定过滤器而无需重新启动客户机。通过使用<em>nwfilter-binding-create</em>可以恢复运行客户机的网络端口绑定过滤器。</p>
<hr>
<p><strong>nwfilter-binding-list</strong><br><strong>语法：</strong><br>nwfilter-binding-list<br>列出所有关联了过滤器的网络端口。</p>
<hr>
<p><strong>nwfilter-binding-dumpxml</strong><br><strong>语法：</strong><br>nwfilter-binding-dumpxml [–xpath 表达式] [–wrap] 端口名称<br>输出名为端口名称的网络设备的网络过滤器绑定XML。</p>
<p>如果 <strong>–xpath</strong> 参数提供XPath表达式，它将对输出XML求值，并且只打印匹配的节点。默认行为是将每个匹配节点打印为独立文档，但是为了便于进一步处理，**–wrap**参数将导致匹配节点包装在公共根节点中。</p>
<hr>
<h1 id="18-虚拟机监控程序专用命令"><a href="#18-虚拟机监控程序专用命令" class="headerlink" title="18 虚拟机监控程序专用命令"></a>18 <strong>虚拟机监控程序专用命令</strong></h1><p>注意：强烈建议不要使用以下命令。它们可能导致 libvirt 在后续操作中出现混乱或错误行为。一旦使用了这些命令，请不要向 libvirt 开发者报告问题，相关报告将被忽略。如果您发现这些命令是完成某项任务的唯一方式，建议您请求将该功能作为正式特性添加到常规 libvirt 库中。</p>
<p><strong>qemu-attach</strong><br><strong>语法：</strong><br>qemu-attach pid<br>将外部启动的 QEMU 进程附加到 libvirt QEMU 驱动程序中。QEMU 进程必须已使用 UNIX 驱动程序创建监控连接。理想情况下，该进程还应指定 <code>-name</code> 参数。<br>示例：<br>$ qemu-kvm -cdrom ~&#x2F;demo.iso \<br>-monitor unix:&#x2F;tmp&#x2F;demo,server,nowait \<br>-name foo \<br>-uuid cece4f9f-dff0-575d-0e8e-01fe380f12ea &amp;<br>$ QEMUPID&#x3D;$!<br>$ virsh qemu-attach $QEMUPID  </p>
<p>并非所有 libvirt 功能在附加到外部启动的 QEMU 进程后都能可靠工作。迁移时可能会出现客户机 ABI 更改的问题，设备热插拔或热拔可能无法正常工作。附加的环境应被视为主要是只读的。</p>
<hr>
<p><strong>qemu-monitor-command</strong><br><strong>语法：</strong><br>qemu-monitor-command 域 { [–hmp] | [–pretty] [–return-value] }<br>[–pass-fds N,M,…] 命令…<br>通过 QEMU 监控器向指定的域发送任意监控命令。命令的结果将打印在标准输出上。  </p>
<p>如果为命令提供了多个参数，它们会在传递给监控器之前用空格连接成一个命令。  </p>
<p>注意，libvirt 使用 QMP 与 QEMU 通信，因此命令必须是有效的 QMP 格式 JSON 才能正常工作。如果命令不是 JSON 对象，libvirt 会尝试将其包装为 JSON 对象，以提供方便的接口，例如处理方式相同的命令组：  </p>
<p>简单命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\$ virsh qemu-monitor-command VM 命令名  </span><br><span class="line">\$ virsh qemu-monitor-command VM <span class="string">&#x27;&#123;&quot;execute&quot;:&quot;命令名&quot;&#125;&#x27;</span>  </span><br></pre></td></tr></table></figure>

<p>带参数的命令：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\$ virsh qemu-monitor-command VM 命令名 <span class="string">&#x27;&quot;arg1&quot;:123&#x27;</span> <span class="string">&#x27;&quot;arg2&quot;:&quot;test&quot;&#x27;</span>  </span><br><span class="line">\$ virsh qemu-monitor-command VM 命令名 <span class="string">&#x27;&#123;&quot;arg1&quot;:123,&quot;arg2&quot;:&quot;test&quot;&#125;&#x27;</span>  </span><br><span class="line">\$ virsh qemu-monitor-command VM <span class="string">&#x27;&#123;&quot;execute&quot;:&quot;命令名&quot;, &quot;arguments&quot;:&#123;&quot;arg1&quot;:123,&quot;arg2&quot;:&quot;test&quot;&#125;&#125;&#x27;</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果指定 <code>--pretty</code>，QMP 回复会以美观格式打印。<br>如果指定 <code>--return-value</code>，将从 QMP 响应对象中提取 <code>&#39;return&#39;</code> 键，而不是传递完整的 QEMU 回复。<br>如果指定 <code>--hmp</code>，命令将被视为人类监控命令，libvirt 会自动将其转换为 QMP 并将结果转换回来。<br>如果指定 <code>--pass-fds</code>，参数是一个逗号分隔的打开文件描述符列表，这些文件描述符将与命令一起传递给 QEMU。  </p>
<p><strong>qemu-agent-command</strong><br><strong>语法：</strong><br>qemu-agent-command 域 [–timeout 秒数 | –async | –block] 命令…<br>通过 QEMU 代理向指定的域发送任意客户机代理命令。<code>--timeout</code>、<code>--async</code> 和 <code>--block</code> 选项是互斥的。<code>--timeout</code> 需要指定正数的超时秒数。当使用 <code>--async</code> 时，命令会等待超时，无论成功或失败。当使用 <code>--block</code> 时，命令会无限期阻塞等待。  </p>
<hr>
<p><strong>qemu-monitor-event</strong><br><strong>语法：</strong><br>qemu-monitor-event [域] [–event 事件名]<br>[–loop] [–timeout 秒数] [–pretty] [–regex] [–no-case]<br>[–timestamp]  </p>
<p>等待任意 QEMU 监控事件发生，并在事件发生时打印详细信息。可以通过域或事件名对事件进行筛选。可以通过 <code>qemu-monitor-command</code> 使用 <code>&#39;query-events&#39;</code> QMP 命令了解支持的事件。如果使用 <code>--regex</code>，事件名是基本正则表达式而不是字面字符串。如果使用 <code>--no-case</code>，事件名将不区分大小写匹配。  </p>
<p>默认情况下，此命令是一次性的，一旦事件发生即返回成功；可以通过发送 SIGINT（通常为 Ctrl-C）立即退出。如果指定 <code>--timeout</code>，命令会在指定秒数后放弃等待事件。使用 <code>--loop</code> 时，命令会打印所有事件，直到超时或中断。如果指定 <code>--pretty</code>，任何 JSON 事件细节会以美观格式打印以提高可读性。  </p>
<p>当使用 <code>--timestamp</code> 时，会在事件前打印人类可读的时间戳，并省略 QEMU 提供的时间信息。  </p>
<hr>
<p><strong>lxc-enter-namespace</strong><br><strong>语法：</strong><br>lxc-enter-namespace 域 [–noseclabel] –<br>&#x2F;path&#x2F;to&#x2F;binary [参数1, [参数2, …]]<br>进入指定域的命名空间并执行命令 <code>/path/to/binary</code>，传递指定的参数。二进制路径是相对于容器根文件系统的，而不是主机根文件系统。二进制文件会继承 virsh 可见的环境变量和控制台。命令将以与容器内进程相同的 sVirt 上下文和 cgroups 位置运行。此命令仅在连接到 LXC 虚拟机监控程序驱动程序时有效。仅当 <code>/path/to/binary</code> 的退出状态为 0 时，此命令才会成功。  </p>
<p>默认情况下，新进程将以新父容器的安全标签运行。使用 <code>--noseclabel</code> 选项可以让进程保持与 virsh 相同的安全标签。  </p>
<hr>
<h1 id="19-环境变量"><a href="#19-环境变量" class="headerlink" title="19 环境变量"></a>19 <strong>环境变量</strong></h1><p>以下环境变量可以设置以改变 virsh 的行为：  </p>
<ul>
<li><p>VIRSH_DEBUG&#x3D;&lt;0 到 4&gt;<br>启用 virsh 命令的详细调试。有效级别为：  </p>
<ul>
<li>VIRSH_DEBUG&#x3D;0<br>DEBUG - 记录所有级别的消息  </li>
<li>VIRSH_DEBUG&#x3D;1<br>INFO - 记录 INFO、NOTICE、WARNING 和 ERROR 级别的消息  </li>
<li>VIRSH_DEBUG&#x3D;2<br>NOTICE - 记录 NOTICE、WARNING 和 ERROR 级别的消息  </li>
<li>VIRSH_DEBUG&#x3D;3<br>WARNING - 记录 WARNING 和 ERROR 级别的消息  </li>
<li>VIRSH_DEBUG&#x3D;4<br>ERROR - 仅记录 ERROR 级别的消息</li>
</ul>
</li>
<li><p>VIRSH_LOG_FILE&#x3D;<code>LOGFILE</code><br>  记录 virsh 调试消息的文件。  </p>
</li>
<li><p>VIRSH_DEFAULT_CONNECT_URI<br>  默认连接的虚拟机监控程序。设置为 URI，格式与 connect 选项接受的格式相同。此环境变量已弃用，推荐使用全局变量 LIBVIRT_DEFAULT_URI，其功能相同。  </p>
</li>
<li><p>LIBVIRT_DEFAULT_URI<br>  默认连接的虚拟机监控程序。设置为 URI，格式与 connect 选项接受的格式相同。这会覆盖任何客户端配置文件中的默认 URI，并阻止 libvirt 探测驱动程序。  </p>
</li>
<li><p>VISUAL<br>edit 及相关选项使用的编辑器。  </p>
</li>
<li><p>EDITOR<br>如果未设置 VISUAL，edit 及相关选项使用的编辑器。  </p>
</li>
<li><p>VIRSH_HISTSIZE<br>命令历史记录中记住的命令数量。默认值为 500。  </p>
</li>
<li><p>LIBVIRT_DEBUG&#x3D;LEVEL<br>启用所有 libvirt API 调用的详细调试。有效级别为：  </p>
<ul>
<li>LIBVIRT_DEBUG&#x3D;1<br>DEBUG 及以上级别的消息  </li>
<li>LIBVIRT_DEBUG&#x3D;2<br>INFO 及以上级别的消息  </li>
<li>LIBVIRT_DEBUG&#x3D;3<br>WARNING 及以上级别的消息  </li>
<li>LIBVIRT_DEBUG&#x3D;4<br>ERROR 及以上级别的消息</li>
</ul>
</li>
</ul>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://watsonlu6.github.io/libvirt%E6%96%87%E6%A1%A3/13-virsh%E4%BD%BF%E7%94%A8/" title="13 virsh使用" target="_blank" rel="external">https://watsonlu6.github.io/libvirt文档/13-virsh使用/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/watsonLu6/" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/watsonLu6/" target="_blank"><span class="text-dark">watson</span><small class="ml-1x">Cloud computing development engineer</small></a></h3>
        <div>内心要狂热，头脑要冷静，四肢要发达</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    
    <li class="next">
      <a href="/libvirt%E6%96%87%E6%A1%A3/12-libvirt%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/" title="12 libvirt使用示例"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/watsonLu6/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>