<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>1 libvirt概述 | watson Lu&#39;blogs</title>
  <meta name="description" content="1 概述virsh [选项]… [命令字符串] virsh [选项]… 命令 [参数]… 2 描述virsh 程序是用于管理 virsh 客户域的主要接口。该程序可用于创建、暂停和关闭域，还可以用于列出当前域。Libvirt 是一个 C 工具包，用于与 Linux（及其他操作系统）最新版本的虚拟化功能交互。它是在 GNU 宽通用公共许可证下可用的免费软件。Linux 操作系统的虚拟化意味着能够在单">
<meta property="og:type" content="article">
<meta property="og:title" content="1 libvirt概述">
<meta property="og:url" content="https://watsonlu6.github.io/libvirt%E6%96%87%E6%A1%A3/13-virsh%E4%BD%BF%E7%94%A8/index.html">
<meta property="og:site_name" content="watson&#39;blogs">
<meta property="og:description" content="1 概述virsh [选项]… [命令字符串] virsh [选项]… 命令 [参数]… 2 描述virsh 程序是用于管理 virsh 客户域的主要接口。该程序可用于创建、暂停和关闭域，还可以用于列出当前域。Libvirt 是一个 C 工具包，用于与 Linux（及其他操作系统）最新版本的虚拟化功能交互。它是在 GNU 宽通用公共许可证下可用的免费软件。Linux 操作系统的虚拟化意味着能够在单">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-04-01T07:50:26.000Z">
<meta property="article:modified_time" content="2025-04-26T13:47:35.594Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="云计算">
<meta property="article:tag" content="libvirt">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="https://watsonlu6.github.io/libvirt%E6%96%87%E6%A1%A3/13-virsh%E4%BD%BF%E7%94%A8/index.html">
  
    <link rel="alternate" href="/atom.xml" title="watson&#39;blogs" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 7.3.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/watsonLu6/" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">watson</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Cloud computing development engineer</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> BeiJing, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/watsonLu6/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA%E7%94%9F%E6%B4%BB/">个人生活</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%91%E5%AD%98%E5%82%A8/">云存储</a><span class="category-list-count">29</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%91%E5%AD%98%E5%82%A8/Ceph/">Ceph</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%91%E5%AD%98%E5%82%A8/%E5%AD%98%E5%82%A8%E5%9F%BA%E7%A1%80/">存储基础</a><span class="category-list-count">5</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</a><span class="category-list-count">13</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/libvirt/">libvirt</a><span class="category-list-count">13</span></li></ul></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ceph/" rel="tag">Ceph</a><span class="tag-list-count">24</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/libvirt/" rel="tag">libvirt</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AA%E4%BA%BA%E7%94%9F%E6%B4%BB/" rel="tag">个人生活</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%91%E5%AD%98%E5%82%A8/" rel="tag">云存储</a><span class="tag-list-count">29</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/" rel="tag">云计算</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%98%E5%82%A8%E5%9F%BA%E7%A1%80/" rel="tag">存储基础</a><span class="tag-list-count">5</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/Ceph/" style="font-size: 13.75px;">Ceph</a> <a href="/tags/libvirt/" style="font-size: 13.5px;">libvirt</a> <a href="/tags/%E4%B8%AA%E4%BA%BA%E7%94%9F%E6%B4%BB/" style="font-size: 13px;">个人生活</a> <a href="/tags/%E4%BA%91%E5%AD%98%E5%82%A8/" style="font-size: 14px;">云存储</a> <a href="/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/" style="font-size: 13.5px;">云计算</a> <a href="/tags/%E5%AD%98%E5%82%A8%E5%9F%BA%E7%A1%80/" style="font-size: 13.25px;">存储基础</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">四月 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">三月 2024</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a><span class="archive-list-count">5</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/libvirt/">libvirt</a>
              </p>
              <p class="item-title">
                <a href="/libvirt%E6%96%87%E6%A1%A3/13-virsh%E4%BD%BF%E7%94%A8/" class="title">1 libvirt概述</a>
              </p>
              <p class="item-date">
                <time datetime="2024-04-01T07:50:26.000Z" itemprop="datePublished">2024-04-01</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/libvirt/">libvirt</a>
              </p>
              <p class="item-title">
                <a href="/libvirt%E6%96%87%E6%A1%A3/12-libvirt%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/" class="title">12 libvirt使用示例</a>
              </p>
              <p class="item-date">
                <time datetime="2024-03-12T07:50:26.000Z" itemprop="datePublished">2024-03-12</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/libvirt/">libvirt</a>
              </p>
              <p class="item-title">
                <a href="/libvirt%E6%96%87%E6%A1%A3/11-libvirt%E8%B0%83%E8%AF%95%E4%B8%8E%E6%97%A5%E5%BF%97/" class="title">11 libvirt调试与日志</a>
              </p>
              <p class="item-date">
                <time datetime="2024-03-11T07:50:26.000Z" itemprop="datePublished">2024-03-11</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/libvirt/">libvirt</a>
              </p>
              <p class="item-title">
                <a href="/libvirt%E6%96%87%E6%A1%A3/10-libvirt%E5%AE%89%E5%85%A8%E6%A8%A1%E5%BC%8F/" class="title">10 libvirt安全模式</a>
              </p>
              <p class="item-date">
                <time datetime="2024-03-10T07:50:26.000Z" itemprop="datePublished">2024-03-10</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/libvirt/">libvirt</a>
              </p>
              <p class="item-title">
                <a href="/libvirt%E6%96%87%E6%A1%A3/9-libvirt%E4%BA%8B%E4%BB%B6%E5%92%8C%E8%AE%A1%E6%97%B6%E5%99%A8%E5%A4%84%E7%90%86/" class="title">9 libvirt事件和计时器处理</a>
              </p>
              <p class="item-date">
                <time datetime="2024-03-09T07:50:26.000Z" itemprop="datePublished">2024-03-09</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-libvirt文档/13-virsh使用" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      1 libvirt概述
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/libvirt%E6%96%87%E6%A1%A3/13-virsh%E4%BD%BF%E7%94%A8/" class="article-date">
	  <time datetime="2024-04-01T07:50:26.000Z" itemprop="datePublished">2024-04-01</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</a>►<a class="article-category-link" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/libvirt/">libvirt</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/libvirt/" rel="tag">libvirt</a>, <a class="article-tag-link-link" href="/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/" rel="tag">云计算</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/libvirt%E6%96%87%E6%A1%A3/13-virsh%E4%BD%BF%E7%94%A8/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 <strong>概述</strong></h1><p>virsh [<em>选项</em>]… [<em>命令字符串</em>]</p>
<p>virsh [<em>选项</em>]… <em>命令</em> [<em>参数</em>]…</p>
<h1 id="2-描述"><a href="#2-描述" class="headerlink" title="2 描述"></a>2 <strong>描述</strong></h1><p>virsh 程序是用于管理 virsh 客户域的主要接口。该程序可用于创建、暂停和关闭域，还可以用于列出当前域。Libvirt 是一个 C 工具包，用于与 Linux（及其他操作系统）最新版本的虚拟化功能交互。它是在 GNU 宽通用公共许可证下可用的免费软件。Linux 操作系统的虚拟化意味着能够在单个硬件系统上同时运行多个操作系统实例，其中基本资源由 Linux 实例驱动。该库旨在提供长期稳定的 C API。目前支持 Xen、QEMU、KVM、LXC、OpenVZ、VirtualBox 和 VMware ESX。</p>
<p>大多数 virsh 使用的基本结构如下：</p>
<p>virsh [<em>选项</em>]… &lt;*命令*&gt; &lt;*域*&gt; [<em>参数</em>]…</p>
<p>其中，<em>命令</em> 是下面列出的命令之一；<em>域</em> 是数字域 ID、域名或域 UUID；<em>参数</em> 是特定于命令的选项。少数例外情况是命令作用于所有域、整个机器或直接作用于 Xen 虚拟机管理程序时。这些例外情况将在相关命令中明确说明。注意：可以为域指定数字名称，但这样做会导致域只能通过域 ID 识别。换句话说，如果提供数字值，它将被解释为域 ID，而不是名称。任何以 # 开头的 <em>命令</em> 将被视为注释并静默忽略，所有其他无法识别的 <em>命令</em> 将被诊断。</p>
<p>virsh 程序可以通过在 shell 命令行中提供命令及其参数来运行单个 <em>命令</em>，也可以通过 <em>命令字符串</em> 运行，<em>命令字符串</em> 是一个由多个 <em>命令</em> 操作及其参数组成的单个 shell 参数，命令之间用空格分隔，并用分号或换行符分隔，其中未引用的反斜杠换行对将被省略。在 <em>命令字符串</em> 中，virsh 理解与 shell 相同的单引号、双引号和反斜杠转义，但在创建单个 shell 参数时必须添加另一层 shell 转义，任何以未引用的 <em>#</em> 开头的单词将开始一个注释，直到换行符结束。如果在命令行中未给出命令，virsh 将启动一个最小的解释器等待输入命令，然后使用 quit 命令退出程序。</p>
<p>virsh 程序支持以下 <em>选项</em>。</p>
<p>-c, --connect <em>URI</em><br>连接到指定的 <em>URI</em>，类似于 connect 命令，而不是默认连接。</p>
<p>-d, --debug <em>级别</em><br>启用整数 <em>级别</em> 及更高级别的调试消息。<em>级别</em> 范围为 0 到 4（默认值）。有关每个 <em>级别</em> 的描述，请参阅下面 VIRSH_DEBUG 环境变量的文档。</p>
<p>-e, --escape <em>字符串</em><br>为 <em>console</em> 命令设置替代转义序列。默认使用 telnet 的 ^]。使用脱字符表示法时允许的字符为：字母字符、@、[、]、\、^、_。</p>
<p>-h, --help<br>忽略所有其他参数，并表现得像给出了 help 命令一样。</p>
<p>-k, --keepalive-interval <em>间隔</em><br>设置发送保活消息的 <em>间隔</em>（以秒为单位），以检查与服务器的连接是否仍然存活。将间隔设置为 0 会禁用客户端保活机制。</p>
<p>-K, --keepalive-count <em>计数</em><br>设置在服务器未响应的情况下可以发送保活消息的次数，而不会将连接标记为死亡。如果 <em>间隔</em> 设置为 0，则此设置无效。</p>
<p>-l, --log <em>文件</em><br>将日志详细信息输出到 <em>文件</em>。</p>
<p>-q, --quiet<br>避免额外的信息性消息。</p>
<p>-r, --readonly<br>使初始连接为只读，类似于 connect 命令的 <em>--readonly</em> 选项。</p>
<p>-t, --timing<br>输出每个命令的耗时信息。</p>
<p>-v, --version[&#x3D;short]<br>忽略所有其他参数，并打印 virsh 所使用的 libvirt 库的版本。</p>
<p>-V, --version&#x3D;long<br>忽略所有其他参数，并打印 virsh 所使用的 libvirt 库的版本以及编译的选项和驱动程序。</p>
<h1 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3 注意事项"></a>3 <strong>注意事项</strong></h1><p>大多数 virsh 操作依赖于 libvirt 库能够连接到已运行的 libvirtd 服务。通常可以使用命令 <code>service libvirtd start</code> 完成此操作。</p>
<p>由于与虚拟机管理程序通信所使用的通道，大多数 virsh 命令需要 root 权限才能运行。以非 root 用户身份运行将返回错误。</p>
<p>大多数 virsh 命令是同步执行的，除了 shutdown、setvcpus 和 setmem 等少数命令。在这些情况下，virsh 程序返回并不意味着操作已完成，必须定期轮询以检测客户机是否已完成操作。</p>
<p>virsh 致力于向后兼容。尽管 help 命令仅列出命令的首选用法，但如果旧版本的 virsh 支持命令或选项的替代拼写（例如 <em>--tunnelled</em> 而不是 <em>--tunneled</em>），则使用旧拼写的脚本将继续有效。</p>
<p>一些 virsh 命令接受可选的带单位的整数；如果未提供单位，则命令中会列出默认单位（出于历史原因，某些命令默认为字节，而其他命令默认为千字节）。以下不区分大小写的后缀可用于选择特定单位：</p>
<p>b, byte 字节 1<br>KB 千字节 1,000<br>k, KiB 千二进制字节 1,024<br>MB 兆字节 1,000,000<br>M, MiB 兆二进制字节 1,048,576<br>GB 吉字节 1,000,000,000<br>G, GiB 吉二进制字节 1,073,741,824<br>TB 太字节 1,000,000,000,000<br>T, TiB 太二进制字节 1,099,511,627,776<br>PB 拍字节 1,000,000,000,000,000<br>P, PiB 拍二进制字节 1,125,899,906,842,624<br>EB 艾字节 1,000,000,000,000,000,000<br>E, EiB 艾二进制字节 1,152,921,504,606,846,976</p>
<h1 id="4-通用命令"><a href="#4-通用命令" class="headerlink" title="4 通用命令"></a>4 <strong>通用命令</strong></h1><p>以下命令是通用的，即不特定于某个域。</p>
<p><strong>help</strong></p>
<p><strong>语法：</strong></p>
<p>help [命令或分组]</p>
<p>此命令列出每个 virsh 命令。不带选项使用时，所有命令将按相关类别分组显示，每行一个命令，并显示每个分组的关键字。</p>
<p>要仅显示特定分组的命令，请将该分组的关键字作为选项。例如：</p>
<p><strong>示例 1：</strong></p>
<p>virsh # help host</p>
<p>主机和虚拟机管理程序（帮助关键字 ‘host’）:</p>
<p>capabilities              显示功能<br>cpu-models                显示架构的 CPU 型号<br>connect                   连接到虚拟机管理程序<br>freecell                  NUMA 空闲内存<br>hostname                  打印虚拟机管理程序主机名<br>qemu-attach               附加到现有 QEMU 进程<br>qemu-monitor-command      QEMU 监视器命令<br>qemu-agent-command        QEMU 客户机代理命令<br>sysinfo                   打印虚拟机管理程序系统信息<br>uri                       打印虚拟机管理程序规范 URI  </p>
<p>要显示特定命令的详细信息，请将其名称作为选项。例如：</p>
<p><strong>示例 2：</strong></p>
<p>virsh # help list</p>
<p>名称<br>list - 列出域  </p>
<p>概要<br>list [–inactive] [–all]  </p>
<p>描述<br>返回域列表。  </p>
<p>选项<br>–inactive  列出非活动域<br>–all       列出非活动和活动域  </p>
<p><strong>quit, exit</strong></p>
<p><strong>语法：</strong></p>
<p>quit<br>exit  </p>
<p>退出交互式终端。  </p>
<p><strong>version</strong></p>
<p><strong>语法：</strong></p>
<p>version [–daemon]  </p>
<p>打印此构建的主要版本信息。如果指定 <em>–daemon</em>，则输出中会包含 libvirt 守护程序的版本。  </p>
<p><strong>示例：</strong></p>
<p>$ virsh version<br>Compiled against library: libvirt 1.2.3<br>Using library: libvirt 1.2.3<br>Using API: QEMU 1.2.3<br>Running hypervisor: QEMU 2.0.50  </p>
<p>$ virsh version –daemon<br>Compiled against library: libvirt 1.2.3<br>Using library: libvirt 1.2.3<br>Using API: QEMU 1.2.3<br>Running hypervisor: QEMU 2.0.50<br>Running against daemon: 1.2.6  </p>
<p><strong>cd</strong></p>
<p><strong>语法：</strong></p>
<p>cd [目录]  </p>
<p>将当前目录更改为 <em>目录</em>。cd 命令的默认目录是主目录，如果环境中没有 <em>HOME</em> 变量，则为根目录。  </p>
<p><strong>pwd</strong></p>
<p><strong>语法：</strong></p>
<p>pwd  </p>
<p>打印当前目录。  </p>
<p><strong>connect</strong></p>
<p><strong>语法：</strong></p>
<p>connect [URI] [–readonly]  </p>
<p>（重新）连接到虚拟机管理程序。当 shell 首次启动时，此命令会自动运行，并使用命令行中 -c 选项请求的 <em>URI</em> 参数。<em>URI</em> 参数指定如何连接到虚拟机管理程序。URI 文档 <a target="_blank" rel="noopener" href="https://libvirt.org/uri.html">https://libvirt.org/uri.html</a> 列出了支持的值，但最常见的有：  </p>
<ul>
<li><p>xen:&#x2F;&#x2F;&#x2F;system<br>用于连接到本地 Xen 虚拟机管理程序。  </p>
</li>
<li><p>qemu:&#x2F;&#x2F;&#x2F;system<br>以 root 身份连接到本地监督 QEMU 和 KVM 域的守护程序。  </p>
</li>
<li><p>qemu:&#x2F;&#x2F;&#x2F;session<br>以普通用户身份连接到其自己的 QEMU 和 KVM 域集。  </p>
</li>
<li><p>lxc:&#x2F;&#x2F;&#x2F;system<br>连接到本地 Linux 容器。</p>
</li>
</ul>
<p>要查找当前使用的 URI，请查看下面记录的 <em>uri</em> 命令。  </p>
<p>对于远程访问，请参阅 URI 文档 <a target="_blank" rel="noopener" href="https://libvirt.org/uri.html">https://libvirt.org/uri.html</a> 了解如何创建 URI。*–readonly* 选项允许只读连接。  </p>
<p><strong>uri</strong></p>
<p><strong>语法：</strong></p>
<p>uri  </p>
<p>打印虚拟机管理程序的规范 URI，在 shell 模式下可能有用。  </p>
<p><strong>hostname</strong></p>
<p><strong>语法：</strong></p>
<p>hostname  </p>
<p>打印虚拟机管理程序的主机名。  </p>
<p><strong>sysinfo</strong></p>
<p><strong>语法：</strong></p>
<p>sysinfo  </p>
<p>打印虚拟机管理程序的 XML 表示的系统信息（如果可用）。  </p>
<p><strong>nodeinfo</strong></p>
<p><strong>语法：</strong></p>
<p>nodeinfo  </p>
<p>返回有关节点的基本信息，例如 CPU 的数量和类型，以及物理内存的大小。  </p>
<p>强烈不建议使用此命令，因为提供的信息不能保证在所有硬件平台上都准确。  </p>
<p><em>CPU 频率</em> 值仅反映机器中第一个 CPU 当前的运行速度。此速度可能因 CPU 而异，并且会随着主机操作系统调整而变化。  </p>
<p>用于获取数据的数据结构不可扩展，因此仅支持全局节点&#x2F;插槽&#x2F;核心&#x2F;线程（插槽&#x2F;核心&#x2F;线程是每个 NUMA 节点）拓扑信息。如果主机 CPU 有任何进一步的分组（例如 die、集群等）或 NUMA 拓扑不对称，则数据结构无法真实表示系统。在这种情况下，将报告一个伪造的拓扑（节点 &#x3D; 1，插槽 &#x3D; 1，核心 &#x3D; 主机 CPU 数量，线程 &#x3D; 1），仅正确表示主机 CPU 总数。  </p>
<p>建议使用 <em>capabilities</em> 命令替代，该命令在 &#x2F;capabilities&#x2F;host&#x2F;topology XPath 下报告数据（频率除外）。  </p>
<p><strong>nodecpumap</strong></p>
<p><strong>语法：</strong></p>
<p>nodecpumap [–pretty]  </p>
<p>显示节点的 CPU 总数、在线 CPU 数量以及在线 CPU 列表。  </p>
<p>使用 <em>–pretty</em> 时，在线 CPU 将以范围形式打印，而不是列表形式。  </p>
<p><strong>nodecpustats</strong></p>
<p><strong>语法：</strong></p>
<p>nodecpustats [CPU] [–percent]  </p>
<p>返回节点的 CPU 统计信息。如果指定 <em>CPU</em>，则仅打印指定 CPU 的统计信息。如果指定 <em>–percent</em>，则打印每种 CPU 统计信息在 1 秒内的百分比。  </p>
<p><strong>nodememstats</strong></p>
<p><strong>语法：</strong></p>
<p>nodememstats [单元]  </p>
<p>返回节点的内存统计信息。如果指定 <em>单元</em>，则仅打印指定单元的统计信息。  </p>
<p><strong>nodesevinfo</strong></p>
<p><strong>语法：</strong></p>
<p>nodesevinfo  </p>
<p>报告有关节点的 AMD SEV 启动安全功能的信息（如果有）。其中一些信息也会在域功能 XML 文档中报告。  </p>
<p><strong>nodesuspend</strong></p>
<p><strong>语法：</strong></p>
<p>nodesuspend [目标] [持续时间]  </p>
<p>将节点（主机）置于系统范围的睡眠状态，并安排节点的实时时钟中断在指定的 <em>持续时间</em> 后恢复节点。<em>目标</em> 指定主机将挂起到的状态，可以是 “mem”（挂起到 RAM）、”disk”（挂起到磁盘）或 “hybrid”（挂起到 RAM 和磁盘）。<em>持续时间</em> 指定主机挂起的时间（以秒为单位），应至少为 60 秒。  </p>
<p><strong>node-memory-tune</strong></p>
<p><strong>语法：</strong></p>
<p>node-memory-tune [shm-pages-to-scan] [shm-sleep-millisecs] [shm-merge-across-nodes]  </p>
<p>允许显示或设置节点内存参数。<em>shm-pages-to-scan</em> 可用于设置共享内存服务在休眠前扫描的页数；<em>shm-sleep-millisecs</em> 可用于设置共享内存服务在下一次扫描前休眠的毫秒数；<em>shm-merge-across-nodes</em> 指定是否可以从不同的 NUMA 节点合并页。设置为 0 时，仅可以合并物理位于同一 NUMA 节点内存区域的页。设置为 1 时，可以合并所有节点的页。默认为 1。  </p>
<p>注意：当前“共享内存服务”仅指 KSM（内核同页合并）。  </p>
<p><strong>capabilities</strong></p>
<p><strong>语法：</strong></p>
<p>capabilities [–xpath 表达式] [–wrap]  </p>
<p>打印描述当前连接的虚拟机管理程序功能的 XML 文档。这包括主机在 CPU 和功能方面的能力部分，以及每种可以虚拟化的客户机的描述集。更完整的描述请参阅：<br><a target="_blank" rel="noopener" href="https://libvirt.org/formatcaps.html">https://libvirt.org/formatcaps.html</a>  </p>
<p>XML 还显示 NUMA 拓扑信息（如果可用）。  </p>
<p>如果 <strong>–xpath</strong> 参数提供 XPath 表达式，则将对输出 XML 求值，并仅打印匹配的节点。默认行为是将每个匹配节点打印为独立文档，但为了方便进一步处理，**–wrap** 参数会将匹配节点包装在公共根节点中。  </p>
<p><strong>domcapabilities</strong></p>
<p><strong>语法：</strong></p>
<p>domcapabilities [virttype] [emulatorbin] [arch] [machine]<br>[–xpath 表达式] [–wrap]<br>[–disable-deprecated-features]  </p>
<p>打印描述当前连接的虚拟机管理程序域功能的 XML 文档，这些信息可以来自现有域或 virsh capabilities 输出。如果您打算创建新域并想知道它是否可以通过为特定模拟器和架构创建域来使用 VFIO，这可能很有用。  </p>
<p>每个虚拟机管理程序对哪些选项是必需的、哪些是可选的会有不同的要求。虚拟机管理程序可以支持为任何选项提供默认值。  </p>
<p><em>virttype</em> 选项指定使用的虚拟化类型。该值可以来自域 XML 中 &lt;domain&#x2F;&gt; 顶级元素的 ‘type’ 属性，也可以来自 virsh capabilities 输出中每个 &lt;guest&#x2F;&gt; 元素的 ‘type’ 属性。<em>emulatorbin</em> 选项指定模拟器的路径。该值可以来自域 XML 中的 &lt;emulator&gt; 元素或 virsh capabilities 输出。<em>arch</em> 选项指定用于域的架构。该值可以来自域 XML 中 &lt;os&#x2F;&gt; 元素和 &lt;type&#x2F;&gt; 子元素的 “arch” 属性，也可以来自 virsh capabilities 输出中 &lt;arch&#x2F;&gt; 元素的 “name” 属性。<em>machine</em> 指定模拟器的机器类型。该值可以来自域 XML 中 &lt;os&#x2F;&gt; 元素和 &lt;type&#x2F;&gt; 子元素的 “machine” 属性，也可以来自 virsh capabilities 输出中特定架构和域类型的机器列表。  </p>
<p>对于 QEMU 虚拟机管理程序，必须提供 <em>virttype</em> 为 ‘qemu’ 或 ‘kvm’ 以及 <em>emulatorbin</em> 或 <em>arch</em> 才能为默认 <em>machine</em> 生成输出。提供 <em>machine</em> 值将为特定机器生成输出。  </p>
<p>如果 <strong>–xpath</strong> 参数提供 XPath 表达式，则将对输出 XML 求值，并仅打印匹配的节点。默认行为是将每个匹配节点打印为独立文档，但为了方便进一步处理，**–wrap** 参数会将匹配节点包装在公共根节点中。  </p>
<p><strong>–disable-deprecated-features</strong> 参数将修改 host-model CPU XML 的内容，更新功能列表，其中包含虚拟机管理程序标记为已弃用的 CPU 模型的任何功能。这些功能将与 “disable” 策略配对。  </p>
<p><strong>pool-capabilities</strong></p>
<p><strong>语法：</strong></p>
<p>pool-capabilities  </p>
<p>打印描述连接的存储驱动程序存储池功能的 XML 文档。如果您打算创建新存储池并需要了解可用的池类型、支持的存储池源和目标卷格式以及创建池所需的源元素，这可能很有用。  </p>
<p><strong>inject-nmi</strong></p>
<p><strong>语法：</strong></p>
<p>inject-nmi 域  </p>
<p>向客户机注入 NMI。  </p>
<p><strong>list</strong></p>
<p><strong>语法：</strong></p>
<p>list [–inactive | –all]<br>[–managed-save] [–title]<br>{ [–table] | –name | –id } [–uuid]<br>[–persistent] [–transient]<br>[–with-managed-save] [–without-managed-save]<br>[–autostart] [–no-autostart]<br>[–with-snapshot] [–without-snapshot]<br>[–with-checkpoint] [–without-checkpoint]<br>[–state-running] [–state-paused]<br>[–state-shutoff] [–state-other]  </p>
<p>打印有关现有域的信息。如果未指定选项，则打印有关运行域的信息。  </p>
<p><strong>示例 1：</strong></p>
<p>列表的示例格式如下：  </p>
<p><code>virsh</code> list  </p>
<h2 id="Id-名称-状态"><a href="#Id-名称-状态" class="headerlink" title="Id   名称       状态  "></a>Id   名称       状态  </h2><p>0    Domain-0   running<br>2    fedora     paused  </p>
<p>名称是域的名称。ID 是域的数字 ID。状态是运行状态（见下文）。  </p>
<p><strong>状态</strong>  </p>
<p>状态字段列出每个域当前的状态。域可以处于以下可能的状态之一：  </p>
<ul>
<li><p>running<br>域当前正在 CPU 上运行。  </p>
</li>
<li><p>idle<br>域处于空闲状态，未运行或不可运行。这可能是由于域正在等待 I&#x2F;O（传统等待状态）或因为没有其他事情可做而进入睡眠状态。  </p>
</li>
<li><p>paused<br>域已暂停，通常是由于管理员运行 virsh suspend。在暂停状态下，域仍会消耗分配的资源（如内存），但没有资格由虚拟机管理程序调度。  </p>
</li>
<li><p>in shutdown<br>域正在关闭过程中，即客户操作系统已收到通知并应正在优雅地停止其操作。  </p>
</li>
<li><p>shut off<br>域未运行。通常这表示域已完全关闭或尚未启动。  </p>
</li>
<li><p>crashed<br>域已崩溃，这始终是暴力结束。通常只有在域配置为崩溃时不重启时才会出现此状态。  </p>
</li>
<li><p>pmsuspended<br>域已由客户电源管理暂停，例如进入 s3 状态。</p>
</li>
</ul>
<p>通常仅列出活动域。要列出非活动域，请指定 <em>–inactive</em> 或 <em>–all</em> 以同时列出活动和非活动域。  </p>
<p><strong>过滤</strong>  </p>
<p>要进一步过滤域列表，可以指定 list 命令支持的一个或多个过滤标志。这些标志按功能分组。从组中指定一个或多个标志会启用过滤组。注意，某些标志组合可能不会产生任何结果。支持的过滤标志和组：  </p>
<p><strong>持久性</strong><br>标志 <em>–persistent</em> 用于在返回的列表中包括持久客户机。要包括临时客户机，请指定 <em>–transient</em>。  </p>
<p><strong>托管保存映像的存在</strong><br>要列出具有托管保存映像的域，请指定标志 <em>–with-managed-save</em>。对于没有托管保存映像的域，请指定 <em>–without-managed-save</em>。  </p>
<p><strong>域状态</strong><br>以下过滤标志按状态选择域：*–state-running* 用于运行域，*–state-paused* 用于暂停域，*–state-shutoff* 用于关闭域，*–state-other* 用于所有其他状态作为后备。  </p>
<p><strong>自动启动域</strong><br>要列出自动启动域，请使用标志 <em>–autostart</em>。要列出禁用此功能的域，请使用 <em>–no-autostart</em>。  </p>
<p><strong>快照存在</strong><br>可以使用标志 <em>–with-snapshot</em> 列出具有快照映像的域，使用 <em>–without-snapshot</em> 列出没有快照的域。  </p>
<p><strong>检查点存在</strong><br>可以使用标志 <em>–with-checkpoint</em> 列出具有检查点的域，使用 <em>–without-checkpoint</em> 列出没有检查点的域。  </p>
<p>在与旧服务器通信时，此命令被迫使用一系列具有固有竞争的 API 调用，如果在收集列表时域状态在调用之间更改，则可能不会列出域或域可能多次出现。新服务器没有此问题。  </p>
<p>如果指定 <em>–managed-save</em>，则具有托管保存状态（仅在域处于关闭状态时可能，因此需要指定 <em>–inactive</em> 或 <em>–all</em> 才能实际列出它们）的域将在列表中显示为已保存。此标志仅可与默认 <em>–table</em> 输出一起使用。注意，此标志不会过滤域列表。  </p>
<p>如果指定 <em>–name</em>，则打印域名而不是表格格式，每行一个。如果指定 <em>–uuid</em>，则打印域的 UUID 而不是名称。如果指定 <em>–id</em>，则打印域的 ID 而不是名称。但是，可以组合 <em>–name</em>、*–uuid* 和 <em>–id</em> 以仅选择要打印的所需字段。标志 <em>–table</em> 指定应使用传统的表格格式输出，但它与 <em>–name</em> 和 <em>–id</em> 互斥。这是默认值，如果未指定 <em>–name</em>、*–uuid* 或 <em>–id</em>，则将使用它。如果未指定 <em>–name</em> 或 <em>–uuid</em>，但指定了 <em>–id</em>，则仅列出活动域，即使使用 <em>–all</em> 参数，否则输出将仅包含一堆仅包含 <em>-1</em> 的行。如果 <em>–table</em> 与 <em>–uuid</em> 组合，则域 UUID 将作为额外列打印。  </p>
<p>如果指定 <em>–title</em>，则会在额外列中打印域的简短描述（标题）。此标志仅可与默认 <em>–table</em> 输出一起使用。  </p>
<p><strong>示例 2：</strong></p>
<p>$ virsh list –title  </p>
<h2 id="Id-名称-状态-标题"><a href="#Id-名称-状态-标题" class="headerlink" title="Id   名称       状态    标题  "></a>Id   名称       状态    标题  </h2><p>0    Domain-0   running Mailserver 1<br>2    fedora     paused  </p>
<p><strong>freecell</strong></p>
<p><strong>语法：</strong></p>
<p>freecell [{ [–cellno] 单元号 | –all }]  </p>
<p>打印机器或 NUMA 单元中的可用内存量。freecell 命令可以根据指定的选项提供三种不同的机器可用内存显示之一。不带选项时，显示机器上的总空闲内存。使用 –all 选项时，显示每个单元的空闲内存和机器上的总空闲内存。最后，使用数字参数或 –cellno 加单元号时，将仅显示指定单元的空闲内存。  </p>
<p><strong>freepages</strong></p>
<p><strong>语法：</strong></p>
<p>freepages [{ [–cellno] 单元号 [–pagesize] 页大小 | –all }]  </p>
<p>打印 NUMA 单元中的可用页数。<em>单元号</em> 指您感兴趣的 NUMA 单元。<em>页大小</em> 是一个带单位的整数（参见上面的 NOTES）。或者，如果使用 <em>–all</em>，则打印每个可能的 NUMA 单元和页大小组合的信息。  </p>
<p><strong>allocpages</strong></p>
<p><strong>语法：</strong></p>
<p>allocpages [–pagesize] 页大小 [–pagecount] 页数 [[–cellno] 单元号] [–add] [–all]  </p>
<p>更改主机上 <em>页大小</em> 的页池大小。如果指定 <em>–add</em>，则将 <em>页数</em> 页添加到池中。但是，如果未指定 <em>–add</em>，则 <em>页数</em> 将作为池的新绝对大小（这可用于释放一些页并缩小池）。<em>单元号</em> 修饰符可用于将修改范围缩小到单个主机 NUMA 单元。在范围的另一端是 <em>–all</em>，它将在所有 NUMA 单元上执行修改。  </p>
<p><strong>cpu-baseline</strong></p>
<p><strong>语法：</strong></p>
<p>cpu-baseline 文件 [–features] [–migratable]  </p>
<p>计算基线 CPU，该 CPU 将由 &lt;文件&gt; 中给出的所有主机 CPU 支持。（参见 hypervisor-cpu-baseline 命令以获取可由特定虚拟机管理程序提供的 CPU。）主机 CPU 列表是通过从 &lt;文件&gt; 中提取所有 &lt;cpu&gt; 元素构建的。因此，&lt;文件&gt; 可以包含由换行符分隔的一组 &lt;cpu&gt; 元素，甚至可以包含 capabilities 命令打印的一组完整的 &lt;capabilities&gt; 元素。如果指定 <em>–features</em>，则生成的 XML 描述将显式包括构成 CPU 的所有功能，没有此选项时，属于 CPU 模型的功能将不会在 XML 描述中列出。如果指定 <em>–migratable</em>，则阻止迁移的功能将不会包含在生成的 CPU 中。  </p>
<p><strong>cpu-compare</strong></p>
<p><strong>语法：</strong></p>
<p>cpu-compare 文件 [–error] [–validate]  </p>
<p>将 XML &lt;文件&gt; 中的 CPU 定义与主机 CPU 进行比较。（参见 hypervisor-cpu-compare 命令以将 CPU 定义与特定虚拟机管理程序在主机上能够提供的 CPU 进行比较。）XML &lt;文件&gt; 可以包含主机或客户机 CPU 定义。主机 CPU 定义是 capabilities 命令打印的 &lt;cpu&gt; 元素及其内容。客户机 CPU 定义是域 XML 定义中的 &lt;cpu&gt; 元素及其内容，或从域功能 XML（由 domcapabilities 命令打印）中找到的主机 CPU 模型创建的 CPU 定义。除了 &lt;cpu&gt; 元素本身外，此命令还接受包含 CPU 定义的完整域 XML、capabilities XML 或域功能 XML。有关客户机 CPU 定义的更多信息，请参阅：<br><a target="_blank" rel="noopener" href="https://libvirt.org/formatdomain.html#elementsCPU">https://libvirt.org/formatdomain.html#elementsCPU</a>  </p>
<p>如果指定 <em>–error</em>，则当给定 CPU 与主机 CPU 不兼容时，命令将返回错误，并打印提供有关不兼容性更多详细信息的消息。如果指定 <em>–validate</em>，则根据内部 RNG 模式验证 XML 文档的格式。  </p>
<p><strong>cpu-models</strong></p>
<p><strong>语法：</strong></p>
<p>cpu-models 架构  </p>
<p>打印 libvirt 为指定架构已知的 CPU 模型列表。特定虚拟机管理程序是否能够创建使用任何打印的 CPU 模型的域是一个单独的问题，可以通过查看 domcapabilities 命令返回的域功能 XML 来回答。此外，对于某些架构，libvirt 不知道任何 CPU 模型，可用的 CPU 模型仅受虚拟机管理程序的限制。对于这些架构，此命令将打印所有 CPU 模型都被接受，实际支持的 CPU 模型列表可以在域功能 XML 中检查。  </p>
<p><strong>hypervisor-cpu-compare</strong></p>
<p><strong>语法：</strong></p>
<p>hypervisor-cpu-compare 文件 [virttype] [emulator] [arch] [machine] [–error] [–validate]  </p>
<p>将 XML &lt;文件&gt; 中的 CPU 定义与虚拟机管理程序在主机上能够提供的 CPU 进行比较。（这与 cpu-compare 不同，后者在不考虑任何特定虚拟机管理程序及其能力的情况下将 CPU 定义与主机 CPU 进行比较。）  </p>
<p>XML <em>文件</em> 应包含客户机 CPU 定义：域 XML 定义中的 &lt;cpu&gt; 元素及其内容，或从域功能 XML（由 domcapabilities 命令打印）中的 &lt;mode name&#x3D;”host-model”&gt; 元素创建的主机 CPU 模型创建的 CPU 定义。域功能 XML 中的 &lt;mode name&#x3D;”host-model”&gt; 元素本身或其 &lt;cpu&gt; 父元素不被接受。必须将元素转换为实际的 CPU 定义。有关客户机 CPU 定义的更多信息，请参阅：<br><a target="_blank" rel="noopener" href="https://libvirt.org/formatdomain.html#elementsCPU">https://libvirt.org/formatdomain.html#elementsCPU</a>  </p>
<p>或者，此命令在提供完整域或域功能 XML 时将自动提取 CPU 定义。  </p>
<p>出于历史原因，XML <em>文件</em> 也可以包含主机 CPU 定义，但强烈不建议这种用法，因为它很可能会提供不正确的结果。  </p>
<p><em>virttype</em> 选项指定虚拟化类型（可在域 XML 中 &lt;domain&gt; 顶级元素的 ‘type’ 属性中使用）。<em>emulator</em> 指定模拟器的路径，<em>arch</em> 指定 CPU 架构，<em>machine</em> 指定机器类型。如果指定 <em>–error</em>，则当给定 CPU 与主机 CPU 不兼容时，命令将返回错误，并打印提供有关不兼容性更多详细信息的消息。如果指定 <em>–validate</em>，则根据内部 RNG 模式验证 XML 文档的格式。  </p>
<p><strong>hypervisor-cpu-baseline</strong></p>
<p><strong>语法：</strong></p>
<p>hypervisor-cpu-baseline [文件] [virttype] [emulator] [arch] [machine]<br>[–features] [–migratable] [模型]  </p>
<p>计算基线 CPU，该 CPU 将与 XML <em>文件</em> 中定义的所有 CPU 以及虚拟机管理程序在主机上能够提供的 CPU 兼容。（这与 cpu-baseline 不同，后者在计算基线 CPU 时不考虑任何虚拟机管理程序的能力。）  </p>
<p>作为 <em>文件</em> 的替代方案，如果 XML 仅包含没有附加功能的 CPU 模型，则可以将 CPU 模型名称本身作为 <em>模型</em> 传递。必须使用 <em>文件</em> 和 <em>模型</em> 中的一个。  </p>
<p>XML <em>文件</em> 应包含从域功能 XML（在每个主机上由 domcapabilities 命令打印）中的 &lt;mode name&#x3D;”host-model”&gt; 元素创建的主机 CPU 模型创建的客户机 CPU 定义。域功能 XML 中的 &lt;mode name&#x3D;”host-model”&gt; 元素本身或其 &lt;cpu&gt; 父元素不被接受。必须将元素转换为实际的 CPU 定义。  </p>
<p>或者，此命令在提供域功能 XML 时将自动提取 CPU 定义。  </p>
<p>出于历史原因，XML <em>文件</em> 也可以包含主机 CPU 定义，但强烈不建议这种用法，因为它很可能会提供不正确的结果。  </p>
<p>当 <em>文件</em> 仅包含单个 CPU 定义时，命令将打印相同的 CPU，并附加虚拟机管理程序能力施加的限制。具体来说，在没有其他选项的情况下运行 virsh hypervisor-cpu-baseline 命令对 virsh domcapabilities 的结果进行操作，将域功能 XML 中的主机 CPU 模型转换为可直接在域 XML 中使用的形式。运行带有 <em>模型</em>（或仅包含模型且没有功能元素的单个 CPU 定义的 <em>文件</em>）的命令，该模型在 virsh domcapabilities 中被标记为不可用，将提供阻止此 CPU 模型可用的功能列表。  </p>
<p><em>virttype</em> 选项指定虚拟化类型（可在域 XML 中 &lt;domain&gt; 顶级元素的 ‘type’ 属性中使用）。<em>emulator</em> 指定模拟器的路径，<em>arch</em> 指定 CPU 架构，<em>machine</em> 指定机器类型。如果指定 <em>–features</em>，则生成的 XML 描述将显式包括构成 CPU 的所有功能，没有此选项时，属于 CPU 模型的功能将不会在 XML 描述中列出。如果指定 <em>–migratable</em>，则阻止迁移的功能将不会包含在生成的 CPU 中。  </p>
<p><strong>hypervisor-cpu-models</strong></p>
<p><strong>语法：</strong></p>
<p>hypervisor-cpu-models [–virttype virttype] [–emulator emulator]<br>[–arch arch] [–machine machine] [–all]  </p>
<p>打印虚拟机管理程序为指定架构已知的 CPU 模型列表。不能保证列出的 CPU 将在主机上运行。要确定 CPU 模型与主机的兼容性，请参阅 virsh hypervisor-cpu-baseline 和 virsh hypervisor-cpu-compare。  </p>
<p><em>virttype</em> 选项指定虚拟化类型（可在域 XML 中 &lt;domain&gt; 顶级元素的 ‘type’ 属性中使用）。<em>emulator</em> 指定模拟器的路径，<em>arch</em> 指定 CPU 架构，<em>machine</em> 指定机器类型。  </p>
<p>默认情况下，仅报告虚拟机管理程序在主机上声称“可用”的模型。选项 <em>–all</em> 将报告虚拟机管理程序已知的每个 CPU 模型，包括不受支持的模型（例如新一代模型）。</p>
<h1 id="5-域命令"><a href="#5-域命令" class="headerlink" title="5 域命令"></a>5 <strong>域命令</strong></h1><p>以下命令直接操作域，如前所述，大多数命令将域作为第一个参数。<em>域</em>可以指定为短整数、名称或完整的UUID。</p>
<p><strong>自动启动</strong></p>
<p><strong>语法：</strong></p>
<p>autostart [–disable] 域</p>
<p>配置域在启动时自动启动。</p>
<p>选项 <em>–disable</em> 禁用自动启动。</p>
<p><strong>块设备IO调优</strong></p>
<p><strong>语法：</strong></p>
<p>blkdeviotune 域 设备 [[–config] [–live] | [–current]]<br>[[total-bytes-sec] | [read-bytes-sec] [write-bytes-sec]]<br>[[total-iops-sec] | [read-iops-sec] [write-iops-sec]]<br>[[total-bytes-sec-max] | [read-bytes-sec-max] [write-bytes-sec-max]]<br>[[total-iops-sec-max] | [read-iops-sec-max] [write-iops-sec-max]]<br>[[total-bytes-sec-max-length] | [read-bytes-sec-max-length] [write-bytes-sec-max-length]]<br>[[total-iops-sec-max-length] | [read-iops-sec-max-length] [write-iops-sec-max-length]]<br>[size-iops-sec] [group-name]</p>
<p>设置或查询域块设备的IO参数。<em>设备</em>指定域中附加的磁盘设备的唯一目标名称（&lt;target dev&#x3D;’name’&#x2F;&gt;）或源文件（&lt;source file&#x3D;’name’&#x2F;&gt;）（参见domblklist列出这些名称）。</p>
<p>如果未指定限制，则查询当前IO限制设置。否则，使用以下标志更改限制：*–total-bytes-sec* 指定总吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–read-bytes-sec* 指定读取吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–write-bytes-sec* 指定写入吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–total-iops-sec* 指定每秒总IO操作限制。*–read-iops-sec* 指定每秒读取IO操作限制。*–write-iops-sec* 指定每秒写入IO操作限制。*–total-bytes-sec-max* 指定最大总吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–read-bytes-sec-max* 指定最大读取吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–write-bytes-sec-max* 指定最大写入吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–total-iops-sec-max* 指定每秒最大总IO操作限制。*–read-iops-sec-max* 指定每秒最大读取IO操作限制。*–write-iops-sec-max* 指定每秒最大写入IO操作限制。*–total-bytes-sec-max-length* 指定允许最大总吞吐量限制的持续时间（秒）。*–read-bytes-sec-max-length* 指定允许最大读取吞吐量限制的持续时间（秒）。*–write-bytes-sec-max-length* 指定允许最大写入吞吐量限制的持续时间（秒）。*–total-iops-sec-max-length* 指定允许最大总IO操作限制的持续时间（秒）。*–read-iops-sec-max-length* 指定允许最大读取IO操作限制的持续时间（秒）。*–write-iops-sec-max-length* 指定允许最大写入IO操作限制的持续时间（秒）。*–size-iops-sec* 指定每秒大小IO操作限制。*–group-name* 指定在多个驱动器之间共享IO配额的组名。对于QEMU域，如果未提供名称，则默认为每个<em>设备</em>有一个单独的组。</p>
<p>旧版本的virsh仅接受下划线而非连字符的选项，例如*–total_bytes_sec*。</p>
<p>字节和IOPS值是独立的，但仅设置一个值（例如–read-bytes-sec）会将该类别中的其他两个值重置为无限制。显式的0也会清除任何限制。对于给定的总值的非零值不能与读取或写入的非零值混合使用。</p>
<p>长度值的处理方式由管理程序决定。对于QEMU管理程序，如果设置了IO限制值或最大值，则默认显示1秒的值。提供0将值重置回默认值。</p>
<p>如果指定*–live<em>，则影响正在运行的客户机。如果指定</em>–config<em>，则影响持久客户机的下一次启动。如果指定</em>–current<em>，则根据客户机的当前状态等效于</em>–live<em>或</em>–config<em>。设置磁盘IO参数时，可以同时指定</em>–live<em>和</em>–config<em>标志，但</em>–current<em>是互斥的。查询时只能指定</em>–live<em>、</em>–config<em>或</em>–current*中的一个。如果未指定标志，行为因管理程序而异。</p>
<p><strong>域节流组设置</strong></p>
<p><strong>语法：</strong></p>
<p>domthrottlegroupset 域 组名 [[–config] [–live] | [–current]]<br>[[total-bytes-sec] | [read-bytes-sec] [write-bytes-sec]]<br>[[total-iops-sec] | [read-iops-sec] [write-iops-sec]]<br>[[total-bytes-sec-max] | [read-bytes-sec-max] [write-bytes-sec-max]]<br>[[total-iops-sec-max] | [read-iops-sec-max] [write-iops-sec-max]]<br>[[total-bytes-sec-max-length] | [read-bytes-sec-max-length] [write-bytes-sec-max-length]]<br>[[total-iops-sec-max-length] | [read-iops-sec-max-length] [write-iops-sec-max-length]]<br>[size-iops-sec]</p>
<p>添加或更新特定域的节流组。<em>组名</em>指定唯一的节流组名称，定义限制，并将被驱动器引用。</p>
<p>如果未指定限制，则默认为全零，这将失败。否则，使用以下标志设置限制：*–total-bytes-sec* 指定总吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–read-bytes-sec* 指定读取吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–write-bytes-sec* 指定写入吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–total-iops-sec* 指定每秒总IO操作限制。*–read-iops-sec* 指定每秒读取IO操作限制。*–write-iops-sec* 指定每秒写入IO操作限制。*–total-bytes-sec-max* 指定最大总吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–read-bytes-sec-max* 指定最大读取吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–write-bytes-sec-max* 指定最大写入吞吐量限制为缩放整数，默认单位为字节&#x2F;秒（如果未指定后缀）。*–total-iops-sec-max* 指定每秒最大总IO操作限制。*–read-iops-sec-max* 指定每秒最大读取IO操作限制。*–write-iops-sec-max* 指定每秒最大写入IO操作限制。*–total-bytes-sec-max-length* 指定允许最大总吞吐量限制的持续时间（秒）。*–read-bytes-sec-max-length* 指定允许最大读取吞吐量限制的持续时间（秒）。*–write-bytes-sec-max-length* 指定允许最大写入吞吐量限制的持续时间（秒）。*–total-iops-sec-max-length* 指定允许最大总IO操作限制的持续时间（秒）。*–read-iops-sec-max-length* 指定允许最大读取IO操作限制的持续时间（秒）。*–write-iops-sec-max-length* 指定允许最大写入IO操作限制的持续时间（秒）。*–size-iops-sec* 指定每秒大小IO操作限制。</p>
<p>字节和IOPS值是独立的，但仅设置一个值（例如–read-bytes-sec）会将该类别中的其他两个值重置为无限制。显式的0也会清除任何限制。对于给定的总值的非零值不能与读取或写入的非零值混合使用。</p>
<p>长度值的处理方式由管理程序决定。对于QEMU管理程序，如果设置了IO限制值或最大值，则默认显示1秒的值。提供0将值重置回默认值。</p>
<p>如果指定*–live<em>，则影响正在运行的客户机。如果指定</em>–config<em>，则影响持久客户机的下一次启动。如果指定</em>–current<em>，则根据客户机的当前状态等效于</em>–live<em>或</em>–config<em>。设置磁盘IO参数时，可以同时指定</em>–live<em>和</em>–config<em>标志，但</em>–current*是互斥的。如果未指定标志，行为因管理程序而异。</p>
<p><strong>域节流组删除</strong></p>
<p><strong>语法：</strong></p>
<p>domthrottlegroupdel 域 组名 [[–config] [–live] | [–current]]</p>
<p>使用指定的<em>组名</em>从域中删除节流组。如果节流组当前被磁盘资源引用，则尝试删除节流组将失败。如果<em>组名</em>不存在，将发生错误。</p>
<p>如果指定*–live<em>，则影响正在运行的客户机。如果客户机未运行，则返回错误。如果指定</em>–config<em>，则影响持久客户机的下一次启动。如果指定</em>–current<em>，则根据客户机的当前状态等效于</em>–live<em>或</em>–config*。</p>
<p><strong>域节流组信息</strong></p>
<p><strong>语法：</strong></p>
<p>domthrottlegroupinfo 域 组名 [[–config] [–live] | [–current]]</p>
<p>显示域节流组信息，包括IO限制设置。</p>
<p>如果指定*–live<em>，则从正在运行的客户机获取节流组数据。如果客户机未运行，则返回错误。如果指定</em>–config<em>，则从持久客户机的下一次启动获取节流组数据。如果指定</em>–current<em>或未指定</em>–live<em>和</em>–config<em>，则根据客户机的当前状态获取节流组数据，可以是活动或离线状态。如果同时指定</em>–live<em>和</em>–config<em>，则</em>–config*选项优先获取当前描述。</p>
<p><strong>域节流组列表</strong></p>
<p><strong>语法：</strong></p>
<p>domthrottlegrouplist 域 [–inactive]</p>
<p>打印显示与域关联的所有节流组名称的表格。如果指定*–inactive*，则查询将在下次启动时使用的节流组数据，而不是当前正在使用的域。</p>
<p><strong>块IO调优</strong></p>
<p><strong>语法：</strong></p>
<p>blkiotune 域 [–weight 权重] [–device-weights 设备权重]<br>[–device-read-iops-sec 设备读取IOPS]<br>[–device-write-iops-sec 设备写入IOPS]<br>[–device-read-bytes-sec 设备读取字节]<br>[–device-write-bytes-sec 设备写入字节]<br>[[–config] [–live] | [–current]]</p>
<p>显示或设置块IO参数。QEMU&#x2F;KVM支持*–weight<em>。</em>–weight*范围为[100, 1000]。在内核2.6.39之后，该值可以在[10, 1000]范围内。</p>
<p>设备权重是一个字符串，列出一个或多个设备&#x2F;权重对，格式为&#x2F;路径&#x2F;到&#x2F;设备,权重,&#x2F;路径&#x2F;到&#x2F;设备,权重。每个权重在[100, 1000]范围内，内核2.6.39之后为[10, 1000]，或值为0以从每设备列表中删除该设备。仅修改字符串中列出的设备；其他设备的现有每设备权重保持不变。</p>
<p>设备读取IOPS是一个字符串，列出一个或多个设备&#x2F;读取IOPS对，格式为&#x2F;路径&#x2F;到&#x2F;设备,读取IOPS,&#x2F;路径&#x2F;到&#x2F;设备,读取IOPS。每个读取IOPS是一个无符号整数，值为0以从每设备列表中删除该设备。仅修改字符串中列出的设备；其他设备的现有每设备读取IOPS保持不变。</p>
<p>设备写入IOPS是一个字符串，列出一个或多个设备&#x2F;写入IOPS对，格式为&#x2F;路径&#x2F;到&#x2F;设备,写入IOPS,&#x2F;路径&#x2F;到&#x2F;设备,写入IOPS。每个写入IOPS是一个无符号整数，值为0以从每设备列表中删除该设备。仅修改字符串中列出的设备；其他设备的现有每设备写入IOPS保持不变。</p>
<p>设备读取字节是一个字符串，列出一个或多个设备&#x2F;读取字节对，格式为&#x2F;路径&#x2F;到&#x2F;设备,读取字节,&#x2F;路径&#x2F;到&#x2F;设备,读取字节。每个读取字节是一个无符号长整型，值为0以从每设备列表中删除该设备。仅修改字符串中列出的设备；其他设备的现有每设备读取字节保持不变。</p>
<p>设备写入字节是一个字符串，列出一个或多个设备&#x2F;写入字节对，格式为&#x2F;路径&#x2F;到&#x2F;设备,写入字节,&#x2F;路径&#x2F;到&#x2F;设备,写入字节。每个写入字节是一个无符号长整型，值为0以从每设备列表中删除该设备。仅修改字符串中列出的设备；其他设备的现有每设备写入字节保持不变。</p>
<p>如果指定*–live<em>，则影响正在运行的客户机。如果指定</em>–config<em>，则影响持久客户机的下一次启动。如果指定</em>–current<em>，则根据客户机的当前状态等效于</em>–live<em>或</em>–config<em>。可以同时指定</em>–live<em>和</em>–config<em>标志，但</em>–current*是互斥的。如果未指定标志，行为因管理程序而异。</p>
<p><strong>块提交</strong></p>
<p><strong>语法：</strong></p>
<p>blockcommit 域 路径 [带宽] [–bytes] [基础]<br>[–shallow] [顶部] [–delete] [–keep-relative]<br>[–wait [–async] [–verbose]] [–timeout 秒]<br>[–active] [{–pivot | –keep-overlay}]</p>
<p>通过将链顶部的更改（快照或增量文件）提交到基础映像中，减少基础映像链的长度。默认情况下，此命令尝试展平整个链。如果<em>基础</em>和&#x2F;或<em>顶部</em>指定为链中的文件，则操作仅限于提交该部分链；*–shallow<em>可以代替</em>基础<em>指定要提交的顶部映像的直接基础文件。正在提交的文件将变为无效，可能在操作开始时即如此；使用</em>–delete<em>标志将在成功完成提交操作后尝试删除这些无效文件。使用</em>–keep-relative*标志时，基础文件路径将保持相对路径。</p>
<p>当省略<em>顶部</em>或将其指定为活动映像时，还可以指定*–active<em>以触发两阶段活动提交。在第一阶段，</em>顶部<em>被复制到</em>基础<em>中，作业只能取消，顶部仍包含尚未在基础中的数据。在第二阶段，</em>顶部<em>和</em>基础<em>保持相同，直到调用带有</em>–abort<em>标志的blockjob（保持顶部作为跟踪从该时间点更改的活动映像）或</em>–pivot*标志（使基础成为新的活动映像并使顶部无效）。</p>
<p>默认情况下，此命令尽快返回，整个磁盘的数据在后台提交；可以使用blockjob检查操作进度。但是，如果指定*–wait<em>，则此命令将阻塞，直到操作完成（或对于</em>–active<em>，进入第二阶段），或由于可选的</em>timeout<em>秒超时或发送SIGINT（通常使用Ctrl-C）而取消操作。使用</em>–verbose<em>与</em>–wait<em>将产生定期状态更新。如果触发作业取消，</em>–async<em>将尽快将控制权返回给用户，否则命令可能会继续阻塞一段时间，直到作业完成清理。使用</em>–pivot<em>是结合</em>–active* <em>–wait</em>与自动blockjob <em>–pivot</em>的简写；使用*–keep-overlay<em>是结合</em>–active* <em>–wait</em>与自动blockjob <em>–abort</em>的简写。</p>
<p><em>路径</em>指定磁盘的完全限定路径；它对应于域中附加的磁盘设备的唯一目标名称（&lt;target dev&#x3D;’name’&#x2F;&gt;）或源文件（&lt;source file&#x3D;’name’&#x2F;&gt;）（参见domblklist列出这些名称）。<em>带宽</em>指定复制带宽限制（MiB&#x2F;s），但对于QEMU，仅在线域可能为非零值。有关<em>带宽</em>参数的更多信息，请参见blockjob命令的相应部分。</p>
<p><strong>块复制</strong></p>
<p><strong>语法：</strong></p>
<p>blockcopy 域 路径 { 目标 [格式] [–blockdev] | –xml 文件 }<br>[–shallow] [–reuse-external] [带宽]<br>[–wait [–async] [–verbose]] [{–pivot | –finish}]<br>[–timeout 秒] [粒度] [缓冲区大小] [–bytes]<br>[–transient-job] [–synchronous-writes] [–print-xml]</p>
<p>将磁盘基础映像链复制到目标。必须存在<em>目标</em>作为目标文件名，或*–xml<em>包含描述目标的顶级&lt;disk&gt;元素的XML文件名。此外，如果给出</em>目标<em>，则应指定</em>格式<em>以声明目标的格式（如果省略</em>格式<em>，则libvirt将重用源的格式，或使用</em>–reuse-external<em>强制探测目标格式，这可能是潜在的安全漏洞）。该命令支持</em>–raw<em>作为</em>–format&#x3D;raw<em>的布尔标志同义词。使用</em>目标<em>时，目标被视为常规文件，除非使用</em>–blockdev<em>表示它是块设备。默认情况下，此命令展平整个链；但如果指定</em>–shallow*，则副本共享基础链。</p>
<p>如果指定*–reuse-external<em>，则目标必须存在并具有足够的空间来保存副本。如果</em>–shallow<em>与</em>–reuse-external*一起使用，则预创建的映像必须具有与原始映像的基础文件相同的客户可见内容。这可以用于修改目标上的基础文件名。</p>
<p>默认情况下，复制作业在后台运行，并分为两个阶段。最初，作业必须从源复制所有数据，在此阶段，作业只能取消以恢复到源磁盘，不保证目标的状态。在此阶段完成后，源和目标保持镜像，直到调用带有*–abort<em>和</em>–pivot<em>标志的blockjob切换到副本，或不带</em>–pivot<em>的调用将目标保留为该时间点的忠实副本。但是，如果指定</em>–wait<em>，则此命令将阻塞，直到镜像阶段开始，或如果可选的</em>timeout<em>秒超时或发送SIGINT（通常使用Ctrl-C）则取消操作。使用</em>–verbose<em>与</em>–wait<em>将产生定期状态更新。使用</em>–pivot<em>（类似于blockjob <em>–pivot</em>）或</em>–finish<em>（类似于blockjob <em>–abort</em>）隐含</em>–wait<em>，并将干净地结束作业，而不是保持在镜像阶段。如果超时或</em>–finish<em>触发作业取消，</em>–async*将尽快将控制权返回给用户，否则命令可能会继续阻塞一段时间，直到作业实际取消。</p>
<p><em>路径</em>指定磁盘的完全限定路径。<em>带宽</em>指定复制带宽限制（MiB&#x2F;s）。指定负值被视为无符号长整型值，可能基本上无限制，但更可能溢出；使用0更安全。有关<em>带宽</em>参数的更多信息，请参见blockjob命令的相应部分。指定<em>粒度</em>允许微调检测到脏区域时要复制的粒度；较大的值触发较少的IO开销，但总体上可能复制更多的数据（默认值通常正确）；管理程序可能限制为2的幂或落在特定范围内。指定<em>缓冲区大小</em>将控制在复制期间可以同时传输的数据量；较大的值使用更多内存，但可能允许更快完成（默认值通常正确）。</p>
<p><em>–transient-job</em>允许指定如果VM在作业完成前崩溃或关闭，用户不需要恢复作业。如果管理程序应用了复制作业对临时域的限制，此标志将删除该限制。</p>
<p>如果指定*–synchronous-writes*，则块作业将等待客户写入传播到原始映像和复制目标，以确保如果目标存储较慢，作业会收敛。这可能会影响块作业运行时的写入性能。</p>
<p>如果指定*–print-xml*，则打印用于启动块复制作业的XML，而不是启动作业。</p>
<p><strong>块作业</strong></p>
<p><strong>语法：</strong></p>
<p>blockjob 域 路径 { [–abort] [–async] [–pivot] |<br>[–info] [–raw] [–bytes] | [带宽] }</p>
<p>管理活动块操作。有三种互斥模式：*–info<em>、</em>带宽<em>和</em>–abort<em>。</em>–async<em>和</em>–pivot<em>隐含中止模式；</em>–raw<em>隐含信息模式；如果未给出模式，则假定为</em>–info*模式。</p>
<p><em>路径</em>指定磁盘的完全限定路径；它对应于域中附加的磁盘设备的唯一目标名称（&lt;target dev&#x3D;’name’&#x2F;&gt;）或源文件（&lt;source file&#x3D;’name’&#x2F;&gt;）（参见domblklist列出这些名称）。</p>
<p>在*–abort<em>模式下，将中止指定磁盘上的活动作业。如果还指定</em>–async<em>，则此命令将立即返回，而不是等待取消完成。如果指定</em>–pivot*，则请求将活动复制或活动提交作业切换到新映像。</p>
<p>在*–info<em>模式下，将打印指定磁盘上的活动作业信息。默认情况下，输出为单个人类可读的摘要行；此格式可能在将来的版本中更改。添加</em>–raw<em>以稳定格式列出结构的每个字段。如果设置</em>–bytes*标志，则如果服务器无法提供字节&#x2F;秒分辨率，则命令将出错；省略标志时，原始输出以MiB&#x2F;s列出，人类可读输出自动选择服务器支持的最佳分辨率。</p>
<p><em>带宽</em>可用于设置活动作业的带宽限制（MiB&#x2F;s）。如果指定*–bytes<em>，则带宽值解释为字节&#x2F;秒。指定负值被视为无符号长整型值或基本上无限制。管理程序可以选择是否拒绝该值或将其转换为允许的最大值。可选地，可以使用缩放正数作为带宽（参见上面的NOTES）。使用</em>–bytes<em>与缩放值允许选择更细的粒度。不带</em>–bytes<em>的缩放值将向下舍入到MiB&#x2F;s。请注意，</em>–bytes*可能不受管理程序支持。</p>
<p>请注意，对应于拉模式备份的块作业报告的进度不是备份的进度，而是备份所需的临时空间的使用情况。</p>
<p><strong>块拉取</strong></p>
<p><strong>语法：</strong></p>
<p>blockpull 域 路径 [带宽] [–bytes] [基础]<br>[–wait [–verbose] [–timeout 秒] [–async]]<br>[–keep-relative]</p>
<p>从基础映像链中填充磁盘。默认情况下，此命令展平整个链；但如果指定<em>基础</em>，包含链中基础文件之一的名称，则该文件成为新的基础文件，仅拉取链的中间部分。一旦从基础映像链中拉取了所有请求的数据，磁盘就不再依赖于该部分基础链。</p>
<p>默认情况下，此命令尽快返回，整个磁盘的数据在后台拉取；可以使用blockjob检查操作进度。但是，如果指定*–wait<em>，则此命令将阻塞，直到操作完成，或如果可选的</em>timeout<em>秒超时或发送SIGINT（通常使用Ctrl-C）则取消操作。使用</em>–verbose<em>与</em>–wait<em>将产生定期状态更新。如果触发作业取消，</em>–async*将尽快将控制权返回给用户，否则命令可能会继续阻塞一段时间，直到作业完成清理。</p>
<p>使用*–keep-relative*标志将保持基础链名称的相对性。</p>
<p><em>路径</em>指定磁盘的完全限定路径；它对应于域中附加的磁盘设备的唯一目标名称（&lt;target dev&#x3D;’name’&#x2F;&gt;）或源文件（&lt;source file&#x3D;’name’&#x2F;&gt;）（参见domblklist列出这些名称）。<em>带宽</em>指定复制带宽限制（MiB&#x2F;s）。有关<em>带宽</em>参数的更多信息，请参见blockjob命令的相应部分。</p>
<p><strong>块调整大小</strong></p>
<p><strong>语法：</strong></p>
<p>blockresize 域 路径 ([大小] | [–capacity])</p>
<p>在域运行时调整块设备的大小。<em>路径</em>指定块设备的绝对路径；它对应于域中附加的磁盘设备的唯一目标名称（&lt;target dev&#x3D;’name’&#x2F;&gt;）或源文件（&lt;source file&#x3D;’name’&#x2F;&gt;）（参见domblklist列出这些名称）。</p>
<p>对于没有元数据的映像格式（原始格式）存储在固定大小的存储（例如块设备）中，可以使用*–capacity*标志将设备调整为基础设备的完整大小。</p>
<p><em>大小</em>是一个缩放整数（参见上面的NOTES），如果没有后缀，则默认为KiB（1024字节的块）。必须使用“B”后缀以获取字节（请注意，由于历史原因，这与vol-resize不同，后者默认不带后缀的字节）。</p>
<p><strong>控制台</strong></p>
<p><strong>语法：</strong></p>
<p>console 域 [设备名] [–safe] [–force] [–resume]</p>
<p>连接到客户机的虚拟串行控制台。可选的<em>设备名</em>参数引用为客户机配置的备用控制台、串行或并行设备的设备别名。如果省略，将打开主控制台。</p>
<p>如果指定*–safe<em>标志，则仅在驱动程序支持安全控制台处理时尝试连接。此标志指定服务器必须确保对控制台设备的独占访问。可选地，可以指定</em>–force*标志，请求断开任何现有会话，例如在连接断开的情况下。</p>
<p>如果指定*–resume*标志，则在连接到控制台后恢复客户机。</p>
<p><strong>CPU统计</strong></p>
<p><strong>语法：</strong></p>
<p>cpu-stats 域 [–total] [起始] [数量]</p>
<p>提供域的CPU统计信息。域应正在运行。默认显示所有CPU的统计信息和总计。使用*–total<em>仅显示总计统计信息，</em>起始<em>仅显示从</em>起始<em>开始的CPU的统计信息，</em>数量<em>仅显示</em>数量*个CPU的统计信息。</p>
<p><strong>创建</strong></p>
<p><strong>语法：</strong></p>
<p>create 文件 [–console] [–paused] [–autodestroy]<br>[–pass-fds N,M,…] [–validate] [–reset-nvram]</p>
<p>从XML &lt;文件&gt;创建域。可选地，可以传递*–validate*选项以根据内部RNG模式验证输入XML文件的格式（与使用virt-xml-validate(1)工具相同）。使用此命令创建的域将是临时的（一旦销毁即消失）或现有的持久客户机，将运行一次性使用的配置，保持持久XML不变（这在基于原始XML的各种配置的自动化测试中可能很方便）。请参见下面的示例以了解用法演示。</p>
<p>如果使用*–paused<em>选项且驱动程序支持，则域将被暂停；否则将运行。如果请求</em>–console<em>，则在创建后附加到控制台。如果请求</em>–autodestroy*，则当virsh关闭其与libvirt的连接或以其他方式退出时，客户机将自动销毁。</p>
<p>如果指定*–pass-fds*，则参数是逗号分隔的打开文件描述符列表，这些文件描述符应传递到客户机中。文件描述符将在客户机中重新编号，从3开始。这仅支持基于容器的虚拟化。</p>
<p>如果指定*–reset-nvram*，则任何现有的NVRAM文件将被删除并从其原始模板重新初始化。</p>
<p><strong>示例：</strong></p>
<ol>
<li>从现有域准备模板（如果从头开始编写，则直接跳到3a）</li>
</ol>
<p># virsh dumpxml &lt;域&gt; &gt; 域.xml</p>
<ol start="2">
<li><p>使用您选择的编辑器编辑模板：</p>
<p> a. 必须更改！&lt;name&gt;和&lt;uuid&gt;（&lt;uuid&gt;也可以删除），或</p>
<p> b. 不要更改！&lt;name&gt;或&lt;uuid&gt;</p>
</li>
</ol>
<p># $EDITOR 域.xml</p>
<ol start="3">
<li><p>从domain.xml创建域，取决于是否遵循2a或2b：</p>
<p> a. 域将是临时的</p>
<p> b. 现有的持久客户机将使用修改后的一次性配置运行</p>
</li>
</ol>
<p># virsh create domain.xml</p>
<p><strong>定义</strong></p>
<p><strong>语法：</strong></p>
<p>define 文件 [–validate]</p>
<p>从XML &lt;文件&gt;定义域。可选地，可以使用*–validate*（与使用virt-xml-validate(1)工具相同）根据内部RNG模式验证输入XML文件的格式。域定义已注册但未启动。如果域已在运行，则更改将在下次启动时生效。</p>
<p><strong>描述</strong></p>
<p><strong>语法：</strong></p>
<p>desc 域 [[–live] [–config] | [–current]] [–title] [–edit] [–new-desc 新描述或标题消息]</p>
<p>显示或修改域的描述和标题。这些值是允许存储任意文本数据的用户字段，以便轻松识别域。标题应简短，尽管未强制执行。（另请参见适用于基于XML的域元数据的元数据。）</p>
<p>标志*–live<em>或</em>–config<em>选择此命令是作用于域的实时定义还是持久定义。如果同时指定</em>–live<em>和</em>–config<em>，则</em>–config<em>选项优先获取当前描述，并在设置描述时同时更新实时配置和配置。</em>–current*是互斥的，如果未指定这些标志，则隐含。</p>
<p>标志*–edit*指定应打开包含当前描述或标题内容的编辑器，并在之后保存内容。</p>
<p>标志*–title*选择操作标题字段而不是描述。</p>
<p>如果既不指定*–edit<em>也不指定</em>–new-desc*，则显示注释或描述而不是修改。</p>
<p><strong>销毁</strong></p>
<p><strong>语法：</strong></p>
<p>destroy 域 [–graceful] [–remove-logs]</p>
<p>立即终止域<em>域</em>。这不会给域操作系统任何反应的机会，相当于物理机器上拔掉电源线。在大多数情况下，您会希望改用shutdown命令。但是，这不会删除客户机使用的任何存储卷，如果域是持久的，则可以稍后重新启动。</p>
<p>如果<em>域</em>是临时的，则一旦客户机停止运行，任何快照的元数据将丢失，但快照内容仍然存在，具有相同名称和UUID的新域可以使用snapshot-create恢复快照元数据。类似地，任何检查点的元数据将丢失，但可以使用checkpoint-create恢复。</p>
<p>如果指定*–graceful*，则在客户机在合理超时后未停止时，不采取极端措施（例如SIGKILL）；而是返回错误。</p>
<p>如果指定*–remove-logs<em>，则删除每个</em>域*的日志文件。并非所有部署配置都受支持。</p>
<p>对于QEMU，仅当使用virlogd处理QEMU进程输出时才支持该标志。否则忽略该标志。</p>
<p><strong>块错误</strong></p>
<p><strong>语法：</strong></p>
<p>domblkerror 域</p>
<p>显示块设备上的错误。当domstate命令说域由于I&#x2F;O错误而暂停时，此命令通常很有用。domblkerror命令列出所有处于错误状态的块设备以及每个设备上看到的错误。</p>
<p><strong>块信息</strong></p>
<p><strong>语法：</strong></p>
<p>domblkinfo 域 [块设备 –all] [–human]</p>
<p>获取域的块设备大小信息。<em>块设备</em>对应于域中附加的磁盘设备的唯一目标名称（&lt;target dev&#x3D;’name’&#x2F;&gt;）或源文件（&lt;source file&#x3D;’name’&#x2F;&gt;）（参见domblklist列出这些名称）。如果指定*–human<em>，则输出将具有人类可读的输出。如果指定</em>–all<em>，则输出将是一个表格，显示与</em>域<em>关联的所有块设备大小信息。</em>–all*选项优先于其他选项。</p>
<p><strong>块列表</strong></p>
<p><strong>语法：</strong></p>
<p>domblklist 域 [–inactive] [–details]</p>
<p>打印一个表格，显示与<em>域</em>关联的所有块设备的简要信息。如果指定*–inactive<em>，则查询将在下次启动时使用的块设备，而不是当前正在使用的域。如果指定</em>–details<em>，还将打印磁盘类型和设备值。其他需要块设备名称的上下文（例如</em>domblkinfo<em>或用于磁盘快照的</em>snapshot-create*）将接受此命令打印的目标或唯一源名称。</p>
<p><strong>块统计</strong></p>
<p><strong>语法：</strong></p>
<p>domblkstat 域 [块设备] [–human]</p>
<p>获取正在运行的域的块设备统计信息。<em>块设备</em>对应于域中附加的磁盘设备的唯一目标名称（&lt;target dev&#x3D;’name’&#x2F;&gt;）或源文件（&lt;source file&#x3D;’name’&#x2F;&gt;）（参见domblklist列出这些名称）。在LXC或QEMU域上，省略<em>块设备</em>将汇总整个域的块设备统计信息。</p>
<p>使用*–human*以获得更人类可读的输出。</p>
<p>这些字段的可用性取决于管理程序。不支持的字段将从输出中缺失。如果与较新版本的libvirtd通信，可能会出现其他字段。</p>
<p>字段说明（字段按以下顺序出现）：</p>
<ul>
<li><p>rd_req - 读取操作计数</p>
</li>
<li><p>rd_bytes - 读取字节计数</p>
</li>
<li><p>wr_req - 写入操作计数</p>
</li>
<li><p>wr_bytes - 写入字节计数</p>
</li>
<li><p>errs - 错误计数</p>
</li>
<li><p>flush_operations - 刷新操作计数</p>
</li>
<li><p>rd_total_times - 读取操作花费的总时间（纳秒）</p>
</li>
<li><p>wr_total_times - 写入操作花费的总时间（纳秒）</p>
</li>
<li><p>flush_total_times - 刷新操作花费的总时间（纳秒）</p>
</li>
<li><p>&lt;– 管理程序提供的其他字段 –&gt;</p>
</li>
</ul>
<p><strong>块阈值</strong></p>
<p><strong>语法：</strong></p>
<p>domblkthreshold 域 设备 阈值</p>
<p>设置传递块阈值事件的阈值值。<em>设备</em>指定磁盘设备目标或使用’target[1]’语法给定设备的支持链元素。<em>阈值</em>是偏移的缩放值。如果块设备应写入超过该偏移，则将传递事件。</p>
<p><strong>域控制</strong></p>
<p><strong>语法：</strong></p>
<p>domcontrol 域</p>
<p>返回用于控制域的VMM接口状态。对于除“ok”或“error”之外的状态，该命令还打印自控制接口进入其当前状态以来经过的秒数。</p>
<p><strong>脏页率计算</strong></p>
<p><strong>语法：</strong></p>
<p>domdirtyrate-calc &lt;域&gt; [–seconds &lt;秒&gt;]<br>–mode&#x3D;[page-sampling | dirty-bitmap | dirty-ring]</p>
<p>计算活动域的内存脏页率，用户可能期望以此决定是否适合迁移出去。seconds参数可用于在特定时间计算脏页率，现在最多允许60s，如果缺失则默认为1s。这三种<em>page-sampling、dirty-bitmap、dirty-ring</em>模式在指定计算模式时是互斥且可选的，如果缺失则<em>page-sampling</em>是默认模式。通过调用’domstats –dirtyrate’可以获取计算的脏页率信息。</p>
<p><strong>域显示</strong></p>
<p><strong>语法：</strong></p>
<p>domdisplay 域 [–include-password] [[–type] 类型] [–all]</p>
<p>输出可用于通过VNC、SPICE或RDP连接到域的图形显示的URI。可以使用type参数选择特定的图形显示类型（例如“vnc”、“spice”、“rdp”）。如果指定*–include-password<em>，则SPICE通道密码将包含在URI中。如果指定</em>–all*，则显示所有可能的图形显示，因为VM可能有多个图形显示。</p>
<p><strong>域显示重新加载</strong></p>
<p><strong>语法：</strong></p>
<p>domdisplay-reload &lt;域&gt; [–type &lt;类型&gt;]</p>
<p>重新加载域的图形显示。这会重新加载其TLS证书而不重新启动域。type可以是<em>virDomainGraphicsReloadType</em>枚举中的任何常量。默认情况下，重新加载任何支持的类型（目前仅VNC）。</p>
<p><strong>域文件系统冻结</strong></p>
<p><strong>语法：</strong></p>
<p>domfsfreeze 域 [[–mountpoint] 挂载点…]</p>
<p>冻结正在运行的域中的已挂载文件系统，以准备一致的快照。</p>
<p><em>–mountpoint</em>选项接受参数挂载点，这是要冻结的文件系统的挂载点路径。此选项可以多次出现。如果未指定此选项，则冻结每个已挂载的文件系统。</p>
<p>注意：snapshot-create命令具有*–quiesce*选项，可以自动冻结和解冻文件系统以保持快照一致。domfsfreeze命令仅在用户希望利用libvirt不支持的存储设备的本地快照功能时才需要。</p>
<p><strong>域文件系统信息</strong></p>
<p><strong>语法：</strong></p>
<p>domfsinfo 域</p>
<p>显示正在运行的域中已挂载文件系统的列表。该列表包含挂载点、客户机中已挂载设备的名称、文件系统类型和域XML中使用的唯一目标名称（&lt;target dev&#x3D;’name’&#x2F;&gt;）。</p>
<p>注意：此命令需要在域的客户机操作系统中配置并运行客户机代理。</p>
<p><strong>域文件系统解冻</strong></p>
<p><strong>语法：</strong></p>
<p>domfsthaw 域 [[–mountpoint] 挂载点…]</p>
<p>解冻由domfsfreeze命令冻结的正在运行的域中的已挂载文件系统。</p>
<p><em>–mountpoint</em>选项接受参数挂载点，这是要解冻的文件系统的挂载点路径。此选项可以多次出现。如果未指定此选项，则解冻每个已挂载的文件系统。</p>
<p><strong>域文件系统修剪</strong></p>
<p><strong>语法：</strong></p>
<p>domfstrim 域 [–minimum 字节] [–mountpoint 挂载点]</p>
<p>在正在运行的域中的所有已挂载文件系统上发出fstrim命令。它丢弃文件系统未使用的块。如果指定*–minimum<em>字节，则告诉客户内核连续空闲范围的长度。小于此值的可能会被忽略（这是一个提示，客户可能不会遵守）。通过增加此值，fstrim操作将更快完成，对于具有严重碎片化空闲空间的文件系统，尽管并非所有块都会被丢弃。默认值为零，表示“丢弃每个空闲块”。此外，如果用户只想修剪一个挂载点，可以通过可选的</em>–mountpoint*参数指定。</p>
<p><strong>域主机名</strong></p>
<p><strong>语法：</strong></p>
<p>domhostname 域 [–source lease|agent]</p>
<p>如果管理程序可用，则返回域的主机名。</p>
<p><em>–source</em>参数指定用于主机名的数据源，当前为“lease”读取DHCP租约或“agent”通过代理查询客户操作系统。如果未指定，驱动程序返回可用的默认方法（某些驱动程序仅支持一种类型的源）。</p>
<p><strong>域ID</strong></p>
<p><strong>语法：</strong></p>
<p>domid 域名或UUID</p>
<p>将域名（或UUID）转换为域ID</p>
<p><strong>域接口获取链接</strong></p>
<p><strong>语法：</strong></p>
<p>domif-getlink 域 接口设备 [–config]</p>
<p>查询域虚拟接口的链接状态。如果指定*–config<em>，则查询持久配置，为了兼容性，</em>–persistent<em>是</em>–config*的别名。</p>
<p><em>接口设备</em>可以是接口的目标名称或MAC地址。</p>
<p><strong>域接口设置链接</strong></p>
<p><strong>语法：</strong></p>
<p>domif-setlink 域 接口设备 状态 [–config] [–print-xml]</p>
<p>修改域虚拟接口的链接状态。状态的可能值为“up”和“down”。如果指定*–config<em>，则仅修改域的持久配置，为了兼容性，</em>–persistent<em>是</em>–config<em>的别名。</em>接口设备*可以是接口的目标名称或MAC地址。</p>
<p>如果指定*–print-xml*，则打印用于更新接口的XML。</p>
<p><strong>域接口地址</strong></p>
<p><strong>语法：</strong></p>
<p>domifaddr 域 [接口] [–full]<br>[–source lease|agent|arp]</p>
<p>获取正在运行的域的接口列表及其IP和MAC地址，或如果指定<em>接口</em>，则仅显示一个接口的有限输出。请注意，<em>接口</em>可能依赖于驱动程序，可以是客户操作系统中的名称或域XML中看到的名称。此外，在某些管理程序（特别是QEMU）下，整个命令可能要求为查询的域配置客户代理。</p>
<p>如果指定*–full*，则当接口有多个IP地址或别名时，始终显示接口名称和MAC地址；否则，仅对第一个名称和MAC地址显示接口名称和MAC地址，其他使用相同名称和MAC地址的显示为“-”。</p>
<p><em>–source</em>参数指定用于地址的数据源，当前为“lease”读取DHCP租约，“agent”通过代理查询客户操作系统，或“arp”从主机的arp表中获取IP。如果未指定，“lease”是默认值。</p>
<p><strong>备份开始</strong></p>
<p><strong>语法：</strong></p>
<p>backup-begin 域 [backupxml] [checkpointxml] [–reuse-external]</p>
<p>开始新的备份作业。如果省略<em>backupxml</em>，则默认为使用libvirt生成的文件名的完整备份；提供XML允许微调，例如请求相对于早期检查点的增量备份，控制哪些磁盘参与或涉及哪些文件名，或请求使用拉模型备份。<em>backup-dumpxml</em>命令显示libvirt分配的任何结果值。有关备份XML的更多信息，请参见：<a target="_blank" rel="noopener" href="https://libvirt.org/formatbackup.html">https://libvirt.org/formatbackup.html</a></p>
<p>如果使用*–reuse-external<em>，则指示libvirt重用用户在</em>backupxml*中提供的临时和输出文件。</p>
<p>如果指定<em>checkpointxml</em>，则使用包含<em>domaincheckpoint</em>顶级元素的第二个文件创建同时检查点，以便在创建备份时进行稍后的增量备份。有关检查点的更多详细信息，请参见<em>checkpoint-create</em>。</p>
<p>此命令尽快返回，备份作业在后台运行；可以使用<em>domjobinfo</em>检查推送模型备份的进度，或使用<em>event</em>等待事件（拉模型备份的进度由连接到NBD导出的任何第三方控制）。使用<em>domjobabort</em>结束作业。</p>
<p><strong>备份转储XML</strong></p>
<p><strong>语法：</strong></p>
<p>backup-dumpxml [–xpath 表达式] [–wrap] 域</p>
<p>输出描述当前备份作业的XML。</p>
<p>如果**–xpath<strong>参数提供XPath表达式，则将对输出XML求值，并仅打印匹配的节点。默认行为是将每个匹配节点打印为独立文档，但是为了便于进一步处理，</strong>–wrap**参数将使匹配节点包装在公共根节点中。</p>
<p><strong>域接口列表</strong></p>
<p><strong>语法：</strong></p>
<p>domiflist 域 [–inactive]</p>
<p>打印显示与域关联的所有虚拟接口的简要信息的表格。如果指定*–inactive<em>，则查询将在下次启动时使用的虚拟接口，而不是当前正在使用的域。其他需要虚拟接口MAC地址的上下文（例如</em>detach-interface<em>或</em>domif-setlink*）将接受此命令打印的MAC地址。</p>
<p><strong>域接口统计</strong></p>
<p><strong>语法：</strong></p>
<p>domifstat 域 接口设备</p>
<p>获取正在运行的域的网络接口统计信息。网络接口统计信息仅适用于具有物理源接口的接口。这不包括例如“user”接口类型，因为它是具有NAT到外部世界的虚拟LAN。<em>接口设备</em>可以是接口的目标名称或MAC地址。请注意，对于非托管<em>ethernet</em>类型，返回的统计信息可能交换了RX&#x2F;TX。</p>
<p><strong>域接口调优</strong></p>
<p><strong>语法：</strong></p>
<p>domiftune 域 接口设备 [[–config] [–live] | [–current]]<br>[–inbound 平均,峰值,突发,下限]<br>[–outbound 平均,峰值,突发]</p>
<p>设置或查询域的网络接口的带宽参数。<em>接口设备</em>可以是接口的目标名称（&lt;target dev&#x3D;’name’&#x2F;&gt;）或MAC地址。</p>
<p>如果未指定*–inbound<em>或</em>–outbound<em>，则此命令将查询并显示带宽设置。否则，它将设置入站或出站带宽。</em>平均,峰值,突发,下限<em>与命令</em>attach-interface<em>中的相同。</em>平均<em>、</em>峰值<em>和</em>下限<em>的值以千字节&#x2F;秒表示，而</em>突发<em>以</em>峰值*速度的单次突发中的千字节表示，如网络XML文档中所述：<a target="_blank" rel="noopener" href="https://libvirt.org/formatnetwork.html#quality-of-service%E3%80%82">https://libvirt.org/formatnetwork.html#quality-of-service。</a></p>
<p>要清除入站或出站设置，分别使用*–inbound<em>或</em>–outbound*，平均值为零。</p>
<p>如果指定*–live<em>，则影响正在运行的客户机。如果指定</em>–config<em>，则影响持久客户机的下一次启动。如果指定</em>–current<em>，则根据客户机的当前状态等效于</em>–live<em>或</em>–config<em>。可以同时指定</em>–live<em>和</em>–config<em>标志，但</em>–current*是互斥的。如果未指定标志，行为因管理程序而异。</p>
<p><strong>域信息</strong></p>
<p><strong>语法：</strong></p>
<p>dominfo 域</p>
<p>返回有关域的基本信息。</p>
<p><strong>域作业中止</strong></p>
<p><strong>语法：</strong></p>
<p>domjobabort 域 [–postcopy]</p>
<p>中止当前正在运行的域作业。</p>
<p>当中止的作业是进入后复制模式的迁移时，由于迁移中涉及的没有一个主机具有域的完整状态，因此无法中止。可选的*–postcopy<em>可用于中断此类迁移，尽管这样做可能会有效地暂停域，直到迁移恢复（另请参见迁移的</em>–postcopy-resume*选项）。</p>
<p><strong>域作业信息</strong></p>
<p><strong>语法：</strong></p>
<p>domjobinfo 域 [–completed [–keep-completed]] [–anystats] [–rawstats]</p>
<p>返回在域上运行的作业的信息。*–completed<em>告诉virsh返回最近完成的作业的信息。完成的作业的统计信息在读取后自动销毁（除非使用</em>–keep-completed*）或重新启动libvirtd时。</p>
<p>通常仅打印正在运行和成功完成的作业的统计信息。*–anystats*也可用于显示失败作业的统计信息。</p>
<p>如果使用*–rawstats*，则所有字段按从服务器接收的方式打印，不尝试解释数据。“Job type:”字段是特殊的，因为它是通过API报告的，不是统计信息的一部分。</p>
<p>请注意，对于已完成的迁移返回的时间信息可能完全不相关，除非源主机和目标主机具有同步时间（即，两者都运行NTP守护程序）。</p>
<p><strong>域启动安全信息</strong></p>
<p><strong>语法：</strong></p>
<p>domlaunchsecinfo 域</p>
<p>返回与正在运行的域关联的启动安全参数的信息。</p>
<p>报告的参数集将根据活动的启动安全保护类型而变化。如果没有活动，则不报告任何参数。</p>
<p><strong>域设置启动安全状态</strong></p>
<p><strong>语法：</strong></p>
<p>domsetlaunchsecstate 域 –secrethdr hdr-filename<br>–secret secret-filename [–set-address 地址]</p>
<p>在客户内存中设置启动安全密钥。客户必须在其配置中启用launchSecurity类型并处于暂停状态。成功后，客户可以转换为运行状态。失败时，应销毁客户。</p>
<p><em>–secrethdr</em>指定包含base64编码的密钥头的文件名。头包括管理程序固件恢复启动密钥明文所需的工件。*–secret*指定包含base64编码的加密启动密钥的文件名。</p>
<p><em>–set-address</em>选项可用于指定客户内存中设置密钥的物理地址。如果未指定，地址将由管理程序确定。</p>
<p><strong>域内存统计</strong></p>
<p><strong>语法：</strong></p>
<p>dommemstat 域 [–period 秒] [[–config] [–live] | [–current]]</p>
<p>获取正在运行的域的内存统计信息。</p>
<p>这些字段的可用性取决于管理程序。不支持的字段将从输出中缺失。如果与较新版本的libvirtd通信，可能会出现其他字段。</p>
<p>字段说明：</p>
<ul>
<li><p>swap_in - 从交换空间读取的数据量（KiB）</p>
</li>
<li><p>swap_out - 写入交换空间的内存量（KiB）</p>
</li>
<li><p>major_fault - 需要磁盘IO的页面错误数</p>
</li>
<li><p>minor_fault - 其他页面错误数</p>
</li>
<li><p>unused - 系统未使用的内存量（KiB）</p>
</li>
<li><p>available - 域可见的可用内存量（KiB）</p>
</li>
<li><p>actual - 当前气球值（KiB）</p>
</li>
<li><p>rss - 运行域进程的驻留集大小（KiB）</p>
</li>
<li><p>usable - 可以通过气球回收而不会导致主机交换的内存量（KiB）</p>
</li>
<li><p>last-update - 上次统计信息更新的时间戳（秒）</p>
</li>
<li><p>disk_caches - 无需额外IO即可回收的内存量，通常是磁盘缓存（KiB）</p>
</li>
<li><p>hugetlb_pgalloc - 从域内启动的成功大页分配数</p>
</li>
<li><p>hugetlb_pgfail - 从域内启动的失败大页分配数</p>
</li>
</ul>
<p>对于带有内存气球的QEMU&#x2F;KVM，将可选的*–period<em>设置为大于0的值（秒）将允许气球驱动程序返回额外的统计信息，这些统计信息将由后续的dommemstat命令显示。将</em>–period*设置为0将停止气球驱动程序的收集，但不会清除气球驱动程序中的统计信息。至少需要QEMU&#x2F;KVM 1.5在主机上运行。</p>
<p><em>–live</em>、*–config<em>和</em>–current<em>标志仅在用于设置气球驱动程序的收集周期时有效。如果指定</em>–live<em>，则仅影响正在运行的客户机的收集周期。如果指定</em>–config<em>，则影响持久客户机的下一次启动。如果指定</em>–current<em>，则根据客户机的当前状态等效于</em>–live<em>或</em>–config*。</p>
<p>可以同时指定*–live<em>和</em>–config<em>标志，但</em>–current*是互斥的。如果未指定标志，行为因客户机状态而异。</p>
<p><strong>域名</strong></p>
<p><strong>语法：</strong></p>
<p>domname 域ID或UUID</p>
<p>将域ID（或UUID）转换为域名</p>
<p><strong>域电源管理挂起</strong></p>
<p><strong>语法：</strong></p>
<p>dompmsuspend 域 目标 [–duration 秒]</p>
<p>将正在运行的域挂起到以下状态之一（可能的<em>目标</em>值）：</p>
<ul>
<li><p>mem - 相当于S3 ACPI状态</p>
</li>
<li><p>disk - 相当于S4 ACPI状态</p>
</li>
<li><p>hybrid - RAM保存到磁盘但不关闭电源</p>
</li>
</ul>
<p><em>–duration</em>参数指定域挂起后唤醒前的秒数（另请参见dompmwakeup）。默认为0，表示无限挂起时间。（此功能目前不受任何管理程序驱动程序支持，应使用0。）</p>
<p>注意：此命令需要在域的客户机操作系统中配置并运行客户机代理。</p>
<p>请注意，至少对于QEMU，当使用目标磁盘时，域的进程将终止，并在libvirt请求唤醒域时启动新进程。因此，任何运行时更改（例如设备热插拔或内存设置）将丢失，除非这些更改是使用*–config*标志进行的。</p>
<p><strong>域电源管理唤醒</strong></p>
<p><strong>语法：</strong></p>
<p>dompmwakeup 域</p>
<p>从pmsuspended状态唤醒域（由dompmsuspend或客户机本身挂起）。向处于pmsuspended状态的客户注入唤醒，而不是等待先前请求的持续时间（如果有）过去。此操作不一定失败，如果域正在运行。</p>
<p><strong>域重命名</strong></p>
<p><strong>语法：</strong></p>
<p>domrename 域 新名称</p>
<p>重命名域。此命令将当前域名更改为第二个参数中指定的新名称。</p>
<p>注意：域必须处于非活动状态。</p>
<p><strong>域状态</strong></p>
<p><strong>语法：</strong></p>
<p>domstate 域 [–reason]</p>
<p>返回有关域的状态。*–reason*告诉virsh还打印状态的原因。</p>
<p><strong>域统计</strong></p>
<p><strong>语法：</strong></p>
<p>domstats [–raw] [–enforce] [–backing] [–nowait] [–state]<br>[–cpu-total] [–balloon] [–vcpu] [–interface]<br>[–block] [–perf] [–iothread] [–memory] [–dirtyrate] [–vm]<br>[[–list-active] [–list-inactive]<br>[–list-persistent] [–list-transient] [–list-running]<br>[–list-paused] [–list-shutoff] [–list-other]] | [域 …]</p>
<p>获取多个或所有域的统计信息。不带任何参数时，此命令打印所有域的所有可用统计信息。</p>
<p>要收集统计信息的域列表可以通过将域列为空格分隔的列表来限制，或通过指定其中一个过滤标志*–list-NNN*。（这些方法不能组合使用。）</p>
<p>默认情况下，某些返回的字段可能会通过一组漂亮的打印机转换为更人类友好的值。要抑制此行为，请使用*–raw*标志。</p>
<p>可以通过特定标志选择各个统计信息组。默认情况下，返回所有支持的统计信息组。支持的统计信息组标志包括：*–state<em>、</em>–cpu-total<em>、</em>–balloon<em>、</em>–vcpu<em>、</em>–interface<em>、</em>–block<em>、</em>–perf<em>、</em>–iothread<em>、</em>–memory<em>、</em>–dirtyrate<em>、</em>–vm*。</p>
<p>请注意，根据管理程序类型和版本或域状态，可能不会返回以下所有统计信息。</p>
<p>选择*–state*组时，返回以下字段：</p>
<ul>
<li><p>state.state - VM的状态，作为virDomainState枚举中的数字返回</p>
</li>
<li><p>state.reason - 进入给定状态的原因，作为与给定状态对应的virDomain*Reason枚举中的整数返回</p>
</li>
</ul>
<p><em>–cpu-total</em>返回：</p>
<ul>
<li><p>cpu.time - 此域的总CPU时间（纳秒）</p>
</li>
<li><p>cpu.user - 用户CPU时间（纳秒）</p>
</li>
<li><p>cpu.system - 系统CPU时间（纳秒）</p>
</li>
<li><p>cpu.haltpoll.success.time - CPU暂停轮询成功时间（纳秒）</p>
</li>
<li><p>cpu.haltpoll.fail.time - CPU暂停轮询失败时间（纳秒）</p>
</li>
<li><p>cpu.cache.monitor.count - 此域的缓存监视器数量</p>
</li>
<li><p>cpu.cache.monitor.&lt;num&gt;.name - 缓存监视器&lt;num&gt;的名称</p>
</li>
<li><p>cpu.cache.monitor.&lt;num&gt;.vcpus - 缓存监视器&lt;num&gt;的vcpu列表</p>
</li>
<li><p>cpu.cache.monitor.&lt;num&gt;.bank.count - 缓存监视器&lt;num&gt;中的缓存库数量</p>
</li>
<li><p>cpu.cache.monitor.&lt;num&gt;.bank.&lt;index&gt;.id - 主机为缓存监视器&lt;num&gt;中的库&lt;index&gt;分配的缓存ID</p>
</li>
<li><p>cpu.cache.monitor.&lt;num&gt;.bank.&lt;index&gt;.bytes - 域在缓存库&lt;index&gt;上使用的最后一级缓存的字节数</p>
</li>
</ul>
<p><em>–balloon</em>返回：</p>
<ul>
<li><p>balloon.current - 当前使用的内存（KiB）</p>
</li>
<li><p>balloon.maximum - 允许的最大内存（KiB）</p>
</li>
<li><p>balloon.swap_in - 从交换空间读取的数据量（KiB）</p>
</li>
<li><p>balloon.swap_out - 写入交换空间的内存量（KiB）</p>
</li>
<li><p>balloon.major_fault - 需要磁盘IO的页面错误数</p>
</li>
<li><p>balloon.minor_fault - 其他页面错误数</p>
</li>
<li><p>balloon.unused - 系统未使用的内存量（KiB）</p>
</li>
<li><p>balloon.available - 域可见的可用内存量（KiB）</p>
</li>
<li><p>balloon.rss - 运行域进程的驻留集大小（KiB）</p>
</li>
<li><p>balloon.usable - 可以通过气球回收而不会导致主机交换的内存量（KiB）</p>
</li>
<li><p>balloon.last-update - 上次统计信息更新的时间戳（秒）</p>
</li>
<li><p>balloon.disk_caches - 无需额外IO即可回收的内存量，通常是磁盘（KiB）</p>
</li>
<li><p>balloon.hugetlb_pgalloc - 通过virtio气球从域内启动的成功大页分配数</p>
</li>
<li><p>balloon.hugetlb_pgfail - 通过virtio气球从域内启动的失败大页分配数</p>
</li>
</ul>
<p><em>–vcpu</em>返回：</p>
<ul>
<li><p>vcpu.current - 当前在线虚拟CPU的数量</p>
</li>
<li><p>vcpu.maximum - 在线虚拟CPU的最大数量</p>
</li>
<li><p>vcpu.&lt;num&gt;.state - 虚拟CPU&lt;num&gt;的状态，作为virVcpuState枚举中的数字</p>
</li>
<li><p>vcpu.&lt;num&gt;.time - 虚拟CPU&lt;num&gt;花费的虚拟CPU时间（纳秒）</p>
</li>
<li><p>vcpu.&lt;num&gt;.wait - vCPU&lt;num&gt;线程在调度程序有其他任务在其前面运行时在运行队列中等待的时间（纳秒），在Linux上需要CONFIG_SCHED_INFO</p>
</li>
<li><p>vcpu.&lt;num&gt;.halted - 虚拟CPU&lt;num&gt;是否暂停：是或否（可能表示处理器空闲或甚至禁用，取决于架构）</p>
</li>
<li><p>vcpu.&lt;num&gt;.delay - vCPU&lt;num&gt;线程在调度程序有其他任务在其前面运行时在运行队列中等待的时间（纳秒）。作为窃取时间暴露给VM。</p>
</li>
</ul>
<p>此组统计信息还报告额外的管理程序来源的每vCPU统计信息。此组中的管理程序特定统计信息具有以下命名方案：</p>
<p>vcpu.&lt;num&gt;.$NAME.$TYPE</p>
<p><strong>$NAME</strong></p>
<p>管理程序提供的统计信息字段的名称</p>
<p><strong>$TYPE</strong></p>
<p>值的类型。返回以下类型：</p>
<p><strong>cur</strong></p>
<p>当前瞬时值</p>
<p><strong>sum</strong></p>
<p>聚合值</p>
<p><strong>max</strong></p>
<p>峰值值</p>
<p>返回值可以是无符号长整型或布尔型。含义是管理程序特定的。请参阅<em>--vm</em>组的免责声明，该组也由管理程序特定的统计信息组成。</p>
<p><em>–interface</em>返回：</p>
<ul>
<li><p>net.count - 此域上的网络接口数量</p>
</li>
<li><p>net.&lt;num&gt;.name - 接口&lt;num&gt;的名称</p>
</li>
<li><p>net.&lt;num&gt;.rx.bytes - 接收的字节数</p>
</li>
<li><p>net.&lt;num&gt;.rx.pkts - 接收的数据包数</p>
</li>
<li><p>net.&lt;num&gt;.rx.errs - 接收错误数</p>
</li>
<li><p>net.&lt;num&gt;.rx.drop - 丢弃的接收数据包数</p>
</li>
<li><p>net.&lt;num&gt;.tx.bytes - 发送的字节数</p>
</li>
<li><p>net.&lt;num&gt;.tx.pkts - 发送的数据包数</p>
</li>
<li><p>net.&lt;num&gt;.tx.errs - 发送错误数</p>
</li>
<li><p>net.&lt;num&gt;.tx.drop - 丢弃的发送数据包数</p>
</li>
</ul>
<p><em>–perf</em>返回所有启用的性能事件的统计信息：</p>
<ul>
<li><p>perf.cmt - 当前使用的缓存使用量（字节）</p>
</li>
<li><p>perf.mbmt - 从一级缓存到另一级的总系统带宽</p>
</li>
<li><p>perf.mbml - 内存控制器的内存流量带宽</p>
</li>
<li><p>perf.cpu_cycles - CPU周期计数（总&#x2F;经过）</p>
</li>
<li><p>perf.instructions - 指令计数</p>
</li>
<li><p>perf.cache_references - 缓存命中计数</p>
</li>
<li><p>perf.cache_misses - 缓存未命中计数</p>
</li>
<li><p>perf.branch_instructions - 分支指令计数</p>
</li>
<li><p>perf.branch_misses - 分支未命中计数</p>
</li>
<li><p>perf.bus_cycles - 总线周期计数</p>
</li>
<li><p>perf.stalled_cycles_frontend - 前端指令处理器管道中的停滞CPU周期计数</p>
</li>
<li><p>perf.stalled_cycles_backend - 后端指令处理器管道中的停滞CPU周期计数</p>
</li>
<li><p>perf.ref_cpu_cycles - 参考CPU周期计数</p>
</li>
<li><p>perf.cpu_clock - CPU时钟时间</p>
</li>
<li><p>perf.task_clock - 任务时钟时间</p>
</li>
<li><p>perf.page_faults - 页面错误计数</p>
</li>
<li><p>perf.context_switches - 上下文切换计数</p>
</li>
<li><p>perf.cpu_migrations - CPU迁移计数</p>
</li>
<li><p>perf.page_faults_min - 次要页面错误计数</p>
</li>
<li><p>perf.page_faults_maj - 主要页面错误计数</p>
</li>
<li><p>perf.alignment_faults - 对齐错误计数</p>
</li>
<li><p>perf.emulation_faults - 仿真错误计数</p>
</li>
</ul>
<p>有关每个事件的更多详细信息，请参阅perf命令。</p>
<p><em>–block</em>返回有关与每个域关联的磁盘的信息。使用*–backing*标志将此信息扩展到覆盖支持链中的所有资源，而不是默认情况下将信息限制为每个客户磁盘的活动层。列出的信息包括：</p>
<ul>
<li><p>block.count - 列出的块设备数量</p>
</li>
<li><p>block.&lt;num&gt;.name - 块设备&lt;num&gt;的目标名称（如果存在*–backing*，则多个条目使用相同的名称）</p>
</li>
<li><p>block.&lt;num&gt;.backingIndex - 当存在*–backing*时，与域XML中列出的&lt;backingStore&gt;索引匹配</p>
</li>
<li><p>block.&lt;num&gt;.path - 块设备&lt;num&gt;的文件源，如果是本地文件或块设备</p>
</li>
<li><p>block.&lt;num&gt;.rd.reqs - 读取请求数</p>
</li>
<li><p>block.&lt;num&gt;.rd.bytes - 读取字节数</p>
</li>
<li><p>block.&lt;num&gt;.rd.times - 读取花费的总时间（纳秒）</p>
</li>
<li><p>block.&lt;num&gt;.wr.reqs - 写入请求数</p>
</li>
<li><p>block.&lt;num&gt;.wr.bytes - 写入字节数</p>
</li>
<li><p>block.&lt;num&gt;.wr.times - 写入花费的总时间（纳秒）</p>
</li>
<li><p>block.&lt;num&gt;.fl.reqs - 总刷新请求数</p>
</li>
<li><p>block.&lt;num&gt;.fl.times - 缓存刷新花费的总时间（纳秒）</p>
</li>
<li><p>block.&lt;num&gt;.errors - 仅Xen：’oo_req’值</p>
</li>
<li><p>block.&lt;num&gt;.allocation - 最高写入扇区的偏移（字节）</p>
</li>
<li><p>block.&lt;num&gt;.capacity - 源文件的逻辑大小（字节）</p>
</li>
<li><p>block.&lt;num&gt;.physical - 源文件的物理大小（字节）</p>
</li>
<li><p>block.&lt;num&gt;.threshold - 传递VIR_DOMAIN_EVENT_ID_BLOCK_THRESHOLD事件的阈值（字节）。参见domblkthreshold。</p>
</li>
</ul>
<p><em>–iothread</em>返回有关运行客户机上的IOThread的信息（如果管理程序支持）。</p>
<p>每个线程的“poll-max-ns”是允许每个轮询间隔发生的最大纳秒数。轮询间隔是允许线程处理数据的时间段，然后客户将其CPU量子返回给主机。设置得太小的值不允许IOThread在CPU上运行足够长的时间来处理数据。设置得太高的值会消耗过多的CPU时间，每个IOThread无法允许CPU上运行的其他线程获得时间。轮询间隔不可用于统计目的。</p>
<ul>
<li><strong>iothread.count</strong> - 后续列表中的IOThread的最大数量</li>
</ul>
<p>作为无符号整数。列表中的每个IOThread将使用其iothread_id值作为&lt;id&gt;。如果轮询值不受支持，则&lt;id&gt;条目可能少于iothread.count值。</p>
<ul>
<li><p>iothread.&lt;id&gt;.poll-max-ns - &lt;id&gt; IOThread使用的最大轮询时间（纳秒）。值为0（零）表示轮询被禁用。</p>
</li>
<li><p>iothread.&lt;id&gt;.poll-grow - 轮询时间增长值。值为0（零）表示增长由管理程序管理。</p>
</li>
<li><p>iothread.&lt;id&gt;.poll-shrink - 轮询时间缩小值。值为（零）表示缩小由管理程序管理。</p>
</li>
</ul>
<p><em>–memory</em>返回：</p>
<ul>
<li><p>memory.bandwidth.monitor.count - 此域的内存带宽监视器数量</p>
</li>
<li><p>memory.bandwidth.monitor.&lt;num&gt;.name - 监视器&lt;num&gt;的名称</p>
</li>
<li><p>memory.bandwidth.monitor.&lt;num&gt;.vcpus - 监视器&lt;num&gt;的vcpu列表</p>
</li>
<li><p><strong>memory.bandwidth.monitor.&lt;num&gt;.node.count</strong> - 内存</p>
</li>
</ul>
<p>控制器在监视器&lt;num&gt;中的数量</p>
<ul>
<li><p>memory.bandwidth.monitor.&lt;num&gt;.node.&lt;index&gt;.id - 主机为监视器&lt;num&gt;中的控制器&lt;index&gt;分配的内存控制器ID</p>
</li>
<li><p>memory.bandwidth.monitor.&lt;num&gt;.node.&lt;index&gt;.bytes.local - 通过@vcpus消耗的字节数，这些vcpu通过属于调度主机CPU的同一处理器中的内存控制器。</p>
</li>
<li><p>memory.bandwidth.monitor.&lt;num&gt;.node.&lt;index&gt;.bytes.total - 通过@vcpus消耗的总字节数，这些vcpu通过所有内存控制器，无论是本地还是远程控制器。</p>
</li>
</ul>
<p><em>–dirtyrate</em>返回：</p>
<ul>
<li><p>dirtyrate.calc_status - 上次内存脏页率计算的状态，作为virDomainDirtyRateStatus枚举中的数字返回。</p>
</li>
<li><p>dirtyrate.calc_start_time - 上次内存脏页率计算的开始时间。</p>
</li>
<li><p>dirtyrate.calc_period - 上次内存脏页率计算的周期。</p>
</li>
<li><p>dirtyrate.megabytes_per_second - 计算的内存脏页率（MiB&#x2F;s）。</p>
</li>
<li><p>dirtyrate.calc_mode - 上次测量使用的计算模式（page-sampling&#x2F;dirty-bitmap&#x2F;dirty-ring）</p>
</li>
<li><p>dirtyrate.vcpu.&lt;num&gt;.megabytes_per_second - 虚拟CPU的内存脏页率（MiB&#x2F;s）</p>
</li>
</ul>
<p><em>–vm</em>返回：</p>
<p><em>--vm</em>选项启用管理程序特定统计信息的报告。字段的命名和含义完全取决于管理程序。</p>
<p>此组中的统计信息具有以下命名方案：</p>
<p>vm.$NAME.$TYPE</p>
<p><strong>$NAME</strong></p>
<p>管理程序提供的统计信息字段的名称</p>
<p><strong>$TYPE</strong></p>
<p>值的类型。返回以下类型：</p>
<p><strong>cur</strong></p>
<p>当前瞬时值</p>
<p><strong>sum</strong></p>
<p>聚合值</p>
<p><strong>max</strong></p>
<p>峰值值</p>
<p>返回值可以是无符号长整型或布尔型。</p>
<p><strong>警告</strong>：此组中报告的统计信息是运行时收集的，源自管理程序，因此不属于libvirt的常规稳定API策略。</p>
<p>Libvirt无法保证从外部源报告的统计信息将在管理程序的未来版本中存在，或命名或含义保持一致。但是，对现有字段的更改预计很少。</p>
<p>选择特定的统计信息组不保证守护程序支持所选统计信息组。标志<em>--enforce</em>强制命令在守护程序不支持所选组时失败。</p>
<p>在收集统计信息时，libvirtd可能会等待一段时间，如果给定域上已有另一个作业正在运行以完成。这可能导致不必要的延迟传递统计信息。使用<em>--nowait</em>抑制此行为。另一方面，此类域可能会缺少某些统计信息。</p>
<p><strong>域时间</strong></p>
<p><strong>语法：</strong></p>
<p>domtime 域 { [–now] [–pretty] [–sync] [–time 时间] }</p>
<p>获取或设置域的系统时间。当不带任何参数（但<em>域</em>）运行时，打印域的当前系统时间。<em>--pretty</em>修饰符可用于以更人类可读的形式打印时间。</p>
<p>当指定<em>--time</em>时间时，不获取域的时间，而是设置它。<em>--now</em>修饰符的作用类似于<em>--time</em> $now的别名，这意味着它设置virsh运行的主机上当前的时间。在这两种情况下（设置和获取），时间是以1970-01-01纪元以来的秒数为单位的UTC时间。<em>--sync</em>修改设置行为：忽略传递的时间，而是从域的RTC读取要设置的时间。请注意，某些管理程序可能需要配置客户代理才能获取或设置客户时间。</p>
<p><strong>域UUID</strong></p>
<p><strong>语法：</strong></p>
<p>domuuid 域名或ID</p>
<p>将域名或ID转换为域UUID</p>
<p><strong>域XML从原生格式转换</strong></p>
<p><strong>语法：</strong></p>
<p>domxml-from-native 格式 配置</p>
<p>将原生客户配置格式<em>格式</em>的文件<em>配置</em>转换为域XML格式。对于QEMU&#x2F;KVM管理程序，<em>格式</em>参数必须为qemu-argv。对于Xen管理程序，<em>格式</em>参数可以是xen-xm、xen-xl或xen-sxpr。对于LXC管理程序，<em>格式</em>参数必须为lxc-tools。对于VMware&#x2F;ESX管理程序，<em>格式</em>参数必须为vmware-vmx。对于Bhyve管理程序，<em>格式</em>参数必须为bhyve-argv。</p>
<p><strong>域XML转换为原生格式</strong></p>
<p><strong>语法：</strong></p>
<p>domxml-to-native 格式 { [–xml] xml | –domain 域名或ID或UUID }</p>
<p>将文件<em>xml</em>转换为域XML格式，或将现有的<em>--domain</em>转换为名为<em>格式</em>的原生客户配置格式。<em>xml</em>和<em>--domain</em>参数是互斥的。有关<em>格式</em>参数的类型，请参阅domxml-from-native。</p>
<p><strong>转储</strong></p>
<p><strong>语法：</strong></p>
<p>dump 域 核心文件路径 [–bypass-cache]<br>{ [–live] | [–crash] | [–reset] }<br>[–verbose] [–memory-only] [–format 字符串]</p>
<p>将域的核心转储到文件以进行分析。如果指定<em>--live</em>，域在核心转储完成之前继续运行，而不是提前暂停。如果指定<em>--crash</em>，域以崩溃状态停止，而不仅仅是保持在暂停状态。如果指定<em>--reset</em>，域在成功转储后重置。注意，这三个开关是互斥的。如果指定<em>--bypass-cache</em>，保存将避免文件系统缓存，尽管这可能会减慢操作速度。如果指定<em>--memory-only</em>，文件是elf文件，仅包含域的内存和CPU通用寄存器值。如果域直接使用主机设备，这将非常有用。<em>--format</em> <em>字符串</em>用于指定“memory-only”转储的格式，<em>字符串</em>可以是以下之一：elf、kdump-zlib（zlib压缩的kdump压缩格式）、kdump-lzo（lzo压缩的kdump压缩格式）、kdump-snappy（snappy压缩的kdump压缩格式）、win-dmp（Windows完整崩溃转储格式）。</p>
<p>可以使用domjobinfo virsh命令监视进度，并使用domjobabort命令（由另一个virsh实例发送）取消。另一个选项是向运行dump命令的virsh进程发送SIGINT（通常使用Ctrl-C）。<em>--verbose</em>显示转储的进度。</p>
<p>注意：某些管理程序可能需要用户手动确保<em>核心文件路径</em>参数指定的文件和路径具有适当的权限。</p>
<p>注意：旧kvmdump格式的崩溃转储正在过时，自其版本6.1.0以来无法由崩溃实用程序加载和处理。需要<em>--memory-only</em>选项以生成可由崩溃实用程序稍后处理的有效ELF文件。</p>
<p><strong>转储XML</strong></p>
<p><strong>语法：</strong></p>
<p>dumpxml [–inactive] [–security-info] [–update-cpu] [–migratable]<br>[–xpath 表达式] [–wrap] 域</p>
<p>将域信息作为XML转储输出到stdout，此格式可由create命令使用。可以使用影响XML转储的其他选项。<em>--inactive</em>告诉virsh转储将在域下次启动时使用的域配置，而不是当前域配置。使用<em>--security-info</em>还将包括XML转储中的安全敏感信息。<em>--update-cpu</em>根据主机CPU更新域CPU要求。使用<em>--migratable</em>可以请求适合迁移的XML，即与较旧版本的libvirt兼容，并可能使用内部运行时选项进行修改。此选项可能会自动启用其他选项（<em>--update-cpu</em>、<em>--security-info</em>，…）根据需要。</p>
<p>如果<strong>--xpath</strong>参数提供XPath表达式，则将对输出XML求值，并仅打印匹配的节点。默认行为是将每个匹配节点打印为独立文档，但是为了便于进一步处理，<strong>--wrap</strong>参数将使匹配节点包装在公共根节点中。</p>
<p><strong>编辑</strong></p>
<p><strong>语法：</strong></p>
<p>edit 域</p>
<p>编辑域的XML配置文件，这将影响客户机的下次启动。</p>
<p>这等效于：</p>
<p>virsh dumpxml –inactive –security-info 域 &gt; 域.xml</p>
<p>vi 域.xml（或使用其他文本编辑器进行更改）</p>
<p>virsh define 域.xml</p>
<p>不同之处在于它进行了一些错误检查。</p>
<p>使用的编辑器可以由$VISUAL或$EDITOR环境变量提供，默认为vi。</p>
<p><strong>模拟器绑定</strong></p>
<p><strong>语法：</strong></p>
<p>emulatorpin 域 [CPU列表] [[–live] [–config] | [–current]]</p>
<p>查询或更改域的模拟器线程到主机物理CPU的绑定。</p>
<p>有关<em>CPU列表</em>的信息，请参见vcpupin。</p>
<p>如果指定<em>--live</em>，则影响正在运行的客户机。如果指定<em>--config</em>，则影响持久客户机的下一次启动。如果指定<em>--current</em>，则根据客户机的当前状态等效于<em>--live</em>或<em>--config</em>。可以同时指定<em>--live</em>和<em>--config</em>标志（如果存在<em>CPU列表</em>），但<em>--current</em>是互斥的。如果未指定标志，行为因管理程序而异。</p>
<p><strong>事件</strong></p>
<p><strong>语法：</strong></p>
<p>event {[域] { 事件 | –all } [–loop] [–timeout 秒] [–timestamp] | –list}</p>
<p>等待一类域事件发生，并在事件发生时打印适当的详细信息。事件可以选择由<em>域</em>过滤。仅使用<em>--list</em>作为参数将提供此客户端已知的可能<em>事件</em>值的列表，尽管连接可能不允许注册所有这些事件。也可以使用<em>--all</em>代替<em>事件</em>一次注册所有可能的事件类型。</p>
<p>默认情况下，此命令是一次性的，一旦事件发生即返回成功；您可以发送SIGINT（通常通过Ctrl-C）立即退出。如果指定<em>--timeout</em>，则命令在<em>秒</em>后放弃等待事件。使用<em>--loop</em>，命令打印所有事件，直到超时或中断键。</p>
<p>当使用<em>--timestamp</em>时，将在事件之前打印人类可读的时间戳。</p>
<p><strong>获取用户SSH密钥</strong></p>
<p><strong>语法：</strong></p>
<p>get-user-sshkeys 域 用户</p>
<p>打印给定<em>用户</em>在客户<em>域</em>中的SSH授权密钥。请注意，文件中的条目具有*sshd(8)*定义的内部结构，virsh&#x2F;libvirt将密钥视为不透明字符串，即不解释它们。</p>
<p><strong>客户代理超时</strong></p>
<p><strong>语法：</strong></p>
<p>guest-agent-timeout 域 [–timeout 值]</p>
<p>设置等待客户代理命令响应的时长。默认情况下，代理命令无限期阻塞等待响应。值必须是正值（等待给定的秒数）或以下值之一：</p>
<ul>
<li><p>-2 - 无限期阻塞等待结果（当省略--timeout时使用），</p>
</li>
<li><p>-1 - 将超时重置为默认值（当前在libvirt守护程序中定义为5秒），</p>
</li>
<li><p>0 - 完全不等待，</p>
</li>
</ul>
<p>在所有基于客户代理的API中，当发生超时时，如果实际命令已发送到客户代理，则返回的错误代码将为VIR_ERR_AGENT_COMMAND_TIMEOUT。</p>
<p><strong>客户信息</strong></p>
<p><strong>语法：</strong></p>
<p>guestinfo 域 [–user] [–os] [–timezone] [–hostname] [–filesystem]<br>[–disk] [–interface]</p>
<p>从客户代理的角度打印有关客户的信息。请注意，此命令需要在域的客户操作系统中配置并运行客户代理。</p>
<p>当不带任何参数运行时，此命令打印客户代理当时支持的所有信息类型，省略不可用的类型。在这种情况下总是报告成功。</p>
<p>您可以通过指定一个或多个标志来限制返回的信息类型。可用的信息类型标志包括<em>--user</em>、<em>--os</em>、<em>--timezone</em>、<em>--hostname</em>、<em>--filesystem</em>、<em>--disk</em>、<em>--interface</em>和<em>--load</em>。如果明确请求的信息类型当时不受客户代理支持，则进程将提供退出代码1。</p>
<p>请注意，根据管理程序类型和在域内运行的客户代理的版本，可能不会返回以下所有信息。</p>
<p>选择<em>--user</em>信息类型时，可能会返回以下字段：</p>
<ul>
<li><p>user.count - 此域上的活动用户数</p>
</li>
<li><p>user.&lt;num&gt;.name - 用户&lt;num&gt;的用户名</p>
</li>
<li><p>user.&lt;num&gt;.domain - 用户&lt;num&gt;的域（可能仅在某些客户类型上存在）</p>
</li>
<li><p>user.&lt;num&gt;.login-time - 用户&lt;num&gt;的登录时间（自纪元以来的毫秒数）</p>
</li>
</ul>
<p><em>--os</em>返回：</p>
<ul>
<li><p>os.id - 标识操作系统的字符串</p>
</li>
<li><p>os.name - 操作系统的名称</p>
</li>
<li><p>os.pretty-name - 操作系统的漂亮名称</p>
</li>
<li><p>os.version - 操作系统的版本</p>
</li>
<li><p>os.version-id - 操作系统的版本ID</p>
</li>
<li><p>os.kernel-release - 操作系统内核的发布</p>
</li>
<li><p>os.kernel-version - 操作系统内核的版本</p>
</li>
<li><p>os.machine - 机器硬件名称</p>
</li>
<li><p>os.variant - 操作系统的特定变体或版本</p>
</li>
<li><p>os.variant-id - 操作系统的特定变体或版本的ID</p>
</li>
</ul>
<p><em>--timezone</em>返回：</p>
<ul>
<li><p>timezone.name - 时区的名称</p>
</li>
<li><p>timezone.offset - 与UTC的偏移（秒）</p>
</li>
</ul>
<p><em>--hostname</em>返回：</p>
<ul>
<li>hostname - 域的主机名</li>
</ul>
<p><em>--filesystem</em>返回：</p>
<ul>
<li><p>fs.count - 此域上定义的文件系统数量</p>
</li>
<li><p>fs.&lt;num&gt;.mountpoint - 文件系统&lt;num&gt;的挂载点路径</p>
</li>
<li><p>fs.&lt;num&gt;.name - 客户中的设备名称（例如sda1）用于文件系统&lt;num&gt;</p>
</li>
<li><p>fs.&lt;num&gt;.fstype - 文件系统&lt;num&gt;的类型</p>
</li>
<li><p>fs.&lt;num&gt;.total-bytes - 文件系统&lt;num&gt;的总大小</p>
</li>
<li><p>fs.&lt;num&gt;.used-bytes - 文件系统&lt;num&gt;中使用的字节数</p>
</li>
<li><p>fs.&lt;num&gt;.disk.count - 文件系统&lt;num&gt;目标的磁盘数量</p>
</li>
<li><p>fs.&lt;num&gt;.disk.&lt;num&gt;.alias - 磁盘&lt;num&gt;的设备别名（例如sda）</p>
</li>
<li><p>fs.&lt;num&gt;.disk.&lt;num&gt;.serial - 磁盘&lt;num&gt;的序列号</p>
</li>
<li><p>fs.&lt;num&gt;.disk.&lt;num&gt;.device - 磁盘&lt;num&gt;的设备节点</p>
</li>
</ul>
<p><em>--disk</em>返回：</p>
<ul>
<li><p>disk.count - 此域上定义的磁盘数量</p>
</li>
<li><p>disk.&lt;num&gt;.name - 设备节点（Linux）或设备UNC（Windows）</p>
</li>
</ul>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://watsonlu6.github.io/libvirt%E6%96%87%E6%A1%A3/13-virsh%E4%BD%BF%E7%94%A8/" title="1 libvirt概述" target="_blank" rel="external">https://watsonlu6.github.io/libvirt文档/13-virsh使用/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/watsonLu6/" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/watsonLu6/" target="_blank"><span class="text-dark">watson</span><small class="ml-1x">Cloud computing development engineer</small></a></h3>
        <div>内心要狂热，头脑要冷静，四肢要发达</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    
    <li class="next">
      <a href="/libvirt%E6%96%87%E6%A1%A3/12-libvirt%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/" title="12 libvirt使用示例"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/watsonLu6/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>